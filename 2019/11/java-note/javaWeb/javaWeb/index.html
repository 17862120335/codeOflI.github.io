<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon128.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon16.ico?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <link rel="alternate" href="/atom.xml" title="nicolas" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="[TOC]web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/…12345&amp;lt;%	pageContext.setAttribute(&quot;APP_PATH&quot;, request.getContex">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="javaWeb">
<meta property="og:url" content="https://codeofli.github.io/2019/11/java-note/javaWeb/javaWeb/index.html">
<meta property="og:site_name" content="nicolas">
<meta property="og:description" content="[TOC]web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/…12345&amp;lt;%	pageContext.setAttribute(&quot;APP_PATH&quot;, request.getContex">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-12T02:57:37.399Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javaWeb">
<meta name="twitter:description" content="[TOC]web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/…12345&amp;lt;%	pageContext.setAttribute(&quot;APP_PATH&quot;, request.getContex">
  <link rel="canonical" href="https://codeofli.github.io/2019/11/java-note/javaWeb/javaWeb/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>javaWeb | nicolas</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">nicolas</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Yesterday you said tomorow.</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
      
        
      
        
      
        
          
        
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">18</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
      
        
      
        
          
        
      
        
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">8</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
      
        
          
        
      
        
      
        
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">27</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/codeOflI/codeOflI.github.io/tree/dev" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://codeofli.github.io/2019/11/java-note/javaWeb/javaWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nicolas lee">
      <meta itemprop="description" content="Yesterday you said tomorow.">
      <meta itemprop="image" content="/assets/img/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nicolas">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">javaWeb

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-12 10:39:06 / 修改时间：10:57:37" itemprop="dateCreated datePublished" datetime="2019-11-12T10:39:06+08:00">2019-11-12</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span></span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC]</p><h1 id="web路径"><a href="#web路径" class="headerlink" title="web路径"></a>web路径</h1><p> <strong>web路径：</strong><br>1.不<strong>以/开始的相对路径</strong>，找资源，<strong>以当前资源的路径为基准</strong>，经常容易出问题<br>2.<strong>以/开始的开始的相对路径</strong>，找资源，<strong>以服务器为标准（http//localhost/端口号)需要加项目名</strong>;<br>就是http//localhost/端口号/crud/…</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">	<span class="attr">pageContext.setAttribute</span>("<span class="attr">APP_PATH</span>", <span class="attr">request.getContextPath</span>());</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line">	$&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css</span><br><span class="line">  --&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>



<h1 id="1JSP-动态网页"><a href="#1JSP-动态网页" class="headerlink" title="1JSP:动态网页"></a>1JSP:动态网页</h1><p>静态、动态：<br>1.不用 和 是否有“动感”混为一谈<br>2.是否 随着 时间、地点、用户操作  的 改变而改变</p>
<p>动态网页 需要使用到 服务端脚本语言（JSP）</p>
<p>2架构<br>CS：Client Server<br>CS不足：<br>a.如果 软件升级， 那么全部软件都需要升级<br>b.维护麻烦：需要维护每一台 客户端软件<br>c.每一台客户端 都需要安装 客户端软件</p>
<p>BS ：Broswer Server<br>客户端可以通过 浏览器  直接访问服务端 </p>
<p>注意：bs和cs各有优势。</p>
<h2 id="3-tomcat解压后目录："><a href="#3-tomcat解压后目录：" class="headerlink" title="3.tomcat解压后目录："></a>3.tomcat解压后目录：</h2><p>bin:可执行文件（startup.bat    shutdown.bat）<br>conf:配置文件（server.xml）<br>lib：tomcat依赖的jar文件<br>log:日志文件（记录出错等信息）<br>temp:临时文件<br>webapps：可执行的项目（将我们开发的项目 放入该目录）<br>work:存放由jsp翻译成的java,以及编辑成的class文件(jsp  -&gt;java -&gt;class)</p>
<p>4.配置tomcat<br>a.配置jdk  (必须配置JAVA_HOME)<br>java_home  classPath  path<br>b.配置catalina_home</p>
<p>双击bin/startup.bat启动tomacat，<br>常见错误： 可能与其他服务的端口号冲突<br>tomcat端口号默认8080 （此端口号较为常见，容易冲突），建议修改此端口 （8888）</p>
<p>修改端口号：</p>
<p>5.访问tomcat<br><a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p>
<p>常见状态码：<br>200：一切正常<br>300/301: 页面重定向 （跳转）<br>404:资源不存在<br>403：权限不足 （如果访问a目录，但是a目录设置 不可见）<br>500：服务器内部错误（代码有误）<br>其他编码：积累</p>
<p>jsp：在html中嵌套的java代码 </p>
<p> 在项目/WEB-INF/web.xml中设置 默认的 初始页面<br>     <welcome-file-list></welcome-file-list></p>
<pre><code>    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;</code></pre><p>6.虚拟路径<br>a.方式一<br>将web项目配置到 webapps以外的目录<br>conf/server.xml中配置<br>host标签中：<br><context docbase="D:\study\JspProject" path="/JspProject"></context></p>
<p>docBase：实际路径<br>path：虚拟路径  （绝对路径、相对路径【相对于webapps】）<br>重启</p>
<p>b.方式二<br>D:\study\apache-tomcat-8.5.30\conf\Catalina\localhost<br>中新建   “项目名.xml”中新增一行：<br><context docbase="D:\study\JspProject" path="/JspProject"></context></p>
<p>7.虚拟主机<br>通过<a href="http://www.test.com访问本机" target="_blank" rel="noopener">www.test.com访问本机</a><br>a. conf/server.xml</p>
  <engine name="Catalina" defaulthost="www.test.com">

<pre><code>&lt;Host appBase=&quot;D:\study\JspProject&quot; name=&quot;www.test.com&quot;&gt;
      &lt;Context docBase=&quot;D:\study\JspProject&quot;   path=&quot;/&quot;/&gt;
&lt;/Host&gt;</code></pre><p>b.C:\Windows\System32\drivers\etc\host<br>增加<br>127.0.0.1       <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></p>
<p>流程：<br><a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a> -&gt; host找映射关系 -&gt;server.xml找Engine的defaultHost -&gt;通过”/“映射到D:\study\JspProject<br>为了后续学习，将以上恢复成默认</p>
<p>7.JSP执行流程<br>jsp- java(Servlet文件) -class<br>D:\study\apache-tomcat-8.5.30\work\Catalina\localhost\JspProject\org\apache\jsp</p>
<h2 id="Jsp-和Servlet-可以相互转换"><a href="#Jsp-和Servlet-可以相互转换" class="headerlink" title="Jsp 和Servlet 可以相互转换"></a>Jsp 和Servlet 可以相互转换</h2><p>因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时  会重新的翻译、编译。</p>
<h1 id="1-使用Eclipse开发Web项目"><a href="#1-使用Eclipse开发Web项目" class="headerlink" title="1.使用Eclipse开发Web项目"></a>1.使用Eclipse开发Web项目</h1><p>(JSP项目)  tomcat</p>
<ol start="2">
<li>在Eclipse中创建的Web项目：<br>浏览器可以直接访问 WebContent中的文件，<br>例如<a href="http://localhost:8888/MyJspProject/index1.jsp" target="_blank" rel="noopener">http://localhost:8888/MyJspProject/index1.jsp</a><br>其中的index1.jsp就在WebContent目录中；<br>但是WEB-INF中的文件  无法通过客户端（浏览器）直接访问，只能通过请求转发来访问</li>
</ol>
<p>注意：并不是 任何的内部跳转都能访问WEB-INF；原因是 跳转有2种方式：请求转发 、重定向</p>
<p>3.配置tomcat运行时环境<br>    jsp&lt;-&gt;Servlet<br>a.将tomcat/lib中的servlet-api.jar加入项目的构建路径<br>b.右键项目-&gt;Build Path -&gt; Add library -&gt;Server Runtime</p>
<p>4.部署tomcat<br>在servers面板 新建一个 tomcat实例 ，  再在该实例中 部署项目（右键-add）<br>之后运行</p>
<p>注意：一般建议 将eclipse中的tomcat与 本地tomcat的配置信息保持一致： 将eclipse中的tomcat设置为托管模式：【第一次】创建tomcat实例之后， 双击，选择Server Location的第二项</p>
<p>5.统一字符集编码<br>a.编码分类：<br>设置jsp文件的编码（jsp文件中的pageEncoding属性）：  jsp -&gt; java<br>设置浏览器读取jsp文件的编码（jsp文件中content属性）<br>一般将上述设置成 一致的编码，推荐使用UTF-8<br>文本编码：<br>    i.将整个eclipse中的文件 统一设置 （推荐）<br>    ii.设置 某一个项目<br>    iii.设置单独文件</p>
<p>6.</p>
<h1 id="JSP的页面元素：-HTML-java代码（脚本Scriptlet）、指令、注释"><a href="#JSP的页面元素：-HTML-java代码（脚本Scriptlet）、指令、注释" class="headerlink" title="JSP的页面元素： HTML  java代码（脚本Scriptlet）、指令、注释"></a>JSP的页面元素： HTML  java代码（脚本Scriptlet）、指令、注释</h1><p>a.脚本Scriptlet<br>    i.<br>        &lt;%<br>                局部变量、java语句<br>        %&gt;</p>
<pre><code>ii.
    &lt;%!
            全局变量、定义方法
    %&gt;

iii.

    &lt;%=输出表达式 %&gt;</code></pre><p>一般而言，修改web.xml、配置文件、java  需要重启tomcat服务<br>但是如果修改 Jsp\html\css\js ，不需要重启</p>
<p>注意，out.println()不能回车； 要想回车：“<br>”，即out.print() &lt;%= %&gt; 可以直接解析html代码</p>
<p>b.指令<br>page指令</p>
<p>&lt;%@ page  ….%&gt;<br>page指定的属性：<br>language:jsp页面使用的脚本语言<br>import:导入类<br>pageEncoding:jsp文件自身编码  jsp -&gt;java<br>contentType:浏览器解析jsp的编码<br>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”<br>    pageEncoding=”UTF-8”  import=”java.util.Date” %&gt;</p>
<p>c.注释<br>    html注释<!-- -->  ,可以被客户 通过浏览器查看源码 所观察到<br>    java注释//     /<em>…</em>/<br>    jsp注释&lt;%– –%&gt;</p>
<h2 id="7-JSP九大内置对象"><a href="#7-JSP九大内置对象" class="headerlink" title="7.JSP九大内置对象"></a>7.JSP九大内置对象</h2><p>（自带的，不需要new 也能使用的对象）</p>
<p>out：输出对象，向客户端输出内容<br>request：请求对象；存储“客户端向服务端发送的请求信息”<br>request对象的常见方法：<br>String getParameter(String name) :根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值）<br>String[] getParameterValues(String name): 根据请求的字段名key ，返回多个字段值value  （checkbox）<br>void setCharacterEncoding(“编码格式utf-8”) ：设置post方式的请求编码  （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8）<br>getRequestDispatcher(“b.jsp”).forward(request,response) ;  ：请求转发 的方式跳转页面   A - &gt; B<br>ServletContext getServerContext():获取项目的ServletContext对象</p>
<p>示例：<br>注册<br>register.jsp  ，show.jsp</p>
<p><a href="http://localhost:8888/MyJspProject/show.jsp?uname=aa&amp;upwd=123&amp;uage=22&amp;uhobbies=%E7%AF%AE%E7%90%83" target="_blank" rel="noopener">http://localhost:8888/MyJspProject/show.jsp?uname=aa&amp;upwd=123&amp;uage=22&amp;uhobbies=%E7%AF%AE%E7%90%83</a><br>        连接/文件？参数名1=参数值1 &amp; 参数名2=参数值2 &amp; 参数名1=参数值1 </p>
<p>get提交方式:  method=”get” 和 地址栏 、超链接(<a href="xx">)请求方式 默认都属于get提交方式</a></p>
<p>get与post请求方式的区别：<br>a.   get方式 在地址栏显示 请求信息  (但是地址栏能够容纳的 信息有限，4-5KB；如果请求数据存在大文件，图片等  会出现地址栏无法容纳全部的数据而出错) ；post不会显示<br>b.   文件上传操作，必须是post<br>推荐使用post</p>
<p>8.统一请求的编码 request<br>get方式请求 如果出现乱码，解决：<br>a.统一每一个变量的 编码 （不推荐）<br>    new String(  旧编码，新编码);<br>    name = new String(name.getBytes(“iso-8859-1”),”utf-8”);</p>
<p>b. 修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8）<br>建议 使用tomcat时， 首先在server.xml中 统一get方式的编码.. URIEncoding=”UTF-8”</p>
<p>tomcat7 (iso-8859-1)</p>
<p>tomcat8（utf-8）</p>
<p>post<br>request.setCharacterEncoding(“utf-8”) ;</p>
<p>1<br>response :响应对象<br>提供的方法：<br>void addCookie( Cookie cookie ); 服务端向客户端增加cookie对象<br>void sendRedirect(String location ) throws IOException; :页面跳转的一种方式（重定向）<br>void setContetType(String type):设置服务端响应的编码（设置服务端的contentType类型）</p>
<p>示例：登陆<br>login.jsp  -&gt; check.jsp  -&gt;success.jsp</p>
<pre><code>请求转发            重定向</code></pre><p>地址栏是否改变        不变(check.jsp)        改变(success.jsp)</p>
<p>是否保留第一次        保留            不保留        –4种范围对象<br>请求时的数据</p>
<p>请求的次数        1            2</p>
<p>跳转发生的位置        服务端            客户端发出的第二次跳转</p>
<p>转发、重定向：</p>
<p>转发：<br>    张三（客户端）     -&gt;    【 服务窗口 A （服务端 ）    -&gt;  服务窗口B  】</p>
<p>重定向：<br>    张三（客户端）       -&gt;     服务窗口 A （服务端 ） -&gt;去找B</p>
<pre><code>张三（客户端）    -&gt;     服务窗口 B （服务端 ） -&gt;结束</code></pre><ol start="2">
<li>session(服务端)<br>Cookie（客户端，不是内置对象）:Cookie是由 服务端生成的 ，再发送给客户端保存。<br>相当于 本地缓存的作用： 客户端(hello.mp4,zs/abc)-&gt;服务端(hello.mp4；zs/abc)<br>作用：提高访问服务端的效率，但是安全性较差。</li>
</ol>
<p>Cookie：    name=value<br>javax.servlet.http.Cookie<br>public Cookie(String name,String value)<br>String getName()：获取name<br>String getValue():获取value<br>void setMaxAge(int expiry);最大有效期 （秒）</p>
<p>服务端准备Cookie：<br>    response.addCookie(Cookie cookie)<br>页面跳转（转发，重定向）<br>客户端获取cookie:  request.getCookies();</p>
<p>a.服务端增加cookie :response对象；客户端获取对象：request对象<br>b.不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到</p>
<p>通过F12可以发现  除了自己设置的Cookie对象外，还有一个name为 JSESSIONID的cookie</p>
<p>建议 cookie只保存  英文数字，否则需要进行编码、解码</p>
<ol start="3">
<li>使用Cookie实现  记住用户名  功能</li>
</ol>
<p>4.session :会话<br>a.浏览网站：开始-关闭<br>b.购物：  浏览、付款、退出<br>c.电子邮件：浏览、写邮件、退出<br>    开始-结束</p>
<p>session机制：</p>
<p>客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；<br>并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);<br>服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；<br>然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；<br>因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID）</p>
<p>客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID  去服务端的session中匹配sessionid,如果匹配成功（cookie  jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录；</p>
<p>例子：<br>客户端：            顾客（客户端）<br>服务端: 存包处   -  商场(服务端)</p>
<p>顾客第一次存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）。<br> 如果是新顾客（没钥匙） ，分配一个钥匙 给该顾客； 钥匙 会和 柜子 一一对应；</p>
<p> 第二/n次 存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）<br> 如果是老顾客（有钥匙），则不需要分配；该顾客手里的钥匙 会 和柜子 自动一一对应。</p>
<p>session:<br>a. session存储在服务端<br>b. session是在 同一个用户（客户）请求时 共享<br>c. 实现机制：第一次客户请求时 产生一个sessionid 并复制给 cookie的jsessionid 然后发给客户端。最终 通过session的sessionid-cookie的jsessionid</p>
<p>session方法：<br>String getId() :获取sessionId<br>boolean isNew() :判断是否是 新用户（第一次访问）<br>void invalidate():使session失效  （退出登录、注销）</p>
<p>void setAttribute()<br>Object getAttribute();</p>
<p>void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间<br>int getMaxInactiveInterval():获取最大有效 非活动时间 </p>
<p>示例：<br>登录</p>
<p>客户端在第一次请求服务端时，如果服务端发现 此请求没有 JSESSIONID,则会创建一个 name=JSESIONID的cookie  并返回给客户端</p>
<p>Cookie：<br>a.不是内对对象，要使用必须new<br>b.但是，服务端会 自动生成一个(服务端自动new一个cookie) name=JSESIONID的cookie  并返回给客户端</p>
<p>cookie和session的区别：<br>        session        cookie<br>保存的位置    服务端        客户端<br>安全性        较安全        较不安全<br>保存的内容    Object        String        </p>
<p>appliation 全局对象<br>String getContextPath()    虚拟路径<br>String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径）</p>
<h2 id="JSP9大内置对象"><a href="#JSP9大内置对象" class="headerlink" title="JSP9大内置对象"></a>JSP9大内置对象</h2><p>pageContext  JSP页面容器<br>request   请求对象<br>session   会话对象<br>appliation 全局对象</p>
<p>response  响应对象</p>
<p>config  配置对象（服务器配置信息）<br>out    输出对象<br>page   当前JSP页面对象（相当于java中的this）<br>exception 异常对象</p>
<h2 id="四种范围对象（小-gt-大）"><a href="#四种范围对象（小-gt-大）" class="headerlink" title="四种范围对象（小-&gt;大）"></a>四种范围对象（小-&gt;大）</h2><p>pageContext  JSP页面容器   （page对象）； 当前页面有效<br>request   请求对象             同一次请求有效<br>session   会话对象            同一次会话有效<br>appliation 全局对象            全局有效（整个项目有效）</p>
<p>以上4个对象共有的方法：<br>Object getAttribute(String name):根据属性名，或者属性值<br>void setAttribute(String name,Object obj) :设置属性值（新增，修改）<br>    setAttribute(“a”,”b”) ;//如果a对象之前不存在，则新建一个a对象 ；<br>                 如果a之前已经存在，则将a的值改为b<br>void removeAttribute(String name)：根据属性名，删除对象</p>
<p>a.<br>pageContext 当前页面有效 (页面跳转后无效)</p>
<p>b.<br>request   同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效）</p>
<p>c.<br>session  同一次会话有效  （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效）</p>
<p>d.<br>application<br>    全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效</p>
<p>-&gt;多个项目共享、重启后仍然有效 ：JNDI</p>
<p>1.以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；<br>2.以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。</p>
<h1 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1.JDBC"></a>1.JDBC</h1><p>:Java DataBase Connectivity  </p>
<p>可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库<br>2.JDBC API 主要功能：<br>三件事，具体是通过以下类/接口实现：<br>DriverManager ： 管理jdbc驱动<br>Connection： 连接（通过DriverManager产生）</p>
<p>Statement（PreparedStatement） ：增删改查  （通过Connection产生 ）<br>CallableStatement  ： 调用数据库中的 存储过程/存储函数  （通过Connection产生 ）</p>
<p>Result ：返回的结果集  （上面的Statement等产生 ）</p>
<p>Connection产生操作数据库的对象：</p>
<p>Connection产生Statement对象：createStatement()<br>Connection产生PreparedStatement对象：prepareStatement()<br>Connection产生CallableStatement对象：prepareCall();</p>
<p>Statement操作数据库：<br>增删改：executeUpdate()<br>查询：executeQuery();</p>
<p>ResultSet：保存结果集 select * from xxx<br>next():光标下移，判断是否有下一条数据；true/false<br>previous():  true/false<br>getXxx(字段名|位置):获取具体的字段值 </p>
<p>PreparedStatement操作数据库：<br>public interface PreparedStatement extends Statement<br>因此<br>增删改：executeUpdate()<br>查询：executeQuery();<br>–此外<br>赋值操作 setXxx();</p>
<p>PreparedStatement与Statement在使用时的区别：<br>1.Statement:<br>sql<br>executeUpdate(sql)</p>
<p>2.<br>PreparedStatement:<br>sql(可能存在占位符?)<br>在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql)<br>executeUpdate()<br>setXxx()替换占位符？</p>
<p>推荐使用PreparedStatement：原因如下：<br>1.编码更加简便（避免了字符串的拼接）<br>String name = “zs” ;<br>int age = 23 ;</p>
<p>stmt:<br>String sql =” insert into student(stuno,stuname) values(‘“+name+”‘,  “+age+” )    “ ;<br>stmt.executeUpdate(sql);</p>
<p>pstmt:<br>String sql =” insert into student(stuno,stuname) values(?,?) “ ;<br>pstmt = connection.prepareStatement(sql);//预编译SQL<br>pstmt.setString(1,name);<br>pstmt.setInt(2,age);</p>
<p>2.提高性能(因为 有预编译操作，预编译只需要执行一次)<br>需要重复增加100条数<br>stmt:<br>String sql =” insert into student(stuno,stuname) values(‘“+name+”‘,  “+age+” )    “ ;<br>for(100)<br>stmt.executeUpdate(sql);</p>
<p>pstmt:<br>String sql =” insert into student(stuno,stuname) values(?,?) “ ;<br>pstmt = connection.prepareStatement(sql);//预编译SQL<br>pstmt.setString(1,name);<br>pstmt.setInt(2,age);<br>for( 100){<br>pstmt.executeUpdate();<br>}</p>
<p>3.安全（可以有效防止sql注入）<br>sql注入： 将客户输入的内容  和 开发人员的SQL语句 混为一体</p>
<p>stmt:存在被sql注入的风险<br>(例如输入  用户名：任意值 ‘ or 1=1 –<br>       密码：任意值)<br>分析：<br>select count(<em>) from login where uname=’任意值 ‘ or 1=1 –’ and upwd =’任意值’  ;<br>select count(</em>) from login where uname=’任意值 ‘ or 1=1 ;<br>select count(*) from login ;</p>
<p>select count(*) from login where uname=’”+name+”‘ and upwd =’”+pwd+”‘ </p>
<p>pstmt:有效防止sql注入</p>
<p>推荐使用pstmt</p>
<p>3.jdbc访问数据库的具体步骤：<br>a.导入驱动，加载具体的驱动类<br>b.与数据库建立连接<br>c.发送sql，执行<br>d.处理结果集 （查询）</p>
<p>4.<br>数据库驱动<br>        驱动jar                    具体驱动类                        连接字符串<br>Oracle        ojdbc-x.jar                oracle.jdbc.OracleDriver                jdbc:oracle:thin:@localhost:1521:ORCL<br>MySQL        mysql-connector-java-x.jar        com.mysql.jdbc.Driver                    jdbc:mysql://localhost:3306/数据库实例名<br>SqlServer    sqljdbc-x.jar                com.microsoft.sqlserver.jdbc.SQLServerDriver        jdbc:microsoft:sqlserver:localhost:1433;databasename=数据库实例名</p>
<p>使用jdbc操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连接字符串、用户名、密码</p>
<h2 id="1-jdbc总结（模板、八股文）："><a href="#1-jdbc总结（模板、八股文）：" class="headerlink" title="1.jdbc总结（模板、八股文）："></a>1.jdbc总结（模板、八股文）：</h2><p>try{<br>a.导入驱动包、加载具体驱动类Class.forName(“具体驱动类”);<br>b.与数据库建立连接connection = DriverManager.getConnection(…);<br>c.通过connection，获取操作数据库的对象（Statement\preparedStatement\callablestatement）<br>stmt = connection.createStatement();<br>d.(查询)处理结果集rs = pstmt.executeQuery()<br>while(rs.next()){ rs.getXxx(..) ;}<br>}catch(ClassNotFoundException e  )<br>{ …}<br>catch(SQLException e)<br>{…<br>}<br>catch(Exception e)<br>{…<br>}<br>finally<br>{<br>    //打开顺序，与关闭顺序相反<br>    if(rs!=null)rs.close()<br>    if(stmt!=null) stmt.close();<br>    if(connection!=null)connection.close();<br>}</p>
<p>–jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException</p>
<p>2.CallableStatement:调用 存储过程、存储函数<br>connection.prepareCall(参数：存储过程或存储函数名)<br>参数格式：<br>存储过程（无返回值return，用out参数替代）：<br>    { call  存储过程名(参数列表) }<br>存储函数（有返回值return）：<br>    { ? = call  存储函数名(参数列表) }</p>
<p>create or replace procedure addTwoNum ( num1  in number,num2  in number,result out number )  – 1 + 2 -&gt;3<br>as<br>begin<br>    result := num1+num2 ;<br>end ;<br>/</p>
<p>强调：<br>如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID<br>通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener</p>
<p>JDBC调用存储过程的步骤：<br>a.产生 调用存储过程的对象（CallableStatement） cstmt =     connection.prepareCall(   “…” ) ;<br>b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);<br>c.通过 registerOutParameter(…)处理输出参数类型<br>d.cstmt.execute()执行<br>e.接受 输出值（返回值）getXxx()</p>
<p>调存储函数：<br>create or replace function addTwoNumfunction ( num1  in number,num2  in number)  – 1 + 2<br>return number<br>as<br>    result number ;<br>begin<br>    result := num1+num2 ;<br>    return result ;<br>end ;<br>/<br>JDBC调用存储函数：与调存储过程的区别：<br>在调用时，注意参数：”{? =  call addTwoNumfunction    (?,?) }”</p>
<p>3.处理CLOB/BLOB类型<br>处理稍大型数据：</p>
<p>a.存储路径    E:\JDK_API_zh_CN.CHM<br>    通过JDBC存储文件路径，然后 根据IO操作处理<br>    例如：JDBC将 E:\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\JDK_API_zh_CN.CHM”存储到数据库中<br>        获取：1.获取该路径“E:\JDK_API_zh_CN.CHM”  2.IO    </p>
<p>b.<br>    CLOB：大文本数据 （小说-&gt;数据）<br>    BLOB：二进制</p>
<p>clob:大文本数据   字符流 Reader Writer<br>存<br>1.先通过pstmt 的? 代替小说内容 （占位符）<br>2.再通过pstmt.setCharacterStream(2, reader,  (int)file.length());  将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型</p>
<p>取：<br>1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据  保存到Reader对象中<br>2. 将Reader通过Writer输出即可。</p>
<p>blob:二进制  字节流 InputStream OutputStream<br>与CLOB步骤基本一致，区别：setBinaryStream(…)  getBinaryStream(…)   </p>
<p>4.JSP访问数据库</p>
<p>JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;%  … %&gt;）</p>
<p>导包操作：java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path<br>      Web项目：jar复制到WEB-INF/lib</p>
<p>核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt;</p>
<p>注意：如果jsp出现错误：The import Xxx cannot be resolved</p>
<p>尝试解决步骤：<br>    a.(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入<br>    b.清空各种缓存：右键项目-&gt;Clean tomcat… clean  （Project -clean或者 进tomcat目录 删除里面work的子目录）<br>    c.删除之前的tomcat，重新解压缩、配置tomcat，重启计算机<br>    d.如果类之前没有包，则将该类加入包中</p>
<p>5.JavaBean<br>刚才我们将 jsp中 登录操作的代码  转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。<br>JavaBean的作用：a.减轻的jsp复杂度  b.提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现）</p>
<p>JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean<br>    a.public 修饰的类  ,public 无参构造<br>    b.所有属性(如果有) 都是private，并且提供set/get   (如果boolean 则get 可以替换成is)</p>
<p>使用层面，Java分为2大类：<br>a.封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑)            逻辑<br>    可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java）</p>
<p>b.封装数据的JavaBean   （实体类，Student.java  Person.java  ）        数据<br>    对应于数据库中的一张表<br>    Login login = new Login(uname,upwd) ;//即用Login对象 封装了2个数据（用户名 和密码）</p>
<p>封装数据的JavaBean 对应于数据库中的一张表   (Login(name,pwd))<br>封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean  </p>
<p>可以发现，JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java)</p>
<p>public  void sleep(String name,String place, int time)<br>{</p>
<p>}</p>
<p>public  void sleep(Person per)<br>{<br>    per.getName()<br>    per.getPlace()<br>    …<br>}</p>
<h1 id="MVC设计模式："><a href="#MVC设计模式：" class="headerlink" title="MVC设计模式："></a>MVC设计模式：</h1><p>M：Model    ，模型  ：一个功能。用JavaBean实现。</p>
<p>V:View，视图： 用于展示、以及与用户交互。使用html  js  css jsp jquery等前端技术实现</p>
<p>C:Controller，控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果<br>            返回给 请求处 。 可以用jsp实现，  但是一般建议使用 Servlet实现控制器。</p>
<p>Jsp-&gt;Java(Servlet)-&gt;JSP</p>
<p>Servlet：<br>Java类必须符合一定的 规范：<br>    a.必须继承  javax.servlet.http.HttpServlet<br>    b.重写其中的 doGet()或doPost()方法</p>
<p> doGet()： 接受 并处 所有get提交方式的请求<br> doPost()：接受 并处 所有post提交方式的请求</p>
<p>Servlet要想使用，必须配置<br>Serlvet2.5：web.xml<br>Servle3.0： @WebServlet</p>
<p>Serlvet2.5：web.xml:</p>
<p>项目的根目录：WebContent 、src</p>
<p><a href="WelcomeServlet">所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet  是去请求项目的根目录。</a></p>
<p>Servlet流程：<br>请求 -&gt;<url-pattern> -&gt; 根据<servlet-mapping>中的<servlet-name> 去匹配  <servlet> 中的<servlet-name>，然后寻找到<servlet-class>，求中将请求交由该<servlet-class>执行。</servlet-class></servlet-class></servlet-name></servlet></servlet-name></servlet-mapping></url-pattern></p>
<p>2个/:<br>jsp:/  localhost:8888<br>web.xml: /   http://localhost:8888/项目名/</p>
<h1 id="1-回顾纯手工方法创建第一个Servlet"><a href="#1-回顾纯手工方法创建第一个Servlet" class="headerlink" title="1.回顾纯手工方法创建第一个Servlet"></a>1.回顾纯手工方法创建第一个Servlet</h1><p>步骤：<br>编写一个类，继承HttpServlet<br>重写doGet()、doPost()方法<br>编写web.xml 中的servlet映射关系</p>
<p>2.借助于Eclipse快速生成Servlet<br>直接新建Servlet即可！（继承、重写、web.xml  可以借助Eclipse自动生成）</p>
<p>Servlet3.0，与Servlet2.5的区别：<br>Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)<br>匹配流程：  请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类</p>
<ol start="3">
<li>项目根目录：WebContent、src（所有的构建路径）<br>例如：<br>WebContent中有一个文件index.jsp<br>src中有一个Servlet.java  </li>
</ol>
<p>如果: index.jsp中请求 <a href="abc">…</a> ，则 寻找范围：既会在src根目录中找  也会在WebContent根目录中找</p>
<p>如果：index.jsp中请求<a href="a/abc"></a>，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc</p>
<p>web.xml中的 /:代表项目根路径<br><a href="http://localhost:8888/Servlet25Project/" target="_blank" rel="noopener">http://localhost:8888/Servlet25Project/</a><br>jsp中的/: 服务器根路径<br><a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a></p>
<p>构建路径、WebContent:根目录</p>
<p>4.Servlet生命周期：5个阶段<br>加载<br>初始化： init()  ，该方法会在 Servlet被加载并实例化的以后 执行<br>服务  ：service() -&gt;doGet()  doPost<br>销毁  ：destroy()，  Servlet被系统回收时执行<br>卸载</p>
<p>init():<br>    a.默认第一次访问 Servlet时会被执行 （只执行这一次）<br>    b.可以修改为 Tomcat启动时自动执行<br>        i.Servlet2.5：  web.xml<br>              <servlet><br>                …<br>                   <load-on-startup>1</load-on-startup><br>                </servlet><br>            其中的“1”代表第一个。<br>        ii.Servlet3.0<br>            @WebServlet( value=”/WelcomeServlet” ,loadOnStartup=1  )</p>
<p>service() -&gt;doGet()  doPost ：调用几次，则执行几次<br>destroy()：关闭tomcat服务时，执行一次。</p>
<p>5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包<br>即Servlet  API可以适用于 任何 通信协议。<br>我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。</p>
<p>6.Servlet继承关系</p>
<p>ServletConfig:接口<br>ServletContext getServletContext():获取Servlet上下文对象   application<br>String  getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数）</p>
<p>a.ServletContext中的常见方法(application)：<br>getContextPath():相对路径<br>getRealPath()：绝对路径<br>setAttribute() 、getAttribute()<br>—&gt;<br>String getInitParameter(String name);在当前Web容器范围内，获取名为name的参数值（初始化参数）</p>
<p>Servlet3.0方式 给当前Servlet设置初始值：<br>@WebServlet( …. , initParams= {@WebInitParam(name=”serveltparaname30”,value=”servletparavalue30”)   }   )<br>注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置）</p>
<p>HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()<br>HttpServletResponse中的方法：同response</p>
<p>Servlet使用层面：</p>
<p>Eclipse中在src创建一个Servlet，然后重写doGet()  doPost()就可以  （doGet() doPost()只需要编写一个）。</p>
<h1 id="三层优化"><a href="#三层优化" class="headerlink" title="三层优化"></a>三层优化</h1><p>1.加入接口<br>    建议面向接口开发：先接口-再实现类<br>    –service、dao加入接口<br>    –接口与实现类的命名规范<br>        接口：interface，    起名   I实体类Service        IStudentService<br>                        IStudentDao<br>        实现类：implements    起名   实体类ServiceImpl        StudentServiceImpl<br>                        StudentDaoImpl<br>        接口：    I实体类层所在包名    IStudentService、IStudentDao<br>            接口所在的包：  xxx.service        xx.dao</p>
<pre><code>    实现类：     实体类层所在包名Impl    StudentServiceImpl、StudentDaoImpl
        实现类所在的包：xxx.service.impl        xx.dao.impl

以后使用接口/实现类时，推荐写法：
接口 x = new 实现类();
IStudentDao studentDao = new StudentDaoImpl();</code></pre><p>2.DBUtil 通用的数据库帮助类，可以简化Dao层的代码量</p>
<p>帮助类 一般建议写在  xxx.util包</p>
<p>A<br>{</p>
<pre><code>a(){
    B.connection
}</code></pre><p>}</p>
<p>B<br>{<br>    static Connection connection =..<br>    b{</p>
<pre><code>}</code></pre><p>}</p>
<p>方法重构：  将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可<br>a()<br>{<br>    ..<br>    c();<br>    ..</p>
<p>}</p>
<p>b()<br>{<br>    ..<br>    c();<br>    ..<br>}</p>
<p>c()<br>{<br>        [..<br>    ..<br>    …<br>    ..]<br>}</p>
<p>Web调试：<br>与java代码的调试 区别：启动方式不同</p>
<p>index.jsp -&gt;index_jsp.java -&gt;index_jsp.class </p>
<p>jsp-&gt;java-&gt;class<br>jsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中</p>
<p>10000</p>
<h1 id="分页：5变量（属性）"><a href="#分页：5变量（属性）" class="headerlink" title="分页：5变量（属性）"></a>分页：5变量（属性）</h1><p>1.数据总数 （select count(*) from xxx ，          查数据库）<br>2.页面大小（页面容量，每页显示的数据条数）    （用户自定义）<br>3.总页数                       （自动计算）<br>    800:10= 80页<br>    总页数= 数据总数 /页面大小</p>
<pre><code>802:10=  800/10 +1 ；
总页数= 数据总数 /页面大小 + 1;

--&gt;通式
总页数= 数据总数 % 页面大小==0 ?数据总数 /页面大小:数据总数 /页面大小 + 1;</code></pre><p>注意：自动计算的时机：当 数据总数 和 页面大小都被赋值以后，自动计算总页数。</p>
<p>4.当前页码                    （用户自定义）</p>
<p>5.实体类对象集合（当前页的数据集合）：依赖于数据库     (查数据库)<br>    假设： 每页显示10条（页面大小=10）</p>
<p>select * from student where id&gt;=起始 and id&lt;=终止;</p>
<p>页数          起止            起止等价写法<br>1        1-10            (页数-1)<em>10+1-页数</em>10<br>2        11-20<br>3        21-30</p>
<p>某一页的数据 起止：</p>
<pre><code>(页数-1)*10+1-页数*10</code></pre><p>select * from student where sno&gt;=(页数-1)<em>10+1 and sno&lt;=页数</em>10;<br>此种分页SQL 严格依赖sno的数据，  一旦sno出现了间隙（裂缝），则无法满足每页10条</p>
<p>-&gt;将此SQL 转换： 1.有rownum  2不能有rownum&gt;xx<br>转换的核心：  将rownum从伪列 转换为 一个 临时表的 普通列。</p>
<p>select <em>from<br>(<br>    select rownum r,t.*from<br>    (select s.</em> from student s order by sno asc) t   </p>
<p>) where r&gt;=(页数-1)<em>10+1 and r&lt;=页数</em>10;            </p>
<p>优化：</p>
<p>select <em>from (<br>    select rownum r,t.*from<br>    (select s.</em> from student s order by sno asc) t<br>    where      rownum&lt;=页数*页面大小            </p>
<p>) where  r&gt;=(页数-1)*页面大小+1     ;                </p>
<p>​        </p>
<p>dao和DBUtil的区别：<br>dao 是处理特定 类的 数据库操作类：<br>DBUtil是通用  数据库操作类</p>
<p>1分页<br>要实现分页，必须知道  某一页的 数据 从哪里开始 到哪里结束</p>
<p>页面大小：每页显示的数据量</p>
<p>假设每页显示10条数据</p>
<p>mysql分页：<br>mysql:从0开始计数<br>0        0        9<br>1        10        19<br>2        20        29<br>n        n<em>10          (n+1)</em>10-1</p>
<p>结论：<br>分页：<br>    第n页的数据：  第(n-1)<em>10+1条  – 第n</em>10条</p>
<p>MYSQL实现分页的sql：<br>limit  开始,多少条<br>第0页<br>select * from student limit 0,10 ;<br>第1页<br>select * from student limit 10,10 ;<br>第2页<br>select * from student limit  20,10 ;<br>第n页<br>select * from student limit n*10,10</p>
<p>mysql的分页语句：</p>
<p>select * from student limit 页数*页面大小,页面大小</p>
<p>b.oracle分页：</p>
<p>sqlserver/oracle:从1开始计数<br>第n页        开始        结束<br>1        1        10<br>2        11        20<br>3        21        30<br>n        (n-1)<em>10+1    n</em>10</p>
<p>select <em>from student  where sno &gt;=(n-1)</em>10+1 and sno &lt;=n*10 ;  –此种写法的前提：必须是Id连续 ，否则 无法满足每页显示10条数据</p>
<p>select rownum,t.<em>from student t where rownum &gt;=(n-1)</em>10+1 and rownum &lt;=n*10  order by sno;<br>–1.如果根据sno排序则rownum会混乱（解决方案：分开使用-&gt;先只排序，再只查询rownum） 2.rownum不能查询&gt;的数据 </p>
<p>select s.* from student s order by sno asc;</p>
<p>select rownum, t.* from<br>(select s.* from student s order by sno asc) t<br>where rownum &gt;=(n-1)<em>10+1 and rownum &lt;=n</em>10 ; ;</p>
<p>//ORACLE\sqlserver都是从1开始计数：  (n-1)<em>10+1    —  n*10<br>oracle的分页查询语句：<br>select *from<br>(<br>    select rownum r, t.</em> from<br>    (select s.* from student s order by sno asc) t         10000<br>)<br>where r&gt;=(n-1)<em>10+1 and &lt;=n</em>10  ;                10</p>
<p>优化：</p>
<p>select <em>from<br>(<br>    select rownum r, t.</em> from<br>    (select s.* from student s order by sno asc) t<br>    where rownum&lt;=n<em>10<br>)<br>where r&gt;=(n-1)</em>10+1  ;    </p>
<p>select <em>from<br>(<br>    select rownum r, t.</em> from<br>    (select s.* from student s order by sno asc) t<br>    where  rownum&lt;=页数<em>页面大小<br>)<br>where r&gt;=(页数-1)</em>页面大小+1  ;    </p>
<p>SQLServer分页：  3种分页sql<br>row_number()    over(字段) ;</p>
<p>sqlserver2003:top  –此种分页SQL存在弊端（如果id值不连续，则不能保证每页数据量相等）<br>select top 页面大小 * from student where id not in<br>( select top (页数-1)*页面大小 id from student  order by sno asc )</p>
<p>sqlserver2005之后支持：<br>select <em>from<br>(<br>    select row_number()  over (sno order by sno asc) as r,</em> from student</p>
<pre><code>where r&lt;=n*10 </code></pre><p>)<br>where r&gt;=(n-1)*10+1 and  ;    </p>
<p>SQLServer此种分页sql与oralce分页sql的区别： 1.rownum  ，row_number()    2.oracle需要排序（为了排序，单独写了一个子查询），但是在sqlserver 中可以省略该排序的子查询  因为sqlserver中可以通过over直接排序</p>
<p>sqlserver2012之后支持：<br>offset fetch next only</p>
<p>select * from student  oreder by sno<br>offset (页数-1)*页面大小+1  rows fetch next 页面大小  rows only ;</p>
<p>(n-1)<em>10+1    —  n</em>10 </p>
<p>mysql从0开始计数，Oracle/sqlserver 从1开始计数</p>
<p>1<br>2<br>3<br>4<br>6<br>8<br>9<br>10</p>
<p>11<br>12<br>…<br>20</p>
<p>21<br>22<br>..<br>31</p>
<p>分页实现：<br>5个变量（属性）<br>1.数据总数    100    103                    （查数据库,select count(*)..）<br>2.页面大小（每页显示的数据条数）20                  (用户自定义)<br>3.总页数                              （程序自动计算）<br>    总页数 = 100/20  =数据总数/页面大小<br>    总页数 = 103/20 = 数据总数/页面大小+1<br>    —&gt;<br>    总页数 = 数据总数%页面大小==0? 数据总数/页面大小:数据总数/页面大小+1 ;</p>
<p>4.当前页（页码）                              （用户自定义）<br>5.当前页的对象集合（实体类集合）：每页所显示的所有数据 （10个人信息）<br>List<student>                               (查数据库,分页sql)    </student></p>
<p>2表单重复提交</p>
<h1 id="1-上传文件"><a href="#1-上传文件" class="headerlink" title="1.上传文件"></a>1.上传文件</h1><p>a.引入2个jar<br>   apache: commons-fileupload.jar组件<br>    commons-fileupload.jar依赖 commons-io.jar</p>
<p>b.<br>代码：<br>前台jsp：<br>    <input type="file" name="spicture"><br>    表单提交方式必须为post<br>    在表单中必须增加一个属性 entype=”multipart/form-data”</p>
<p>后台servlet：</p>
<p>注意的问题：<br>    上传的目录  upload ：<br>    1.如果修改代码，则在tomcat重新启动时 会被删除<br>        原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录）</p>
<pre><code>2.如果不修改代码，则不会删除
    原因： 没有修改代码，class仍然是之前的class</code></pre><p>因此，为了防止 上传目录丢失： a.虚拟路径    b.直接更换上传目录 到非tomcat目录</p>
<p>限制上传：<br>    类型、<br>    大小<br>    注意 对文件的限制条件 写再parseRequest之前</p>
<p>2.下载：不需要依赖任何jar<br>    a.请求（地址a  form），请求Servlet<br>    b.Servlet通过文件的地址  将文件转为输入流 读到Servlet中<br>    c.通过输出流 将 刚才已经转为输入流的文件  输出给用户<br>注意：下载文件 需要设置2个 响应头：<br>response.addHeader(“content-Type”,”application/octet-stream” );//MIME类型:二进制文件（任意文件）<br>response.addHeader(“content-Disposition”,”attachement;filename=”+fileName );//fileName包含了文件后缀：abc.txt<br>        1.下载时 ，文件名乱码问题：<br>edge：</p>
<p>URLEncoder.encode(fileName,”UTF-8”) </p>
<p>firefox：<br>给文件名 加：<br>前缀   =?UTF-8?B?</p>
<p>String构造方法<br>Base64.encode<br>后缀   ?=<br>示例：<br>    response.addHeader(“content-Disposition”,”attachment;filename==?UTF-8?B?”+   new String(  Base64.encodeBase64(fileName.getBytes(“UTF-8”))  ) +”?=” );//fileName包含了文件后缀：abc.txt</p>
<p>2</p>
<h1 id="EL-："><a href="#EL-：" class="headerlink" title="EL ："></a>EL ：</h1><p>为了消除jsp中的Java代码</p>
<p>语法：<br>${EL表达式}<br>a.EL不需要导包<br>b.在el中调用属性，其实是调用的getXxx()方法</p>
<p>${范围.对象.属性.属性的属性 }</p>
<p>操作符：操作：属性，不是对象<br>. : 使用方便<br>[] : 如果是常量属性，需要使用双引号/单引号 引起来;比点操作符更加强大</p>
<p>[]强大之处：<br>a.可以容纳一些 特殊符号 （.  ?   -）<br>b.[]可以容纳 变量属性 （可以动态赋值）<br>String x = “a”;<br>${requestScope.a}等价于${requestScope[“a”]}等价于${${requestScope[x]}</p>
<p>c.可以处理数组<br>${requestScope.arr[0] }</p>
<p>普通对象、map中的变量</p>
<p>通过EL获取JSP  九大内置对象</p>
<p>${pageContext }<br>${pageContext.request }<br>${pageContext.sessoin }</p>
<h1 id="JSTL：比EL更加强大"><a href="#JSTL：比EL更加强大" class="headerlink" title="JSTL：比EL更加强大"></a>JSTL：比EL更加强大</h1><p>需要引入2个jar ：jstl.jar   standard.jar<br>引入tablib  :<br>&lt;%@ taglib uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c” %&gt;<br>其中prefix=”c” :前缀</p>
<p>核心标签库：  通用标签库、条件标签库  迭代标签库</p>
<p>a.通用标签库<br>&lt;c:set&gt;赋值<br>i:<br>在某个作用域之中（4个范围对象），给某个变量赋值<br>    &lt;%–<br>        request.setAttribute(“name”, “zhangsan”) ;<br>    –%&gt;<br>        &lt;c:set var=”name”    value=”zhangsan”   scope=”request”/&gt;<br>        ${requestScope.name }</p>
<p>&lt;c:set var=”变量名”    value=”变量值”   scope=”4个范围对象的作用域”/&gt;</p>
<p>ii:<br>给普通对象赋值<br>在某个作用域之中（4个范围对象），给某个对象的属性复制 （此种写法，不能指定scope属性）</p>
<pre><code>&lt;c:set target=&quot;${requestScope.student}&quot; property=&quot;sname&quot;  value=&quot;zxs&quot; /&gt;</code></pre><p>给map对象赋值<br>        &lt;c:set target=”${requestScope.countries}” property=”cn”  value=”中国” /&gt;</p>
<p>&lt;c:set target=”对象” property=”对象的属性”  value=”赋值” /&gt;</p>
<p>注意 &lt;c:set&gt;可以给不存在的变量赋值 （但不能给不存在的对象赋值）</p>
<p>&lt;c:out&gt;  ：显示<br>true:&lt;c:out value=’<a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a>‘ default=”当value为空的，显示的默认值” escapeXml=”true” /&gt;<br>false：    &lt;c:out value=’<a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a>‘ escapeXml=”false” /&gt;</p>
<p>&lt;c:remove &gt;：删除属性<br>&lt;c:remove var=”a” scope=”request”/&gt;</p>
<p>选择：<br>if(boolean)<br>单重选择<br>&lt;c:if test=”” &gt;</p>
<p>if else if… esle if… else  /switch</p>
<p>&lt;c:choose&gt;<br>    &lt;c:when test=”…”&gt;   <br>    &lt;c:when test=”…”&gt;   <br>    &lt;c:when test=”…”&gt;   <br>    &lt;c:otherwise&gt;   <br></p>
<p>在使用 test=”” 一定要注意后面是否有空格<br>例如：test=”${10&gt;2 }”   true<br>     test=”${10&gt;2 } “  非true</p>
<p>循环（迭代标签库）<br>for(int i=0;i&lt;5;i++)<br>    &lt;c:forEach  var=”name” items=”${requestScope.names }” &gt;<br>        -${name }-<br>        </p>
<p><strong>可以在foreach便签中items属性作用域（requestScope）中保存的对象</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--for(String str:names)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span>  <span class="attr">var</span>=<span class="string">"student"</span> <span class="attr">items</span>=<span class="string">"$&#123;requestScope.students &#125;"</span> &gt;</span></span><br><span class="line">	$&#123;student.sname &#125;-$&#123;student.sno &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h1><p>实现一个Filter接口<br>init()、destroy() 原理、执行时机 同Servlet<br>配置过滤器，类似servlet<br>通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行</p>
<p>filter映射</p>
<p>只拦截 访问MyServlet的请求<br>    <url-pattern>/MyServlet</url-pattern><br>拦截一切请求（每一次访问 都会被拦截）<br><url-pattern>/*</url-pattern></p>
<p>通配符</p>
<p>dispatcher请求方式：<br>REQUEST：拦截HTTP请求 get post<br>FORWARD：只拦截 通过 请求转发方式的请求</p>
<p>INCLUDE:只拦截拦截通过 request.getRequestDispatcher(“”).include()  、通过&lt;jsp:include page=”…” /&gt;此种方式发出的请求<br>ERROR：只拦截<error-page>发出的请求</error-page></p>
<p>过滤器中doFilter方法参数：ServletRequest<br>在Servlet中的方法参数：HttpServletRequest</p>
<p>过滤器链<br>可以配置多个过滤器，过滤器的先后顺序 是由 <filter-mapping>的位置 决定</filter-mapping></p>
</engine>
    </div>

    
    
    
    
    <div>
     
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

     
    </div>
    
        
      
        <div id="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>nicolas lee</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://codeofli.github.io/2019/11/java-note/javaWeb/javaWeb/" title="javaWeb">https://codeofli.github.io/2019/11/java-note/javaWeb/javaWeb/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/java/" rel="tag"># java</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/java-note/javaSE/javaSE/" rel="next" title="javaSE">
                  <i class="fa fa-chevron-left"></i> javaSE
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/11/java-note/mybatis/mybatis/" rel="prev" title="mybatis">
                  mybatis <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#web路径"><span class="nav-number">1.</span> <span class="nav-text">web路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1JSP-动态网页"><span class="nav-number">2.</span> <span class="nav-text">1JSP:动态网页</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-tomcat解压后目录："><span class="nav-number">2.1.</span> <span class="nav-text">3.tomcat解压后目录：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jsp-和Servlet-可以相互转换"><span class="nav-number">2.2.</span> <span class="nav-text">Jsp 和Servlet 可以相互转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-使用Eclipse开发Web项目"><span class="nav-number">3.</span> <span class="nav-text">1.使用Eclipse开发Web项目</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSP的页面元素：-HTML-java代码（脚本Scriptlet）、指令、注释"><span class="nav-number">4.</span> <span class="nav-text">JSP的页面元素： HTML  java代码（脚本Scriptlet）、指令、注释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-JSP九大内置对象"><span class="nav-number">4.1.</span> <span class="nav-text">7.JSP九大内置对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSP9大内置对象"><span class="nav-number">4.2.</span> <span class="nav-text">JSP9大内置对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四种范围对象（小-gt-大）"><span class="nav-number">4.3.</span> <span class="nav-text">四种范围对象（小-&gt;大）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-JDBC"><span class="nav-number">5.</span> <span class="nav-text">1.JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-jdbc总结（模板、八股文）："><span class="nav-number">5.1.</span> <span class="nav-text">1.jdbc总结（模板、八股文）：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVC设计模式："><span class="nav-number">6.</span> <span class="nav-text">MVC设计模式：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-回顾纯手工方法创建第一个Servlet"><span class="nav-number">7.</span> <span class="nav-text">1.回顾纯手工方法创建第一个Servlet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三层优化"><span class="nav-number">8.</span> <span class="nav-text">三层优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分页：5变量（属性）"><span class="nav-number">9.</span> <span class="nav-text">分页：5变量（属性）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-上传文件"><span class="nav-number">10.</span> <span class="nav-text">1.上传文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EL-："><span class="nav-number">11.</span> <span class="nav-text">EL ：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSTL：比EL更加强大"><span class="nav-number">12.</span> <span class="nav-text">JSTL：比EL更加强大</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#过滤器："><span class="nav-number">13.</span> <span class="nav-text">过滤器：</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/assets/img/avatar.jpg"
      alt="nicolas lee">
  <p class="site-author-name" itemprop="name">nicolas lee</p>
  <div class="site-description" itemprop="description">Yesterday you said tomorow.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/codeOflI" title="GitHub &rarr; https://github.com/codeOflI" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://blog.csdn.net/qq_42835910" title="CSDN &rarr; https://blog.csdn.net/qq_42835910" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nicolas lee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数"></span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>