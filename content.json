{"meta":{"title":"nicolas","subtitle":"Yesterday you said tomorow.","description":"Yesterday you said tomorow.","author":"nicolas lee","url":"https://codeofli.github.io","root":"/"},"pages":[{"title":"about","date":"2019-10-09T02:11:44.000Z","updated":"2019-10-09T02:11:44.532Z","comments":true,"path":"about/index-1.html","permalink":"https://codeofli.github.io/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2019-10-07T02:31:20.000Z","updated":"2019-10-07T02:31:20.450Z","comments":true,"path":"about/index.html","permalink":"https://codeofli.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-09T02:10:12.000Z","updated":"2019-10-09T02:44:45.050Z","comments":true,"path":"categories/index.html","permalink":"https://codeofli.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-09T02:17:04.000Z","updated":"2019-10-09T02:56:53.797Z","comments":true,"path":"tags/index.html","permalink":"https://codeofli.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"maven","slug":"java-note/maven/maven","date":"2019-11-13T07:09:35.000Z","updated":"2019-11-13T12:53:57.289Z","comments":true,"path":"2019/11/java-note/maven/maven/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/maven/maven/","excerpt":"[TOC]maven配置文件D:\\apache-maven-3.6.1\\conf\\settings.xml设置镜像阿里mirrors12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt;","text":"[TOC]maven配置文件D:\\apache-maven-3.6.1\\conf\\settings.xml设置镜像阿里mirrors12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置maven的jdk 1234567891011&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activaByDefault&gt;true&lt;/activaByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; maven使用spring单元测试test写在src/test/mapper/目录下 推荐Spring的项目就可以使用spring的单元测试，可以依赖注入我们需要的组件 1.导入springTest模块(meven导包) 2.@ContextConfiguration指定spring配置文件内容,@RunWith(SpringJUnit4ClassRunner.class) 3.直接autoWrited要使用的组件即可 1234567** * 测试dao工作层 * @author test */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; maven的pom.xml结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!--maven的pom.xml结构--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--组织名称 一般是公司名称的倒写，像包名--&gt; &lt;groupId&gt;com.sz&lt;/groupId&gt; &lt;!--项目，模块名称--&gt; &lt;artifactId&gt;helloworld1&lt;/artifactId&gt; &lt;!--版本号--&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目名--&gt; &lt;name&gt;helloworld1&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;!--属性的定义--&gt; &lt;!--项目构建使用字符编码--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--编译源代码的版本--&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;!--目标代码的版本--&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;!--依赖集 你所需要的jar包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--要什么jar全部到maven中央仓库去找仓库中进行搜索即可--&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;!--这是一个依赖--&gt; &lt;dependency&gt; &lt;!--通过坐标来描述--&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-project-info-reports-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; maven目录结构测试类一般是放在src/test/java,而不是放在src/main/java下.maven在编译的时候,src/main/java下是不引用test的jar,而编译src/test/java下的测试这会引用test的jar maven中classpath路径在Maven工程中，classpath的路径指java resources路径下的目录，即 src/main/java、 src/main/resource、src/test/java 、src/test/resource 四个目录所以在配置路径时需要注意文件名是否重名，导致加载文件失败","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://codeofli.github.io/tags/maven/"}]},{"title":"docker","slug":"docker/docker","date":"2019-11-12T07:39:56.000Z","updated":"2019-11-12T15:25:37.111Z","comments":true,"path":"2019/11/docker/docker/","link":"","permalink":"https://codeofli.github.io/2019/11/docker/docker/","excerpt":"[TOC]1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；","text":"[TOC]1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术；Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；运行中的这个镜像称为容器，容器启动是非常快速的。2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(docker)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤：(安装不成功可以到菜鸟教程安装) 1、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker 1sudo apt install docker.io 3、输入y确认安装4、启动docker 123[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.6 5、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 操作 命令 说明 运行 docker run –name container-name -d image-nameeg:docker run –name myredis –d redis– –name：自定义容器名-d：后台运行image-name:指定镜像模板 列表 docker ps（查看运行中的容器）； 加上-a；可以查看所有容器 启动 docker stop container-name/container-id 启动容器 停止 docker stop container-name/container-id 停止当前你运行的容器 删除 docker rm container-id 删除指定容器 端口映射 -p 6379:6379eg:docker run -d -p 6379:6379 –name myredisdocker.io/redis -p:主机端口(映射到)容器内部的端口 容器日志 docker logs container-name/container-id 更多命令 https://docs.docker.com/engine/reference/commandline/docker/ 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例123docker pull mysql#mysql 版本最好在5.7左右，不然navicat连不上[root@MiWiFi-R3A-srv ~]# docker pull mysql:5.7.27 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 123456[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlnicolas@iZuf6i77uwsb2oiszspgvkZ:/home/admin$ sudo docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 1234567[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlnicolas@iZuf6i77uwsb2oiszspgvkZ:/home/admin$ sudo docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 1234567891011docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数#创建mysql容器+character-setdocker run -p 3306:3306 --name mysql03 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_cidocker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=db123456 --name mysql -e TZ=Asia/Shanghai mysql:5.7 1234567891011-e TZ=Asia/Shanghai 时区修改为中国时区-p 3306：3306：将容器的3306端口映射到主机的3306端口-v $ PWD / conf / my.cnf：/etc/mysql/my.cnf：将主机当前目录下的conf / my.cnf挂载到容器的/etc/mysql/my.cnf-v $ PWD / logs：/ logs：将主机当前目录下的日志目录挂载到容器的/ logs-v $ PWD / data：/ mysql_data：将主机当前目录下的数据目录挂载到容器的/ mysql_data-e MYSQL_ROOT_PASSWORD = 123456：初始化 root用户的密码 修改时区和字符集 12docker run -p 3306:3306 --name ch-timezone-mysql -e MYSQL_ROOT_PASSWORD=123456 -e TZ=Asia/Shanghai -d mysql:5.7.27 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 安装mysql之后进行操作3.进入容器bash并进入mysql命令行： 1ubuntu@VM-0-5-ubuntu:/etc/apt$ sudo docker exec -it mysql02 bash Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用-v参数指定。 譬如我要启动一个centos容器，宿主机的/test目录挂载到容器的/soft目录，可通过以下方式指定： 12docker run -it -v /test:/soft centos /bin/bashdocker run -it -v /hmoe/ubuntu:/tmp mysql02 /bin/bash 安装redis1runoob@runoob:~$ mkdir -p ~/redis ~/redis/data 1sudo docker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 连接、查看容器使用redis镜像执行redis-cli命令连接到刚启动的容器,主机IP为172.17.0.1 123456789101112runoob@runoob:~/redis$ docker exec -it 43f7a65ec7f8 redis-cli172.17.0.1:6379&gt; info# Serverredis_version:3.2.0redis_git_sha1:00000000redis_git_dirty:0redis_build_id:f449541256e7d446redis_mode:standaloneos:Linux 4.2.0-16-generic x86_64arch_bits:64multiplexing_api:epoll... 1docker exec -it 239fadb88042 redis-cli 官方文档配置文件映射Alternatively, you can specify something along the same lines with docker run options. 1$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf Where /myredis/conf/ is a local directory containing your redis.conffile. Using this method means that there is no need for you to have a Dockerfile for your redis container. 其他1docker run -d --privileged=true -p 6379:6379 --restart always -v /root/docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /root/docker/redis/data:/data --name myredis redis redis-server /etc/redis/redis.conf --appendonly yes 12345678-d -&gt; 以守护进程的方式启动容器-p 6379:6379 -&gt; 绑定宿主机端口--name myredis -&gt; 指定容器名称--restart always -&gt; 开机启动--privileged=true -&gt; 提升容器内权限-v /root/docker/redis/conf:/etc/redis/redis.conf -&gt; 映射配置文件-v /root/docker/redis/data:/data -&gt; 映射数据目录--appendonly yes -&gt; 开启数据持久化","categories":[{"name":"learn-note","slug":"learn-note","permalink":"https://codeofli.github.io/categories/learn-note/"}],"tags":[{"name":"learn-note","slug":"learn-note","permalink":"https://codeofli.github.io/tags/learn-note/"},{"name":"docker","slug":"docker","permalink":"https://codeofli.github.io/tags/docker/"}]},{"title":"mybatis","slug":"java-note/mybatis/mybatis","date":"2019-11-12T02:40:06.000Z","updated":"2019-11-12T02:42:31.200Z","comments":true,"path":"2019/11/java-note/mybatis/mybatis/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/mybatis/mybatis/","excerpt":"[TOC]入门mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名}输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student”","text":"[TOC]入门mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名}输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student” 注意事项：如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit(); conf.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 通过environment的default值和environment的id值指定Mybatis数据库的运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;!-- development environment --&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事务提交方式： JDBC：使用JDBC方式提交事务（commit rollback close） MANAGED:将事务交给其他组件去托管（spring，jobss）默认自动关闭 设置不关闭： &lt;transactionManager type=\"MANAGED\" /&gt; property name=\"closeConnection\" value=\"false\" /&gt; --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据源类型 UNPOOLED:传统jdbc方式(每次访问数据，均需要打开和关闭等数据库操作，但是打开和关闭都是很浪费资源和性能的） POLLED：使用数据库连接池 JNDI：从tomcat中获取一个内置数据库连接池（数据库连接池-数据源） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置数据库信息 --&gt; &lt;property name=\"driver\" value=\"oracle.jdbc.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:MLDN\" /&gt; &lt;property name=\"username\" value=\"scott\" /&gt; &lt;property name=\"password\" value=\"tigger\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- test environment--&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置数据库信息 --&gt; &lt;property name=\"driver\" value=\"oracle.jdbc.OracleDriver\" /&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@111:11:11:1521:MLDN\" /&gt; &lt;property name=\"username\" value=\"scott\" /&gt; &lt;property name=\"password\" value=\"tigger\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!-- 加载映射文件 --&gt; &lt;mapper resource=\"pers/nicolas/entity/studentMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace：该mapper.xml映射文件的唯一标识 --&gt;&lt;mapper namespace=\"pers.nicolas.entity.studnetMapper\"&gt; &lt;!-- 后续通过namespace.Id 定位该SQL语句--&gt; &lt;!-- parameterType：输入参数的类型 resultType：查询结果的返回类型 --&gt; &lt;select id=\"queryStudentBysno\" parameterType=\"int\" resultType=\"pers.nicolas.entity.Student\"&gt; select * from student where stuno = #&#123;stuno&#125;&lt;!-- 不能有分号！！！无效字符 --&gt; &lt;/select&gt; &lt;insert id=\"addStudent\" parameterType=\"pers.nicolas.entity.Student\" &gt; insert into student(stuno,stuname,stuage,graname) values(#&#123;stuNo&#125;,#&#123;stuName&#125;,#&#123;stuAge&#125;,#&#123;graName&#125;) &lt;/insert&gt; &lt;delete id=\"deleteStudentBySno\" parameterType=\"int\"&gt; delete from student where stuno=#&#123;stuno&#125; &lt;/delete&gt; &lt;update id=\"updateStudentBySno\" parameterType=\"pers.nicolas.entity.Student\"&gt; update student set stuno=#&#123;stuNo&#125;, stuname = #&#123;stuName&#125;, stuage=#&#123;stuAge&#125;,graname=#&#123;graName&#125; &lt;/update&gt; &lt;select id=\"queryAllStudents\" resultType=\"pers.nicolas.entity.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; mybatis约定：输入参数parameterType 和 输出参数resultType ，在形式上都只能有一个 如果输入参数 ：是简单类型（8个基本类型+String） 是可以使用任何占位符,#{xxxx} 如果是对象类型，则必须是对象的属性 #{属性名} 输出参数： 如果返回值类型是一个 对象（如Student），则无论返回一个、还是多个， 再resultType都写成org.lanqiao.entity.Student 即 resultType=”org.lanqiao.entity.Student” 注意事项：如果使用的 事务方式为 jdbc,则需要 手工commit提交，即session.commit(); mapper动态代理方式的crud又称（MyBatis接口开发） 原则：约定优于配置 硬编码方式 abc.java Configuration conf = new Configuration(); con.setName(“myProject”) ; 配置方式： abc.xml myProject 约定：默认值就是myProject 具体实现的步骤：1.基础环境：mybatis.jar/ojdbc.jar、conf.xml、mapper.xml2.（不同之处） 约定的目标： 省略掉statement,即根据约定 直接可以定位出SQL语句 a.接口，接口中的方法必须遵循以下约定： 1.方法名和mapper.xml文件中标签的id值相同 2 .方法的 输入参数 和mapper.xml文件中标签的 parameterType类型一致 (如果mapper.xml的标签中没有 parameterType，则说明方法没有输入参数) 3.方法的返回值 和mapper.xml文件中标签的 resultType类型一致 （无论查询结果是一个 还是多个（student、List），在mapper.xml标签中的resultType中只写 一个（Student）；如果没有resultType，则说明方法的返回值为void） 除了以上约定，要实现 接口中的方法 和 Mapper.xml中SQL标签一一对应，还需要以下1点： namespace的值 ，就是 接口的全类名（ 接口 - mapper.xml 一一对应） 匹配的过程：（约定的过程）1.根据 接口名 找到 mapper.xml文件（根据的是namespace=接口全类名）2.根据 接口的方法名 找到 mapper.xml文件中的SQL标签 （方法名=SQL标签Id值） 以上2点可以保证： 当我们调用接口中的方法时，程序能自动定位到 某一个Mapper.xml文件中的sqL标签 习惯：SQL映射文件（mapper.xml） 和 接口放在同一个包中 （注意修改conf.xml中加载mapper.xml文件的路径） 以上，可以通过接口的方法-&gt;SQL语句 执行： StudentMapper studentMapper = session.getMapper(StudentMapper.class) ; studentMapper.方法(); 通过session对象获取接口（session.getMapper(接口.class);），再调用该接口中的方法，程序会自动执行该方法对应的SQL。 配置别名https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases 1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Problem\" type=\"com.yoj.web.bean.Problem\"/&gt; &lt;package name=\"com.yoj.web.bean\"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值。见下面的例子： 1234@Alias(\"author\")public class Author &#123; ...&#125; 类型处理器（类型转换器）1.MyBatis自带一些常见的类型处理器 int - number 2.自定义MyBatis类型处理器 1java -数据库(jdbc类型) 示例：实体类Student : boolean stuSex true:男 false：女 表student： number stuSex 1:男 0：女自定义类型转换器（boolean -number）步骤：a.创建转换器：需要实现TypeHandler接口 通过阅读源码发现，此接口有一个实现类 BaseTypeHandler ，因此 要实现转换器有2种选择： i.实现接口TypeHandler接口 ii.继承BaseTypeHandlerb.配置conf.xml 需要注意的问题： INTEGER(需要大写) 1insert into student(stuno,stuname,stuage,graname,stusex) values(#&#123;stuNo&#125;,#&#123;stuName&#125;,#&#123;stuAge&#125;,#&#123;graName&#125; ,#&#123;stuSex ,javaType=boolean ,jdbcType=INTEGER &#125; ) 注意#{stuNo} 中存放的是 属性值，需要严格区分大小写。 resultMap可以实现2个功能：1.类型转换2.属性-字段的映射关系 select * from student where stuno = #{stuno} 12345678&lt;resultMap type=\"student\" id=\"studentMapping\"&gt; &lt;!-- 分为主键id 和非主键 result--&gt; &lt;id property=\"id\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuage\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" javaType=\"boolean\" jdbcType=\"INTEGER\"/&gt; &lt;/resultMap&gt; mybatis调用存储过程123456789&lt;select id=\"queryCountByGradeWithProcedure\" statementType=\"CALLABLE\" parameterType=\"HashMap\" &gt; &#123; CALL queryCountByGradeWithProcedure( #&#123;gName,jdbcType=VARCHAR,mode=IN&#125;, #&#123;scount,jdbcType=INTEGER,mode=OUT&#125; ) &#125; &lt;/select&gt; 其中 通过statementType=”CALLABLE”设置SQL的执行方式是存储过程。 存储过程的输入参数gName需要通过HashMap来指定在使用时，通过hashmap的put方法传入输入参数的值；通过hashmap的Get方法 获取输出参数的值。要注意Jar问题：ojdbc6.jar不能在 调存储过程时 打回车、tab，但是ojdbc7.jar可以。 如果报错： No enum constant org.apache.ibatis.type.JdbcType.xx，则说明mybatis不支持xx类型，需要查表。 存储过程 无论输入参数是什么值，语法上都需要 用map来传递该值； 只要 是 ，则增删改都需要手工commit ; mapper.xml-&gt;mapper接口-&gt;测试方法 输入和输出参数输入参数parameterType1.类型为 简单类型（8个基本类型+String）#{}、${}的区别a.#{任意值}${value} ，其中的标识符只能是value b.#{}自动给String类型加上’’ （自动类型转换） ${} 原样输出，但是适合于 动态排序（动态字段） select stuno,stuname,stuage from student where stuname = #{value} select stuno,stuname,stuage from student where stuname = ‘${value}’ 动态排序：select stuno,stuname,stuage from student order by ${value} asc c.#{}可以防止SQL注入 ${}不防止 ${}、#{}相同之处：a.都可以 获取对象的值 （嵌套类型对象） i.获取对象值：模糊查询，方式一： 1select stuno,stuname,stuage from student where stuage= #&#123;stuAge&#125; or stuname like #&#123;stuName&#125; 1234Student student = new Student(); student.setStuAge(24); student.setStuName(\"%w%\"); List&lt;Student&gt; students = studentMapper.queryStudentBystuageOrstuName(student) ;//接口的方法-&gt;SQL 模糊查询，方式二： student.setStuName(“w”); select stuno,stuname,stuage from student where stuage= #{stuAge} or stuname like ‘%${stuName}%’ ii.嵌套类型对象 2.对象类型#{属性名}${属性名} 输入对象为HashMap：where stuage= #{stuAge} 用map中key的值 匹配 占位符#{stuAge}，如果匹配成功 就用map的value替换占位符 输出参数resultType输出参数resultType1.简单类型（8个基本+String）2.输出参数为实体对象类型3.输出参数为实体对象类型的集合 ：虽然输出类型为集合，但是resultType依然写 集合的元素类型（resyltType=”Student”）4.输出参数类型为HashMap –HashMap本身是一个集合，可以存放多个元素， 但是根据提示发现 返回值为HashMap时 ，查询的结果只能是1个学生（no,name）；–&gt;结论：一个HashMap 对应一个学生的多个元素（多个属性） 【一个map，一个学生】 二维数组{ {1,zs,23,xa}, -一个HashMap对象 {2,ls,24,bj}, {3,ww,25,tj}} resultTyperesultMap:实体类的属性、数据表的字段： 类型、名字不同时（stuno,id）注意：当属性名 和字段名 不一致时，除了使用resultMap以外，还可以使用resultType+HashMap: a.resultMap b.resultType+HashMapselect 表的字段名 “类的属性名” from… 来制定字段名 和属性名的对应关系 select id “stuNo”,name “stuName” from student where id = #{id} 注意: 如果如果10个字段，但发现 某一个字段结果始终为默认值（0，0.0，null），则可能是 表的字段 和 类的属性名字写错。 //查询全部String statement = “select stuno,stuname from student”; //根据年龄查询学生 String statement = “select stuno,stuname from student where stuage = #{stuage}”; //根据姓名和年龄查询学生 String statement = “select stuno,stuname from student where stuage = #{stuage} and stuage = #{stuage} “; select stuno,stuname from student where stuname = #{stuName}and stuage = #{stuAge} 查询使用了类型转换器 1.如果类中属性和表中字段类型能够合理识别（String-varchar2），则可以使用resultType，(boolean-number)否则使用resultMap； 2.如果类中属性名和表中字段名能够合理识别（stuNo-stuno），则可以使用resultType，（stuno-id）否则使用resultMap； 1234&lt;!-- 别名作为HashMap的Key --&gt; &lt;select id=\"queryStudentOutByHashMap\" resultMap=\"HashMap\"&gt; select stuno \"no\", stuname \"name\" from student &lt;/select&gt; 1234567891011&lt;!--resultMap --&gt; &lt;select id=\"queryStudentById\" parameterType=\"int\" resultMap=\"queryStudentByIdMap\"&gt; select id,name from student where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap type=\"Student\" id=\"queryStudentByIdMap\"&gt; &lt;!-- 将类中属性和表中字段对应起来 --&gt; &lt;!-- 分为主键id和非主键 result --&gt; &lt;id property=\"stuNo\" column=\"id\"/&gt; &lt;result property=\"stuName\" column=\"name\"/&gt; &lt;/resultMap&gt; 12345&lt;!--resultType HashMap方式起别名--&gt; &lt;select id=\"queryStudentByIdWithHashMap\" parameterType=\"int\" resultType=\"Student\"&gt; select id \"stuNo\",name \"stuName\" from student where id = #&#123;id&#125; &lt;/select&gt; 动态sql官网地址 wherewhere 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除。 如果 where 元素没有按正常套路出牌，我们可以通过自定义 trim 元素来定制 where 元素的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ...&lt;/trim&gt; 123456789101112&lt;!-- where标签 --&gt;&lt;select id=\"queryStudentBySqlTag\" parameterType=\"student\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"stuName != null and stuName !='' \"&gt; and stuName = #&#123;stuName&#125; &lt;/if&gt; &lt;if test=\"stuAge != null and stuAge !=0 \"&gt; and stuAge = #&#123;stuAge&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 简单类型的数组:无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用array代替该数组 集合：无论编写代码时，传递的是什么参数名(stuNos)，在mapper.xml中 必须用list代替该数组 对象数组：Student[] students = {student0,student1,student2} 每个studentx包含一个学号属性注意的几点： parameterType=”Object[]” #{student.stuNo} SQL片段： java：方法 数据库：存储过程、存储函数 Mybatis :SQL片段 a.提取相似代码b.引用 if标签12345678910&lt;!-- 添加虚拟前缀 --&gt;&lt;select id=\"queryStudentBySqlTag\" parameterType=\"student\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student where 1=1 &lt;if test=\"stuName != null and stuName !='' \"&gt; and stuName = #&#123;stuName&#125; &lt;/if&gt; &lt;if test=\"stuAge != null and stuAge !=0 \"&gt; and stuAge = #&#123;stuAge&#125; &lt;/if&gt; &lt;/select&gt; foreach Tag12345678910111213&lt;!-- foreach迭代 使用对象属性--&gt; &lt;select id=\"queryStudentInGrade\" parameterType=\"grade\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"stuNos != null and stuNos.size &gt; 0\"&gt; &lt;foreach collection=\"stuNos\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用list集合--&gt; &lt;select id=\"queryStudentWithList\" parameterType=\"list\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"list != null and list.size &gt; 0\"&gt; &lt;foreach collection=\"list\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用简单数组--&gt; &lt;select id=\"queryStudentWithArray\" parameterType=\"int[]\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345678910111213&lt;!-- foreach迭代 使用对象数组--&gt; &lt;select id=\"queryStudentWithObjectArray\" parameterType=\"Object[]\" resultType=\"student\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 1public List&lt;Student&gt; queryStudentWithObjectArray(Student[] stuNos); sql片段1234567891011121314151617&lt;sql id=\"ObjectArraySql\"&gt; select stuno,stuname,stuage,graname from student &lt;where&gt; &lt;if test=\"array != null and array.length &gt; 0\"&gt; &lt;foreach collection=\"array\" open=\"and stuno in(\" close=\")\" item=\"student\" separator=\",\"&gt; #&#123;student.stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt;&lt;select id=\"queryStudentWithObjectArray\" parameterType=\"Object[]\" resultType=\"student\"&gt; &lt;!-- 同一文件映射文件下可以省略当前namespace：namesapceId --&gt; &lt;include refid=\"pers.nicolas.mapper.StudentMapper.ObjectArraySql\"&gt;&lt;/include&gt; &lt;/select&gt; 查询关联查询：一对一:a.业务扩展类 核心：用resultType指定类(该类扩展了连接查询的所有属性)的属性 包含 多表查询的所有字段 b.resultMap i.通过 属性成员 将2个类建立起联系 -&gt;一对一：association 2. 1234567891011&lt;resultMap type=\"student\" id=\"student_card_map\"&gt; &lt;!-- 学生的信息 --&gt; &lt;id property=\"stuNo\" column=\"stuNo\"/&gt; &lt;result property=\"stuName\" column=\"stuName\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;!-- 一对一时，对象成员使用 association映射;javaType指定该属性的类型--&gt; &lt;association property=\"card\" javaType=\"StudentCard\" &gt; &lt;id property=\"cardId\" column=\"cardId\"/&gt; &lt;result property=\"cardInfo\" column=\"cardInfo\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对一：association一对多：collection 一对多：表：student studentclass (关联：classid)类：student studentClass (关联：List students ) 123456789101112131415161718192021222324&lt;!-- 利用resultMap实现一对多 --&gt; &lt;select id=\"queryClassAndStudents\" parameterType=\"int\" resultMap=\"class_student_map\"&gt; select s.*,c.* from student s inner join studentclass c on s.classid = c.classid where c.classid = #&#123;classId&#125; &lt;/select&gt; &lt;!-- 类与表一一对应 --&gt; &lt;resultMap type=\"StudentClass\" id=\"class_student_map\"&gt; &lt;id property=\"classId\" column=\"classId\" /&gt; &lt;result property=\"className\" column=\"className\" /&gt; &lt;!-- 一对多；属性类型javaType；（集合）属性的元素类型ofType --&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;id property=\"stuNo\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" /&gt; &lt;association property=\"card\" javaType=\"StudentCard\"&gt; &lt;id property=\"cardId\" column=\"cardid\" /&gt; &lt;result property=\"cardInfo\" column=\"cardInfo\" /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/resultMap&gt; 一对多 （MyBatis:多对一，多对多的本质就是 一对多的变化） 关联的嵌套 Select 查询可以传入多个参数column=”{prop1=col1,prop2=col2}” 注意接收属性为Map 123456789&lt;association property=\"userSolved\" javaType=\"INTEGER\"select=\"com.yoj.web.dao.SolutionMapper.querySolved\"column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;association property=\"userSubmitted\" javaType=\"INTEGER\"select=\"com.yoj.web.dao.SolutionMapper.querySubmitted\"column=\"&#123;userId = user_id,problemId = problem_id&#125;\"&gt;&lt;/association&gt;&lt;/resultMap&gt; 12345@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; and result = 0 LIMIT 1\")Integer querySolved(Map&lt;String,Object&gt; map);@Select(\"SELECT solution_id FROM solution WHERE problem_id = #&#123;problemId&#125; and user_id = #&#123;userId&#125; LIMIT 1\")Integer querySubmitted(Map&lt;String,Object&gt; map); 属性 描述 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;{prop1=col1,prop2=col2}&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 fetchType 可选的。有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 示例： 1234567891011&lt;resultMap id=\"blogResult\" type=\"Blog\"&gt; &lt;association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectBlog\" resultMap=\"blogResult\"&gt; SELECT * FROM BLOG WHERE ID = #&#123;id&#125;&lt;/select&gt;&lt;select id=\"selectAuthor\" resultType=\"Author\"&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt; 就是这么简单。我们有两个 select 查询语句：一个用来加载博客（Blog），另外一个用来加载作者（Author），而且博客的结果映射描述了应该使用 selectAuthor 语句加载它的 author 属性。 其它所有的属性将会被自动加载，只要它们的列名和属性名相匹配。 这种方式虽然很简单，但在大型数据集或大型数据表上表现不佳。这个问题被称为“N+1 查询问题”。 概括地讲，N+1 查询问题是这样子的： 你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。 对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。 这个问题会导致成百上千的 SQL 语句被执行。有时候，我们不希望产生这样的后果。 好消息是，MyBatis 能够对这样的查询进行延迟加载，因此可以将大量语句同时运行的开销分散开来。 然而，如果你加载记录列表之后立刻就遍历列表以获取嵌套的数据，就会触发所有的延迟加载查询，性能可能会变得很糟糕。 模糊查询使用#{}，￥{}容易sql注入 使用concat函数拼接 1234567891011&lt;select id=\"getProblemList\" parameterType=\"com.yoj.web.bean.Problem\" resultMap=\"ProblemList\"&gt; select problem_id,title,#&#123;userId&#125; as user_id from problem &lt;where&gt; &lt;if test=\"problemId != null\"&gt; and problem_id LIKE CONCAT('%',#&#123;problemId&#125;,'%') &lt;/if&gt; &lt;if test=\"title != null\"&gt; and title LIKE CONCAT('%',#&#123;title&#125;,'%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 日志：Log4ja.Log4j: log4j.jar (mybatis.zip中lib中包含此jar)b.开启日志，conf.xml 1234&lt;settings&gt; &lt;!-- 开启日志，并指定使用的具体日志 --&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt;&lt;/settings&gt; 如果不指定，Mybatis就会根据以下顺序 寻找日志SLF4J →Apache Commons Logging →Log4j 2 → Log4j →JDK logging c.编写配置日志输出文件 log4j.properties，内容 1234log4j.rootLogger=DEBUG, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别：​ DEBUG&lt;INFO&lt;WARN&lt;ERROR如果设置为info，则只显示 info及以上级别的信息；建议：在开发时设置debug，在运行时设置为info或以上。 可以通过日志信息，相信的阅读mybatis执行情况（ 观察mybatis实际执行sql语句 以及SQL中的参数 和返回结果） 延迟加载（懒加载）：一对一、一对多、多对一、多对多一对多：班级-学生 ，如果不采用延迟加载 （立即加载），查询时会将 一 和多 都查询，班级、班级中的所有学生。如果想要 暂时只查询1的一方， 而多的一方 先不查询 而是在需要的时候再去查询 –&gt;延迟加载 一对一：学生、学生证 mybatis中使用延迟加载，需要先配置：123456&lt;settings&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 关闭立即加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 如果增加了mapper.xml ,要修改conf.xml配置文件（将新增的mapper.xml加载进去） 通过debug可以发现， 如果程序只需要学生，则只向数据库发送了查询学生的SQL；当我们后续 需要用到学生证的时候，再第二次发送 查询学生证的SQL。 123456789101112131415161718192021222324252627&lt;mapper namespace=\"pers.nicolas.mapper.StudentCardMapper\"&gt; &lt;!-- 后续通过namespace.Id 定位该SQL语句 --&gt; &lt;!-- parameterType：输入参数的类型 resultType：查询结果的返回类型 --&gt; &lt;!-- 根据cardId查学生证信息--&gt; &lt;select id=\"qeuryCardById\" parameterType=\"int\" resultType=\"studentCard\"&gt; select * from studentcard where cardid = #&#123;cardId&#125; &lt;/select&gt;&lt;!-- 延迟加载 --&gt; &lt;select id=\"queryStudentWithLazyLoad\" resultMap=\"student_card_lazyload_map\"&gt; &lt;!-- 先查学生 --&gt; select * from student &lt;/select&gt; &lt;resultMap type=\"student\" id=\"student_card_lazyload_map\"&gt; &lt;id property=\"stuNo\" column=\"stuno\" /&gt; &lt;result property=\"stuName\" column=\"stuname\" /&gt; &lt;result property=\"stuAge\" column=\"stuAge\" /&gt; &lt;result property=\"graName\" column=\"graname\" /&gt; &lt;result property=\"stuSex\" column=\"stusex\" /&gt; &lt;!-- 延迟加载： 在加载学生时，并不立即加载学生证信息 通过调用sql column外键传参 --&gt; &lt;association property=\"card\" javaType=\"StudentCard\" select=\"pers.nicolas.mapper.StudentCardMapper.qeuryCardById\" column=\"cardid\"&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多：和一对一的延迟加载配置方法相同 延迟加载的步骤：先查班级，按需查询学生1.开启延迟加载conf.xml配置settings2.配置mapper.xml 写2个Mapper: 班级mapper.xml 123456789101112 &lt;select id=\"queryClassAndStudents\" resultMap=\"class_student_lazyLoad_map\"&gt; select c.* from studentclass c&lt;/select&gt;&lt;resultMap type=\"studentClass\" id=\"class_student_lazyLoad_map\"&gt; &lt;!-- 因为 type的主类是班级，因此先配置班级的信息--&gt; &lt;id property=\"classId\" column=\"classId\"/&gt; &lt;result property=\"className\" column=\"className\"/&gt; &lt;!-- 配置成员属性学生，一对多;属性类型：javaType，属性的元素类型ofType --&gt; &lt;!-- 2222222再查班级对应的学生 --&gt; &lt;collection property=\"students\" ofType=\"student\" select=\"org.lanqiao.mapper.StudentMapper.queryStudentsByClassId\" column=\"classid\"&gt;​ &lt;/collection&gt;​1234&lt;/resultMap&gt;​ 即查询 学生的sql是通过 select属性指定，并且通过column指定外键 ​1234567学生mapper.xml&lt;!-- 一对多,延迟加载需要的： 查询班级中的所有学生 --&gt;&lt;select id=\"queryStudentsByClassId\" parameterType=\"int\" resultType=\"student\"&gt; select * from student where classId = #&#123;classId&#125;&lt;/select&gt; 查询缓存一级缓存 ：同一个SqlSession对象 ​ MyBatis默认开启一级缓存，如果用同样的SqlSession对象查询相同的数据，​ 则只会在第一次 查询时 向数据库发送SQL语句，并将查询的结果 放入到 SQLSESSION中（作为缓存存在）； 后续再次查询该同样的对象时， 则直接从缓存中查询该对象即可（即省略了数据库的访问） 二级缓存​ MyBatis默认情况没有开启二级缓存，需要手工打开。​ a.conf.xml 12&lt;!-- 开启二级缓存 --&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; ​ b.在具体的mapper.xml中声明开启(studentMapper.xml中) 123&lt;mapper namespace=\"org.lanqiao.mapper.StudentMapper\"&gt; &lt;!-- 声明次namespace开启二级缓存 --&gt;&lt;cache/&gt; 根据异常提示：NotSerializableException可知，MyBatis的二级缓存 是将对象 放入硬盘文件中 序列化：内存-&gt;硬盘 反序列化：硬盘-&gt;内存准备缓存的对象，必须实现了序列化接口 （如果开启的缓存Namespace=”org.lanqiao.mapper.StudentMapper”），可知序列化对象为Student，因此需要将Student序列化 （序列化Student类，以及Student的级联属性、和父类） 触发将对象写入二级缓存的时机：SqlSession对象的close()方法。 Mybatis自带二级缓存：【同一个namespace】生成的mapper对象回顾：namespace的值 就是 接口的全类名（包名.类名）， 通过接口可以产生代理对象（studentMapper对象） –&gt;namespace决定了studentMapper对象的产生结论：只要产生的xxxMapper对象 来自于同一个namespace，则 这些对象 共享二级缓存。注意：二级缓存 的范围是同一个namespace, 如果有多个xxMapper.xml的namespace值相同，则通过这些xxxMapper.xml产生的xxMapper对象 仍然共享二级缓存。 禁用 ：select标签中useCache=”false” 清理：a.与清理一级缓存的方法相同 commit(); （一般执行增删改时 会清理掉缓存；设计的原因 是为了防止脏数据）在二级缓存中，commit()不能是查询自身的commit。 commit会清理一级和二级缓存；但是 清理二级缓存时，不能是查询自身的commit； b. 在select标签中 增加属性 flushCache=”true” 命中率： 1:zs :0% 2: 50% 3: 2/3 0.666 4: 3/4 0.75 三方提供的二级缓存：ehcache、memcache 要想整合三方提供的二级缓存 （或者自定义二级缓存），必须实现org.apache.ibatis.cache.Cache接口，该接口的默认实现类是PerpetualCache 整合ehcache二级缓存：a.ehcache-core.jarmybatis-Ehcache.jarslf4j-api.jar b.编写ehcache配置文件 Ehcache.xml 12345678910111213141516171819202122232425&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;!--当二级缓存的对象 超过内存限制时（缓存对象的个数&gt;maxElementsInMemory），存放入的硬盘文件 --&gt; &lt;diskStore path=\"E:\\Ehcache\"/&gt; &lt;!-- maxElementsInMemory:设置 在内存中缓存 对象的个数 maxElementsOnDisk：设置 在硬盘中缓存 对象的个数 eternal：设置缓存是否 永远不过期 overflowToDisk：当内存中缓存的对象个数 超过maxElementsInMemory的时候，是否转移到硬盘中 timeToIdleSeconds：当2次访问 超过该值的时候，将缓存对象失效 timeToLiveSeconds：一个缓存对象 最多存放的时间（生命周期） diskExpiryThreadIntervalSeconds：设置每隔多长时间，通过一个线程来清理硬盘中的缓存 memoryStoreEvictionPolicy：当超过缓存对象的最大值时，处理的策略；LRU，FIFO,LFU --&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"1000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"100\" timeToLiveSeconds=\"100\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; c.开启EhCache二级缓存 在xxxMapper.xml中开启 12345&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!-- 通过property覆盖Ehcache.xml中的值 --&gt; &lt;property name=\"maxElementsInMemory\" value=\"2000\"/&gt; &lt;property name=\"maxElementsOnDisk\" value=\"3000\"/&gt; &lt;/cache&gt; 逆向工程表、类、接口、mapper.xml四者密切相关，因此 当知道一个的时候 其他三个应该可以自动生成。表-&gt;其他三个 实现步骤： a. 导入依赖 mybatis-generator-core.jar、mybatis.jar、ojdbc.jar 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; b. 逆向工程的配置文件generator.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!-- suppressAllComments属性值： true:自动生成实体类、SQL映射文件时没有注释 false:自动生成实体类、SQL映射文件，并附有注释 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库连接信息 --&gt; &lt;jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:ORCL\" userId=\"scott\" password=\"tigger\"&gt; &lt;/jdbcConnection&gt; &lt;!-- forceBigDecimals属性值： true:把数据表中的DECIMAL和NUMERIC类型， 解析为JAVA代码中的java.math.BigDecimal类型 false(默认):把数据表中的DECIMAL和NUMERIC类型， 解析为解析为JAVA代码中的Integer类型 --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject属性值:实体类的生成位置 targetPackage属性值：实体类所在包的路径 --&gt; &lt;javaModelGenerator targetPackage=\"org.lanqiao.entity\" targetProject=\".\\src\"&gt; &lt;!-- trimStrings属性值： true：对数据库的查询结果进行trim操作 false(默认)：不进行trim操作 --&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject属性值:SQL映射文件的生成位置 targetPackage属性值：SQL映射文件所在包的路径 --&gt; &lt;sqlMapGenerator targetPackage=\"org.lanqiao.mapper\" targetProject=\".\\src\"&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成动态代理的接口 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"org.lanqiao.mapper\" targetProject=\".\\src\"&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=\"Student\"&gt; &lt;/table&gt; &lt;table tableName=\"studentCard\"&gt; &lt;/table&gt; &lt;table tableName=\"studentClass\"&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; c. 执行 12345678File file = new File(\"src/generator.xml\"); // 配置文件 List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(file); DefaultShellCallback callback = new DefaultShellCallback(true); // 逆向工程核心类 MyBatisGenerator generator = new MyBatisGenerator(config, callback, warnings); generator.generate(null); 123456789101112131415161718192021import java.io.File;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;public class MybatisGeneratorTest &#123; public static void main(String[] args) throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mybatis-generator.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 常用方法取到最后生成的主键1&lt;!--取到最后生成的主键--&gt;&lt;insert id=\"insertSelective\" useGeneratedKeys=\"true\" keyColumn=\"problem_id\" keyProperty=\"problemId\" parameterType=\"com.yoj.web.bean.Problem\"&gt; [用Criteria实现多条件查询](https://blog.csdn.net/qjlhlh/article/details/6599557) 逆向工程产生的bean（entity class）的扩展类中的静态内部类。 mybatis注解版插入时返回主键id1234567@Mapperpublic interface UserMapper&#123; @Insert(\"insert into tbl_user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)\") @Options(useGeneratedKeys=true, keyProperty=\"userId\", keyColumn=\"id\") void insertUser(User user);&#125; 调用其他方法1234567891011121314@Select(\"SELECT * FROM solution ORDER BY solution_id DESC\")@Results(&#123; @Result(id = true, column = \"solution_id\", property = \"solutionId\"), @Result(column = \"problem_id\", property = \"problem\", one = @One(select = \"com.yoj.web.dao.ProblemMapper.queryProblemTitleAndIdById\", fetchType = FetchType.EAGER)), @Result(column = \"language\", property = \"language\"), @Result(column = \"code\", property = \"code\"), @Result(column = \"result\", property = \"result\"), @Result(column = \"runtime\", property = \"runtime\"), @Result(column = \"memory\", property = \"memory\"), @Result(column = \"error_message\", property = \"errorMessage\"), @Result(column = \"submit_time\", property = \"submitTime\"), @Result(column = \"user_id\", property = \"user\", one = @One(select = \"com.yoj.web.dao.UserMapper.getUserById\", fetchType = FetchType.EAGER))&#125;)List&lt;Solution&gt; getAllWithUserAndProblemName(); other自动映射当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。 这意味着如果发现了 ID 列和 id 属性，MyBatis 会将列 ID 的值赋给 id 属性。 通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将 mapUnderscoreToCamelCase 设置为 true。","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"https://codeofli.github.io/tags/mybatis/"}]},{"title":"javaWeb","slug":"java-note/javaWeb/javaWeb","date":"2019-11-12T02:39:06.000Z","updated":"2019-11-12T02:57:37.399Z","comments":true,"path":"2019/11/java-note/javaWeb/javaWeb/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/javaWeb/javaWeb/","excerpt":"[TOC]web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath());%&gt; $&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt;","text":"[TOC]web路径 web路径：1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名;就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath());%&gt; $&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt; 1JSP:动态网页静态、动态：1.不用 和 是否有“动感”混为一谈2.是否 随着 时间、地点、用户操作 的 改变而改变 动态网页 需要使用到 服务端脚本语言（JSP） 2架构CS：Client ServerCS不足：a.如果 软件升级， 那么全部软件都需要升级b.维护麻烦：需要维护每一台 客户端软件c.每一台客户端 都需要安装 客户端软件 BS ：Broswer Server客户端可以通过 浏览器 直接访问服务端 注意：bs和cs各有优势。 3.tomcat解压后目录：bin:可执行文件（startup.bat shutdown.bat）conf:配置文件（server.xml）lib：tomcat依赖的jar文件log:日志文件（记录出错等信息）temp:临时文件webapps：可执行的项目（将我们开发的项目 放入该目录）work:存放由jsp翻译成的java,以及编辑成的class文件(jsp -&gt;java -&gt;class) 4.配置tomcata.配置jdk (必须配置JAVA_HOME)java_home classPath pathb.配置catalina_home 双击bin/startup.bat启动tomacat，常见错误： 可能与其他服务的端口号冲突tomcat端口号默认8080 （此端口号较为常见，容易冲突），建议修改此端口 （8888） 修改端口号： 5.访问tomcathttp://localhost:8888/ 常见状态码：200：一切正常300/301: 页面重定向 （跳转）404:资源不存在403：权限不足 （如果访问a目录，但是a目录设置 不可见）500：服务器内部错误（代码有误）其他编码：积累 jsp：在html中嵌套的java代码 在项目/WEB-INF/web.xml中设置 默认的 初始页面 &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;6.虚拟路径a.方式一将web项目配置到 webapps以外的目录conf/server.xml中配置host标签中： docBase：实际路径path：虚拟路径 （绝对路径、相对路径【相对于webapps】）重启 b.方式二D:\\study\\apache-tomcat-8.5.30\\conf\\Catalina\\localhost中新建 “项目名.xml”中新增一行： 7.虚拟主机通过www.test.com访问本机a. conf/server.xml &lt;Host appBase=&quot;D:\\study\\JspProject&quot; name=&quot;www.test.com&quot;&gt; &lt;Context docBase=&quot;D:\\study\\JspProject&quot; path=&quot;/&quot;/&gt; &lt;/Host&gt;b.C:\\Windows\\System32\\drivers\\etc\\host增加127.0.0.1 www.test.com 流程：www.test.com -&gt; host找映射关系 -&gt;server.xml找Engine的defaultHost -&gt;通过”/“映射到D:\\study\\JspProject为了后续学习，将以上恢复成默认 7.JSP执行流程jsp- java(Servlet文件) -classD:\\study\\apache-tomcat-8.5.30\\work\\Catalina\\localhost\\JspProject\\org\\apache\\jsp Jsp 和Servlet 可以相互转换因为第一请求服务端 会有翻译 和编译的过程，因此比较慢； 后续访问 可以直接访问class,因此速度较快。但是 如果 服务端修改了代码，则再次访问时 会重新的翻译、编译。 1.使用Eclipse开发Web项目(JSP项目) tomcat 在Eclipse中创建的Web项目：浏览器可以直接访问 WebContent中的文件，例如http://localhost:8888/MyJspProject/index1.jsp其中的index1.jsp就在WebContent目录中；但是WEB-INF中的文件 无法通过客户端（浏览器）直接访问，只能通过请求转发来访问 注意：并不是 任何的内部跳转都能访问WEB-INF；原因是 跳转有2种方式：请求转发 、重定向 3.配置tomcat运行时环境 jsp&lt;-&gt;Servleta.将tomcat/lib中的servlet-api.jar加入项目的构建路径b.右键项目-&gt;Build Path -&gt; Add library -&gt;Server Runtime 4.部署tomcat在servers面板 新建一个 tomcat实例 ， 再在该实例中 部署项目（右键-add）之后运行 注意：一般建议 将eclipse中的tomcat与 本地tomcat的配置信息保持一致： 将eclipse中的tomcat设置为托管模式：【第一次】创建tomcat实例之后， 双击，选择Server Location的第二项 5.统一字符集编码a.编码分类：设置jsp文件的编码（jsp文件中的pageEncoding属性）： jsp -&gt; java设置浏览器读取jsp文件的编码（jsp文件中content属性）一般将上述设置成 一致的编码，推荐使用UTF-8文本编码： i.将整个eclipse中的文件 统一设置 （推荐） ii.设置 某一个项目 iii.设置单独文件 6. JSP的页面元素： HTML java代码（脚本Scriptlet）、指令、注释a.脚本Scriptlet i. &lt;% 局部变量、java语句 %&gt; ii. &lt;%! 全局变量、定义方法 %&gt; iii. &lt;%=输出表达式 %&gt;一般而言，修改web.xml、配置文件、java 需要重启tomcat服务但是如果修改 Jsp\\html\\css\\js ，不需要重启 注意，out.println()不能回车； 要想回车：“”，即out.print() &lt;%= %&gt; 可以直接解析html代码 b.指令page指令 &lt;%@ page ….%&gt;page指定的属性：language:jsp页面使用的脚本语言import:导入类pageEncoding:jsp文件自身编码 jsp -&gt;javacontentType:浏览器解析jsp的编码&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8” import=”java.util.Date” %&gt; c.注释 html注释 ,可以被客户 通过浏览器查看源码 所观察到 java注释// /…/ jsp注释&lt;%– –%&gt; 7.JSP九大内置对象（自带的，不需要new 也能使用的对象） out：输出对象，向客户端输出内容request：请求对象；存储“客户端向服务端发送的请求信息”request对象的常见方法：String getParameter(String name) :根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值）String[] getParameterValues(String name): 根据请求的字段名key ，返回多个字段值value （checkbox）void setCharacterEncoding(“编码格式utf-8”) ：设置post方式的请求编码 （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8）getRequestDispatcher(“b.jsp”).forward(request,response) ; ：请求转发 的方式跳转页面 A - &gt; BServletContext getServerContext():获取项目的ServletContext对象 示例：注册register.jsp ，show.jsp http://localhost:8888/MyJspProject/show.jsp?uname=aa&amp;upwd=123&amp;uage=22&amp;uhobbies=%E7%AF%AE%E7%90%83 连接/文件？参数名1=参数值1 &amp; 参数名2=参数值2 &amp; 参数名1=参数值1 get提交方式: method=”get” 和 地址栏 、超链接()请求方式 默认都属于get提交方式 get与post请求方式的区别：a. get方式 在地址栏显示 请求信息 (但是地址栏能够容纳的 信息有限，4-5KB；如果请求数据存在大文件，图片等 会出现地址栏无法容纳全部的数据而出错) ；post不会显示b. 文件上传操作，必须是post推荐使用post 8.统一请求的编码 requestget方式请求 如果出现乱码，解决：a.统一每一个变量的 编码 （不推荐） new String( 旧编码，新编码); name = new String(name.getBytes(“iso-8859-1”),”utf-8”); b. 修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8）建议 使用tomcat时， 首先在server.xml中 统一get方式的编码.. URIEncoding=”UTF-8” tomcat7 (iso-8859-1) tomcat8（utf-8） postrequest.setCharacterEncoding(“utf-8”) ; 1response :响应对象提供的方法：void addCookie( Cookie cookie ); 服务端向客户端增加cookie对象void sendRedirect(String location ) throws IOException; :页面跳转的一种方式（重定向）void setContetType(String type):设置服务端响应的编码（设置服务端的contentType类型） 示例：登陆login.jsp -&gt; check.jsp -&gt;success.jsp 请求转发 重定向地址栏是否改变 不变(check.jsp) 改变(success.jsp) 是否保留第一次 保留 不保留 –4种范围对象请求时的数据 请求的次数 1 2 跳转发生的位置 服务端 客户端发出的第二次跳转 转发、重定向： 转发： 张三（客户端） -&gt; 【 服务窗口 A （服务端 ） -&gt; 服务窗口B 】 重定向： 张三（客户端） -&gt; 服务窗口 A （服务端 ） -&gt;去找B 张三（客户端） -&gt; 服务窗口 B （服务端 ） -&gt;结束 session(服务端)Cookie（客户端，不是内置对象）:Cookie是由 服务端生成的 ，再发送给客户端保存。相当于 本地缓存的作用： 客户端(hello.mp4,zs/abc)-&gt;服务端(hello.mp4；zs/abc)作用：提高访问服务端的效率，但是安全性较差。 Cookie： name=valuejavax.servlet.http.Cookiepublic Cookie(String name,String value)String getName()：获取nameString getValue():获取valuevoid setMaxAge(int expiry);最大有效期 （秒） 服务端准备Cookie： response.addCookie(Cookie cookie)页面跳转（转发，重定向）客户端获取cookie: request.getCookies(); a.服务端增加cookie :response对象；客户端获取对象：request对象b.不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到 通过F12可以发现 除了自己设置的Cookie对象外，还有一个name为 JSESSIONID的cookie 建议 cookie只保存 英文数字，否则需要进行编码、解码 使用Cookie实现 记住用户名 功能 4.session :会话a.浏览网站：开始-关闭b.购物： 浏览、付款、退出c.电子邮件：浏览、写邮件、退出 开始-结束 session机制： 客户端第一次请求服务端时，（jsessionid-sessionid）服务端会产生一个session对象（用于保存该客户的信息）；并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session);服务端由会 产生一个cookie，并且 该cookie的name=JSESSIONID ,value=服务端sessionId的值；然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)；因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID） 客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID 去服务端的session中匹配sessionid,如果匹配成功（cookie jsessionid和sesion sessionid），说明此用户 不是第一次访问,无需登录； 例子：客户端： 顾客（客户端）服务端: 存包处 - 商场(服务端) 顾客第一次存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙）。 如果是新顾客（没钥匙） ，分配一个钥匙 给该顾客； 钥匙 会和 柜子 一一对应； 第二/n次 存包：商场 判断此人是 之前已经存过包（通过你手里是否有钥匙） 如果是老顾客（有钥匙），则不需要分配；该顾客手里的钥匙 会 和柜子 自动一一对应。 session:a. session存储在服务端b. session是在 同一个用户（客户）请求时 共享c. 实现机制：第一次客户请求时 产生一个sessionid 并复制给 cookie的jsessionid 然后发给客户端。最终 通过session的sessionid-cookie的jsessionid session方法：String getId() :获取sessionIdboolean isNew() :判断是否是 新用户（第一次访问）void invalidate():使session失效 （退出登录、注销） void setAttribute()Object getAttribute(); void setMaxInactiveInterval(秒) ：设置最大有效 非活动时间int getMaxInactiveInterval():获取最大有效 非活动时间 示例：登录 客户端在第一次请求服务端时，如果服务端发现 此请求没有 JSESSIONID,则会创建一个 name=JSESIONID的cookie 并返回给客户端 Cookie：a.不是内对对象，要使用必须newb.但是，服务端会 自动生成一个(服务端自动new一个cookie) name=JSESIONID的cookie 并返回给客户端 cookie和session的区别： session cookie保存的位置 服务端 客户端安全性 较安全 较不安全保存的内容 Object String appliation 全局对象String getContextPath() 虚拟路径String getRealPath(String name): 绝对路径（虚拟路径 相对的绝对路径） JSP9大内置对象pageContext JSP页面容器request 请求对象session 会话对象appliation 全局对象 response 响应对象 config 配置对象（服务器配置信息）out 输出对象page 当前JSP页面对象（相当于java中的this）exception 异常对象 四种范围对象（小-&gt;大）pageContext JSP页面容器 （page对象）； 当前页面有效request 请求对象 同一次请求有效session 会话对象 同一次会话有效appliation 全局对象 全局有效（整个项目有效） 以上4个对象共有的方法：Object getAttribute(String name):根据属性名，或者属性值void setAttribute(String name,Object obj) :设置属性值（新增，修改） setAttribute(“a”,”b”) ;//如果a对象之前不存在，则新建一个a对象 ； 如果a之前已经存在，则将a的值改为bvoid removeAttribute(String name)：根据属性名，删除对象 a.pageContext 当前页面有效 (页面跳转后无效) b.request 同一次请求有效；其他请求无效 （请求转发后有效；重定向后无效） c.session 同一次会话有效 （无论怎么跳转，都有效；关闭/切换浏览器后无效 ； 从 登陆-&gt;退出 之间 全部有效） d.application 全局变量；整个项目运行期间 都有效 (切换浏览器 仍然有效)；关闭服务、其他项目 无效 -&gt;多个项目共享、重启后仍然有效 ：JNDI 1.以上的4个范围对象，通过 setAttribute()复制，通过getAttribute()取值；2.以上范围对象，尽量使用最小的范围。因为 对象的范围越大，造成的性能损耗越大。 1.JDBC:Java DataBase Connectivity 可以为多种关系型数据库DBMS 提供统一的访问方式，用Java来操作数据库2.JDBC API 主要功能：三件事，具体是通过以下类/接口实现：DriverManager ： 管理jdbc驱动Connection： 连接（通过DriverManager产生） Statement（PreparedStatement） ：增删改查 （通过Connection产生 ）CallableStatement ： 调用数据库中的 存储过程/存储函数 （通过Connection产生 ） Result ：返回的结果集 （上面的Statement等产生 ） Connection产生操作数据库的对象： Connection产生Statement对象：createStatement()Connection产生PreparedStatement对象：prepareStatement()Connection产生CallableStatement对象：prepareCall(); Statement操作数据库：增删改：executeUpdate()查询：executeQuery(); ResultSet：保存结果集 select * from xxxnext():光标下移，判断是否有下一条数据；true/falseprevious(): true/falsegetXxx(字段名|位置):获取具体的字段值 PreparedStatement操作数据库：public interface PreparedStatement extends Statement因此增删改：executeUpdate()查询：executeQuery();–此外赋值操作 setXxx(); PreparedStatement与Statement在使用时的区别：1.Statement:sqlexecuteUpdate(sql) 2.PreparedStatement:sql(可能存在占位符?)在创建PreparedStatement 对象时，将sql预编译 prepareStatement(sql)executeUpdate()setXxx()替换占位符？ 推荐使用PreparedStatement：原因如下：1.编码更加简便（避免了字符串的拼接）String name = “zs” ;int age = 23 ; stmt:String sql =” insert into student(stuno,stuname) values(‘“+name+”‘, “+age+” ) “ ;stmt.executeUpdate(sql); pstmt:String sql =” insert into student(stuno,stuname) values(?,?) “ ;pstmt = connection.prepareStatement(sql);//预编译SQLpstmt.setString(1,name);pstmt.setInt(2,age); 2.提高性能(因为 有预编译操作，预编译只需要执行一次)需要重复增加100条数stmt:String sql =” insert into student(stuno,stuname) values(‘“+name+”‘, “+age+” ) “ ;for(100)stmt.executeUpdate(sql); pstmt:String sql =” insert into student(stuno,stuname) values(?,?) “ ;pstmt = connection.prepareStatement(sql);//预编译SQLpstmt.setString(1,name);pstmt.setInt(2,age);for( 100){pstmt.executeUpdate();} 3.安全（可以有效防止sql注入）sql注入： 将客户输入的内容 和 开发人员的SQL语句 混为一体 stmt:存在被sql注入的风险(例如输入 用户名：任意值 ‘ or 1=1 – 密码：任意值)分析：select count() from login where uname=’任意值 ‘ or 1=1 –’ and upwd =’任意值’ ;select count() from login where uname=’任意值 ‘ or 1=1 ;select count(*) from login ; select count(*) from login where uname=’”+name+”‘ and upwd =’”+pwd+”‘ pstmt:有效防止sql注入 推荐使用pstmt 3.jdbc访问数据库的具体步骤：a.导入驱动，加载具体的驱动类b.与数据库建立连接c.发送sql，执行d.处理结果集 （查询） 4.数据库驱动 驱动jar 具体驱动类 连接字符串Oracle ojdbc-x.jar oracle.jdbc.OracleDriver jdbc:oracle:thin:@localhost:1521:ORCLMySQL mysql-connector-java-x.jar com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/数据库实例名SqlServer sqljdbc-x.jar com.microsoft.sqlserver.jdbc.SQLServerDriver jdbc:microsoft:sqlserver:localhost:1433;databasename=数据库实例名 使用jdbc操作数据库时，如果对数据库进行了更换，只需要替换：驱动、具体驱动类、连接字符串、用户名、密码 1.jdbc总结（模板、八股文）：try{a.导入驱动包、加载具体驱动类Class.forName(“具体驱动类”);b.与数据库建立连接connection = DriverManager.getConnection(…);c.通过connection，获取操作数据库的对象（Statement\\preparedStatement\\callablestatement）stmt = connection.createStatement();d.(查询)处理结果集rs = pstmt.executeQuery()while(rs.next()){ rs.getXxx(..) ;}}catch(ClassNotFoundException e ){ …}catch(SQLException e){…}catch(Exception e){…}finally{ //打开顺序，与关闭顺序相反 if(rs!=null)rs.close() if(stmt!=null) stmt.close(); if(connection!=null)connection.close();} –jdbc中，除了Class.forName() 抛出ClassNotFoundException，其余方法全部抛SQLException 2.CallableStatement:调用 存储过程、存储函数connection.prepareCall(参数：存储过程或存储函数名)参数格式：存储过程（无返回值return，用out参数替代）： { call 存储过程名(参数列表) }存储函数（有返回值return）： { ? = call 存储函数名(参数列表) } create or replace procedure addTwoNum ( num1 in number,num2 in number,result out number ) – 1 + 2 -&gt;3asbegin result := num1+num2 ;end ;/ 强调：如果通过sqlplus 访问数据库，只需要开启：OracleServiceSID通过其他程序访问数据（sqldevelop、navicate、JDBC），需要开启：OracleServiceSID、XxxListener JDBC调用存储过程的步骤：a.产生 调用存储过程的对象（CallableStatement） cstmt = connection.prepareCall( “…” ) ;b.通过setXxx()处理 输出参数值 cstmt.setInt(1, 30);c.通过 registerOutParameter(…)处理输出参数类型d.cstmt.execute()执行e.接受 输出值（返回值）getXxx() 调存储函数：create or replace function addTwoNumfunction ( num1 in number,num2 in number) – 1 + 2return numberas result number ;begin result := num1+num2 ; return result ;end ;/JDBC调用存储函数：与调存储过程的区别：在调用时，注意参数：”{? = call addTwoNumfunction (?,?) }” 3.处理CLOB/BLOB类型处理稍大型数据： a.存储路径 E:\\JDK_API_zh_CN.CHM 通过JDBC存储文件路径，然后 根据IO操作处理 例如：JDBC将 E:\\JDK_API_zh_CN.CHM 文件 以字符串形式“E:\\JDK_API_zh_CN.CHM”存储到数据库中 获取：1.获取该路径“E:\\JDK_API_zh_CN.CHM” 2.IO b. CLOB：大文本数据 （小说-&gt;数据） BLOB：二进制 clob:大文本数据 字符流 Reader Writer存1.先通过pstmt 的? 代替小说内容 （占位符）2.再通过pstmt.setCharacterStream(2, reader, (int)file.length()); 将上一步的？替换为 小说流， 注意第三个参数需要是 Int类型 取：1.通过Reader reader = rs.getCharacterStream(“NOVEL”) ; 将cloc类型的数据 保存到Reader对象中2. 将Reader通过Writer输出即可。 blob:二进制 字节流 InputStream OutputStream与CLOB步骤基本一致，区别：setBinaryStream(…) getBinaryStream(…) 4.JSP访问数据库 JSP就是在html中嵌套的java代码，因此 java代码可以写在jsp中（&lt;% … %&gt;） 导包操作：java项目 ：1 Jar复制到工程中 2.右键该Jar :build path -&gt;add to build Path Web项目：jar复制到WEB-INF/lib 核心：就是将 java中的JDBC代码，复制到 JSP中的&lt;% … %&gt; 注意：如果jsp出现错误：The import Xxx cannot be resolved 尝试解决步骤： a.(可能是Jdk、tomcat版本问题) 右键项目-&gt;build path，将其中 报错的 libary或Lib 删除后 重新导入 b.清空各种缓存：右键项目-&gt;Clean tomcat… clean （Project -clean或者 进tomcat目录 删除里面work的子目录） c.删除之前的tomcat，重新解压缩、配置tomcat，重启计算机 d.如果类之前没有包，则将该类加入包中 5.JavaBean刚才我们将 jsp中 登录操作的代码 转移到了LoginDao.java；其中LoginDao类 就称之为JavaBean。JavaBean的作用：a.减轻的jsp复杂度 b.提高代码复用（以后任何地方的 登录操作，都可以通过调用LoginDao实现） JavaBean（就是一个Java类）的定义：满足一下2点 ，就可以称为JavaBean a.public 修饰的类 ,public 无参构造 b.所有属性(如果有) 都是private，并且提供set/get (如果boolean 则get 可以替换成is) 使用层面，Java分为2大类：a.封装业务逻辑的JavaBean (LoginDao.java封装了登录逻辑) 逻辑 可以将jsp中的JDBC代码，封装到Login.java类中 （Login.java） b.封装数据的JavaBean （实体类，Student.java Person.java ） 数据 对应于数据库中的一张表 Login login = new Login(uname,upwd) ;//即用Login对象 封装了2个数据（用户名 和密码） 封装数据的JavaBean 对应于数据库中的一张表 (Login(name,pwd))封装业务逻辑的JavaBean 用于操作 一个封装数据的JavaBean 可以发现，JavaBean可以简化 代码(jsp-&gt;jsp+java)、提供代码复用(LoginDao.java) public void sleep(String name,String place, int time){ } public void sleep(Person per){ per.getName() per.getPlace() …} MVC设计模式：M：Model ，模型 ：一个功能。用JavaBean实现。 V:View，视图： 用于展示、以及与用户交互。使用html js css jsp jquery等前端技术实现 C:Controller，控制器 ：接受请求，将请求跳转到模型进行处理；模型处理完毕后，再将处理的结果 返回给 请求处 。 可以用jsp实现， 但是一般建议使用 Servlet实现控制器。 Jsp-&gt;Java(Servlet)-&gt;JSP Servlet：Java类必须符合一定的 规范： a.必须继承 javax.servlet.http.HttpServlet b.重写其中的 doGet()或doPost()方法 doGet()： 接受 并处 所有get提交方式的请求 doPost()：接受 并处 所有post提交方式的请求 Servlet要想使用，必须配置Serlvet2.5：web.xmlServle3.0： @WebServlet Serlvet2.5：web.xml: 项目的根目录：WebContent 、src 所在的jsp是在 WebContent目录中，因此 发出的请求WelcomeServlet 是去请求项目的根目录。 Servlet流程：请求 -&gt; -&gt; 根据中的 去匹配 中的，然后寻找到，求中将请求交由该执行。 2个/:jsp:/ localhost:8888web.xml: / http://localhost:8888/项目名/ 1.回顾纯手工方法创建第一个Servlet步骤：编写一个类，继承HttpServlet重写doGet()、doPost()方法编写web.xml 中的servlet映射关系 2.借助于Eclipse快速生成Servlet直接新建Servlet即可！（继承、重写、web.xml 可以借助Eclipse自动生成） Servlet3.0，与Servlet2.5的区别：Servlet3.0不需要在web.xml中配置，但 需要在 Servlet类的定义处之上编写 注解@WebServlet(“url-pattern的值”)匹配流程： 请求地址 与@WebServlet中的值 进行匹配，如果匹配成功 ，则说明 请求的就是该注解所对应的类 项目根目录：WebContent、src（所有的构建路径）例如：WebContent中有一个文件index.jspsrc中有一个Servlet.java 如果: index.jsp中请求 … ，则 寻找范围：既会在src根目录中找 也会在WebContent根目录中找 如果：index.jsp中请求，寻找范围：先在src或WebContent中找a目录，然后再在a目录中找abc web.xml中的 /:代表项目根路径http://localhost:8888/Servlet25Project/jsp中的/: 服务器根路径http://localhost:8888/ 构建路径、WebContent:根目录 4.Servlet生命周期：5个阶段加载初始化： init() ，该方法会在 Servlet被加载并实例化的以后 执行服务 ：service() -&gt;doGet() doPost销毁 ：destroy()， Servlet被系统回收时执行卸载 init(): a.默认第一次访问 Servlet时会被执行 （只执行这一次） b.可以修改为 Tomcat启动时自动执行 i.Servlet2.5： web.xml … 1 其中的“1”代表第一个。 ii.Servlet3.0 @WebServlet( value=”/WelcomeServlet” ,loadOnStartup=1 ) service() -&gt;doGet() doPost ：调用几次，则执行几次destroy()：关闭tomcat服务时，执行一次。 5 Servlet API ： 由两个软件包组成： 对应于HTTP协议的软件包、对应于除了HTTP协议以外的其他软件包即Servlet API可以适用于 任何 通信协议。我们学习的Servlet,是位于javax.servlet.http包中的类和接口，是基础HTTP协议。 6.Servlet继承关系 ServletConfig:接口ServletContext getServletContext():获取Servlet上下文对象 applicationString getInitParameter(String name):在当前Servlet范围内，获取名为name的参数值（初始化参数） a.ServletContext中的常见方法(application)：getContextPath():相对路径getRealPath()：绝对路径setAttribute() 、getAttribute()—&gt;String getInitParameter(String name);在当前Web容器范围内，获取名为name的参数值（初始化参数） Servlet3.0方式 给当前Servlet设置初始值：@WebServlet( …. , initParams= {@WebInitParam(name=”serveltparaname30”,value=”servletparavalue30”) } )注意，此注解只 隶属于某一个具体的Servlet ，因此无法为 整个web容器设置初始化参数 （如果要通过3.0方式设置 web容器的初始化参数，仍然需要在web.xml中设置） HttpServletRequest中的方法：(同request)，例如setAttrite()、getCookies()、getMethod()HttpServletResponse中的方法：同response Servlet使用层面： Eclipse中在src创建一个Servlet，然后重写doGet() doPost()就可以 （doGet() doPost()只需要编写一个）。 三层优化1.加入接口 建议面向接口开发：先接口-再实现类 –service、dao加入接口 –接口与实现类的命名规范 接口：interface， 起名 I实体类Service IStudentService IStudentDao 实现类：implements 起名 实体类ServiceImpl StudentServiceImpl StudentDaoImpl 接口： I实体类层所在包名 IStudentService、IStudentDao 接口所在的包： xxx.service xx.dao 实现类： 实体类层所在包名Impl StudentServiceImpl、StudentDaoImpl 实现类所在的包：xxx.service.impl xx.dao.impl 以后使用接口/实现类时，推荐写法： 接口 x = new 实现类(); IStudentDao studentDao = new StudentDaoImpl();2.DBUtil 通用的数据库帮助类，可以简化Dao层的代码量 帮助类 一般建议写在 xxx.util包 A{ a(){ B.connection }} B{ static Connection connection =.. b{ }} 方法重构： 将多个方法 的共同代码 提炼出来，单独写在一个方法中，然后引入该方法即可a(){ .. c(); .. } b(){ .. c(); ..} c(){ [.. .. … ..]} Web调试：与java代码的调试 区别：启动方式不同 index.jsp -&gt;index_jsp.java -&gt;index_jsp.class jsp-&gt;java-&gt;classjsp翻译成的Java 以及编译后的class文件 存在于tomcat中的work目录中 10000 分页：5变量（属性）1.数据总数 （select count(*) from xxx ， 查数据库）2.页面大小（页面容量，每页显示的数据条数） （用户自定义）3.总页数 （自动计算） 800:10= 80页 总页数= 数据总数 /页面大小 802:10= 800/10 +1 ； 总页数= 数据总数 /页面大小 + 1; --&gt;通式 总页数= 数据总数 % 页面大小==0 ?数据总数 /页面大小:数据总数 /页面大小 + 1;注意：自动计算的时机：当 数据总数 和 页面大小都被赋值以后，自动计算总页数。 4.当前页码 （用户自定义） 5.实体类对象集合（当前页的数据集合）：依赖于数据库 (查数据库) 假设： 每页显示10条（页面大小=10） select * from student where id&gt;=起始 and id&lt;=终止; 页数 起止 起止等价写法1 1-10 (页数-1)10+1-页数102 11-203 21-30 某一页的数据 起止： (页数-1)*10+1-页数*10select * from student where sno&gt;=(页数-1)10+1 and sno&lt;=页数10;此种分页SQL 严格依赖sno的数据， 一旦sno出现了间隙（裂缝），则无法满足每页10条 -&gt;将此SQL 转换： 1.有rownum 2不能有rownum&gt;xx转换的核心： 将rownum从伪列 转换为 一个 临时表的 普通列。 select from( select rownum r,t.*from (select s. from student s order by sno asc) t ) where r&gt;=(页数-1)10+1 and r&lt;=页数10; 优化： select from ( select rownum r,t.*from (select s. from student s order by sno asc) t where rownum&lt;=页数*页面大小 ) where r&gt;=(页数-1)*页面大小+1 ; ​ dao和DBUtil的区别：dao 是处理特定 类的 数据库操作类：DBUtil是通用 数据库操作类 1分页要实现分页，必须知道 某一页的 数据 从哪里开始 到哪里结束 页面大小：每页显示的数据量 假设每页显示10条数据 mysql分页：mysql:从0开始计数0 0 91 10 192 20 29n n10 (n+1)10-1 结论：分页： 第n页的数据： 第(n-1)10+1条 – 第n10条 MYSQL实现分页的sql：limit 开始,多少条第0页select * from student limit 0,10 ;第1页select * from student limit 10,10 ;第2页select * from student limit 20,10 ;第n页select * from student limit n*10,10 mysql的分页语句： select * from student limit 页数*页面大小,页面大小 b.oracle分页： sqlserver/oracle:从1开始计数第n页 开始 结束1 1 102 11 203 21 30n (n-1)10+1 n10 select from student where sno &gt;=(n-1)10+1 and sno &lt;=n*10 ; –此种写法的前提：必须是Id连续 ，否则 无法满足每页显示10条数据 select rownum,t.from student t where rownum &gt;=(n-1)10+1 and rownum &lt;=n*10 order by sno;–1.如果根据sno排序则rownum会混乱（解决方案：分开使用-&gt;先只排序，再只查询rownum） 2.rownum不能查询&gt;的数据 select s.* from student s order by sno asc; select rownum, t.* from(select s.* from student s order by sno asc) twhere rownum &gt;=(n-1)10+1 and rownum &lt;=n10 ; ; //ORACLE\\sqlserver都是从1开始计数： (n-1)10+1 — n*10oracle的分页查询语句：select *from( select rownum r, t. from (select s.* from student s order by sno asc) t 10000)where r&gt;=(n-1)10+1 and &lt;=n10 ; 10 优化： select from( select rownum r, t. from (select s.* from student s order by sno asc) t where rownum&lt;=n10)where r&gt;=(n-1)10+1 ; select from( select rownum r, t. from (select s.* from student s order by sno asc) t where rownum&lt;=页数页面大小)where r&gt;=(页数-1)页面大小+1 ; SQLServer分页： 3种分页sqlrow_number() over(字段) ; sqlserver2003:top –此种分页SQL存在弊端（如果id值不连续，则不能保证每页数据量相等）select top 页面大小 * from student where id not in( select top (页数-1)*页面大小 id from student order by sno asc ) sqlserver2005之后支持：select from( select row_number() over (sno order by sno asc) as r, from student where r&lt;=n*10 )where r&gt;=(n-1)*10+1 and ; SQLServer此种分页sql与oralce分页sql的区别： 1.rownum ，row_number() 2.oracle需要排序（为了排序，单独写了一个子查询），但是在sqlserver 中可以省略该排序的子查询 因为sqlserver中可以通过over直接排序 sqlserver2012之后支持：offset fetch next only select * from student oreder by snooffset (页数-1)*页面大小+1 rows fetch next 页面大小 rows only ; (n-1)10+1 — n10 mysql从0开始计数，Oracle/sqlserver 从1开始计数 123468910 1112…20 2122..31 分页实现：5个变量（属性）1.数据总数 100 103 （查数据库,select count(*)..）2.页面大小（每页显示的数据条数）20 (用户自定义)3.总页数 （程序自动计算） 总页数 = 100/20 =数据总数/页面大小 总页数 = 103/20 = 数据总数/页面大小+1 —&gt; 总页数 = 数据总数%页面大小==0? 数据总数/页面大小:数据总数/页面大小+1 ; 4.当前页（页码） （用户自定义）5.当前页的对象集合（实体类集合）：每页所显示的所有数据 （10个人信息）List (查数据库,分页sql) 2表单重复提交 1.上传文件a.引入2个jar apache: commons-fileupload.jar组件 commons-fileupload.jar依赖 commons-io.jar b.代码：前台jsp： 表单提交方式必须为post 在表单中必须增加一个属性 entype=”multipart/form-data” 后台servlet： 注意的问题： 上传的目录 upload ： 1.如果修改代码，则在tomcat重新启动时 会被删除 原因：当修改代码的时候,tomcat会重新编译一份class 并且重新部署（重新创建各种目录） 2.如果不修改代码，则不会删除 原因： 没有修改代码，class仍然是之前的class因此，为了防止 上传目录丢失： a.虚拟路径 b.直接更换上传目录 到非tomcat目录 限制上传： 类型、 大小 注意 对文件的限制条件 写再parseRequest之前 2.下载：不需要依赖任何jar a.请求（地址a form），请求Servlet b.Servlet通过文件的地址 将文件转为输入流 读到Servlet中 c.通过输出流 将 刚才已经转为输入流的文件 输出给用户注意：下载文件 需要设置2个 响应头：response.addHeader(“content-Type”,”application/octet-stream” );//MIME类型:二进制文件（任意文件）response.addHeader(“content-Disposition”,”attachement;filename=”+fileName );//fileName包含了文件后缀：abc.txt 1.下载时 ，文件名乱码问题：edge： URLEncoder.encode(fileName,”UTF-8”) firefox：给文件名 加：前缀 =?UTF-8?B? String构造方法Base64.encode后缀 ?=示例： response.addHeader(“content-Disposition”,”attachment;filename==?UTF-8?B?”+ new String( Base64.encodeBase64(fileName.getBytes(“UTF-8”)) ) +”?=” );//fileName包含了文件后缀：abc.txt 2 EL ：为了消除jsp中的Java代码 语法：${EL表达式}a.EL不需要导包b.在el中调用属性，其实是调用的getXxx()方法 ${范围.对象.属性.属性的属性 } 操作符：操作：属性，不是对象. : 使用方便[] : 如果是常量属性，需要使用双引号/单引号 引起来;比点操作符更加强大 []强大之处：a.可以容纳一些 特殊符号 （. ? -）b.[]可以容纳 变量属性 （可以动态赋值）String x = “a”;${requestScope.a}等价于${requestScope[“a”]}等价于${${requestScope[x]} c.可以处理数组${requestScope.arr[0] } 普通对象、map中的变量 通过EL获取JSP 九大内置对象 ${pageContext }${pageContext.request }${pageContext.sessoin } JSTL：比EL更加强大需要引入2个jar ：jstl.jar standard.jar引入tablib :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core&quot; prefix=”c” %&gt;其中prefix=”c” :前缀 核心标签库： 通用标签库、条件标签库 迭代标签库 a.通用标签库&lt;c:set&gt;赋值i:在某个作用域之中（4个范围对象），给某个变量赋值 &lt;%– request.setAttribute(“name”, “zhangsan”) ; –%&gt; &lt;c:set var=”name” value=”zhangsan” scope=”request”/&gt; ${requestScope.name } &lt;c:set var=”变量名” value=”变量值” scope=”4个范围对象的作用域”/&gt; ii:给普通对象赋值在某个作用域之中（4个范围对象），给某个对象的属性复制 （此种写法，不能指定scope属性） &lt;c:set target=&quot;${requestScope.student}&quot; property=&quot;sname&quot; value=&quot;zxs&quot; /&gt;给map对象赋值 &lt;c:set target=”${requestScope.countries}” property=”cn” value=”中国” /&gt; &lt;c:set target=”对象” property=”对象的属性” value=”赋值” /&gt; 注意 &lt;c:set&gt;可以给不存在的变量赋值 （但不能给不存在的对象赋值） &lt;c:out&gt; ：显示true:&lt;c:out value=’百度‘ default=”当value为空的，显示的默认值” escapeXml=”true” /&gt;false： &lt;c:out value=’百度‘ escapeXml=”false” /&gt; &lt;c:remove &gt;：删除属性&lt;c:remove var=”a” scope=”request”/&gt; 选择：if(boolean)单重选择&lt;c:if test=”” &gt; if else if… esle if… else /switch &lt;c:choose&gt; &lt;c:when test=”…”&gt; &lt;c:when test=”…”&gt; &lt;c:when test=”…”&gt; &lt;c:otherwise&gt; 在使用 test=”” 一定要注意后面是否有空格例如：test=”${10&gt;2 }” true test=”${10&gt;2 } “ 非true 循环（迭代标签库）for(int i=0;i&lt;5;i++) &lt;c:forEach var=”name” items=”${requestScope.names }” &gt; -${name }- 可以在foreach便签中items属性作用域（requestScope）中保存的对象 1234&lt;!--for(String str:names)--&gt;&lt;c:forEach var=\"student\" items=\"$&#123;requestScope.students &#125;\" &gt; $&#123;student.sname &#125;-$&#123;student.sno &#125;&lt;/c:forEach&gt; 过滤器：实现一个Filter接口init()、destroy() 原理、执行时机 同Servlet配置过滤器，类似servlet通过doFilter()处理拦截，并且通过chain.doFilter(request, response);放行 filter映射 只拦截 访问MyServlet的请求 /MyServlet拦截一切请求（每一次访问 都会被拦截）/* 通配符 dispatcher请求方式：REQUEST：拦截HTTP请求 get postFORWARD：只拦截 通过 请求转发方式的请求 INCLUDE:只拦截拦截通过 request.getRequestDispatcher(“”).include() 、通过&lt;jsp:include page=”…” /&gt;此种方式发出的请求ERROR：只拦截发出的请求 过滤器中doFilter方法参数：ServletRequest在Servlet中的方法参数：HttpServletRequest 过滤器链可以配置多个过滤器，过滤器的先后顺序 是由 的位置 决定","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"javaSE","slug":"java-note/javaSE/javaSE","date":"2019-11-12T02:32:06.000Z","updated":"2019-11-12T02:35:44.689Z","comments":true,"path":"2019/11/java-note/javaSE/javaSE/","link":"","permalink":"https://codeofli.github.io/2019/11/java-note/javaSE/javaSE/","excerpt":"[TOC]java控制台执行可以直接编译＋运行1java Create.java字符串String特点String内容不可改变字符串常量就是String的匿名对象所谓的直接赋值实际上就是相当于将一个匿名对象设置了一个名字而已 String类的匿名对象是由系统自动设置，而不是有用户自己定义的String当做参数传递没有改变，是因为新的String通过赋值指向了新的对象，所以对传入的String没有影响","text":"[TOC]java控制台执行可以直接编译＋运行1java Create.java字符串String特点String内容不可改变字符串常量就是String的匿名对象所谓的直接赋值实际上就是相当于将一个匿名对象设置了一个名字而已 String类的匿名对象是由系统自动设置，而不是有用户自己定义的String当做参数传递没有改变，是因为新的String通过赋值指向了新的对象，所以对传入的String没有影响 修改类StringBuffer StringBuffer的内容可以修改 方法： public StringBuffer reverse() append insert delete 线程安全的，都是同步方法和String一样都实现了CharSequence接口StringBulid 是StringBuffer基本一样 线程不安全的 两种实例化方式直接赋值new构造方法 其内容不会保存在对象池中 使用new关键字，在堆上开辟一个内存 手动入池 public native String intern(); 容易找出空间浪费，不建议使用 常用类数字类大数类### 大整数类BigIntegerString构造方法 public BigInteger(String val) 大浮点数BigDecimal构造方法 String构造方法 double构造方法可实现准确的四舍五入操作 public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) 除以1实现四舍五入 divide(new BigDecimal(1),scale,BigDecimal.ROUND_HALF_UP) round(new MathContext(setPrecision, RoundingMode.HALF_UP)) MathContext构造方法默认四舍五入 setScale(newScale, RoundingMode.HALF_UP) 小数位后保留 Math类 Math类里面提供的方法都是static方法，Math类里面都没有普通方法四舍五入round public static long round(double a) 如果负数进行四舍五入时，大于-0.5才为-1 JDBC1、加载数据库驱动 E:\\app\\test\\product\\11.2.0\\dbhome_1\\jdbc\\lib\\ojdbc6.jar Oracle驱动类：oracle.jdbc.dirver.OracleDrive 连接oracle 驱动程序下载oracle自带有 加载驱动类class.forName(“oracle.jdbc.dirver.OracleDrive”)2、建立数据库连接 DriverManager.getConnection(url, user, password) 数据库链接地址（URL） oracle jdbc：oracle:连接方式：主机名称：端口号：数据库的SID（Security Identifier） 连接本机的mldn数据库： jdbc:oracle:thin:@localhost:1521:mldnjava之中所有的数据库操作类和接口在java.sql数据库驱动程序有数据库生成商提供JDBC在实现数据库驱动连接对象使用工厂设计设计模式，而DriverManager就是工厂类 所以客服端调用连接时，隐藏子类的具体连接实现 正则表达式Pattern类 获得此类对象必须通过Compile()方法，编译正则表达式Matcher类 Pattern类获得 字符串的正则运用​ matches()：正则验证​ replaceAll(String regex, String replacement):全部替换​ replaceFirst(String regex, String replacement)：替换首个​ split(String regex) ：全部拆分​ split(String regex, int limit)：部分拆分 正则标记都在Pattern类定义单个字符（匹配数量1） 字符：由一个字符组成 \\转移字符’&#39; ‘\\t’制表符 \\n换行符字符集（数量1） [abc]表示字符a、b和c中的任意一个（或的关系） [ ^abc]表示不是abc中任意一个（^非的关系） ​ [x-y] x的ascii到y的ascii码之间的值 ​ [a-z]所有小写字母（也可以[e-i])​ [a-zA-Z]任意字母​ [0-9]任意一位数字简化字符表达式（数量1）​ . :任意一位字符​ \\d： =[0-9]​ \\D : = [ ^0-9]​ \\s: 任意空白字符，如’\\t’,’\\n’​ \\S:任意非空白字符​ \\w : =[a-zA-Z_0-9]​ \\W : = [ ^a-zA-Z_0-9]边界表达式（不要在java中用，javaScript中用）​ ^:正则开始​ $:正则结束数量表达式​ 正则？：表示正则可以出现0次或1次 {0,1}​ 正则+：表示正则可以出现1次或1次以上 &gt;=1 {1,}​ 正则：表示正则可以出现0次或1次或多次 &gt;= 0 {0,}​ 正则{n}：表示正则正好出现n次​ 正则{n,}：表示正则出现n次及以上​ 正则{n,m}：表示正则出现{n,m}次逻辑表达式​ 正则1正则2：判断第一个完成以后再判断第二个正则​ 正则1|正则2：两个正则的或（正则）：*将多个正则作为一组**，可以为这一组单独设置次数注解 Annotation3个最常用的基础注解 声明覆写操作@Override 明确告诉编译器覆写，如果没有覆写成功则会报错 声明过期操作@desperated 压制警告@SupperssWarming 多线程实现 Thread实现 Runnable接口实现，能多继承 Thread类有Runnable的构造函数 Callable泛型接口实现，能有返回值 Thread类没有Callable的构造函数 FutureTask类负责接收call方法的返回值（接收Callable构造），实现RunnableFuture接口，RunnableFuture接口实现了Runnable接口、Future接口的get方法（负责接收返回值） 需要重写run方法，start开始 不用run方法是因为需要判断线程是否重复启动，并且需要不同操作系统提供start0的资源调配方法休眠Sleep（Thread） 几个线程一起休眠感觉是一起结束（时间长)，当是结束之后还是要抢占资源（时间短）,顺序是不固定的优先级 优先级越高，越有可能抢占到资源，越有可能执行同步synchronized 同步代码块 同步方法public synchronized 返回值等待wait(Object类） notify唤醒 对象克隆如果没有实现Cloneable的接口会上抛一个异常Cloneable接口 没有方法和全局常量 此为标识接口，表示一种能力需要覆写Object类的clone方法 protected native Object clone() throws CloneNotSupportedException; 反射“反”通过对象找到类的出处java.lang.Class反射的源头 三种实例化方式 第一种：调用Object类中的getClass() 需要对象实例化 第二种：类.class属性 不需要对象实例化，需要import Spring、Hibernate 第三种：Class提供的forName()方法 不需要import导入类，类用String描述 public static Class forName(String className) 反射对象实例化 Class类的无参构造方法：public T newInstance() new是耦合的主要元凶，当出现高耦合时大多数时能用反射降低 工厂模式 构造方法调用 最好保留无参构造方法，以便构造 取得指定构造方法 public Constructor getConstructor(Class… parameterTypes) public类型构造方法 public Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 所有构造方法 取得一些构造方法调用普通方法 共享设计模式​ 在JVM的底层实际上会存在有一个对象池（不一定只保存String），当String通过直接赋值创建一个String类对象时，会将此匿名对象如此保存，而后若果有新的String通过直接复制并且赋值内容和之前入池的相同，则不会开辟新的堆内存，而是使用之前对象池的引用。 4种代码块1、普通代码块 代码块写在了方法里面 改变变量作用域，能防止重名？（但是什么没有）2、构造块 代码写在了类里 构造块优先于构造块执行，每次构造执行一次（没什么用）3、静态代码块 非主类 主类 静态块在主方法前运行 为了静态变量的初始化，一个类只执行一次（也没什么用）4、同步代码块 多线程同步使用尽量不要使用代码块 [^a-zA-Z_0-9]:","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"}]},{"title":"jquery","slug":"js-note/jquery/jquery","date":"2019-11-12T02:25:41.000Z","updated":"2019-11-12T02:29:57.666Z","comments":true,"path":"2019/11/js-note/jquery/jquery/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/jquery/jquery/","excerpt":"[TOC]jQuery入口函数jQuery与JavaScript加载模式对比 多个window.onload只会执行一次, 后面的会覆盖前面的 12345678&lt;script&gt; window.onload = function () &#123; alert(\"hello lnj1\"); // 不会显示 &#125; window.onload = function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;&lt;/script&gt;","text":"[TOC]jQuery入口函数jQuery与JavaScript加载模式对比 多个window.onload只会执行一次, 后面的会覆盖前面的 12345678&lt;script&gt; window.onload = function () &#123; alert(\"hello lnj1\"); // 不会显示 &#125; window.onload = function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;&lt;/script&gt; 多个$(document).ready()会执行多次,后面的不会覆盖前面的 12345678&lt;script&gt; $(document).ready(function () &#123; alert(\"hello lnj1\"); //会显示 &#125;); $(document).ready(function () &#123; alert(\"hello lnj2\"); // 会显示 &#125;);&lt;/script&gt; 不会覆盖的本质(了解,后面jQuery原理会详细讲解) jQuery框架本质是一个闭包,每次执行我们都会给ready函数传递一个新的函数,不同函数内部的数据不会相互干扰 1234567891011121314151617181920212223242526&lt;script&gt; // 相当于这样写 var test1 = function () &#123; alert(\"hello lnj1\"); &#125; var test2 = function () &#123; alert(\"hello lnj2\"); &#125; $(document).ready(test1); $(document).ready(test2);&lt;/script&gt;&lt;script&gt; var test3 = function () &#123; var abc = \"123\";// 因为在同一个函数中,所以456覆盖123// var abc = \"456\"; alert(abc); &#125; test3(); var test4 = function () &#123; // 因为在不同函数中,所以不会影响 var abc = \"456\"; alert(abc); &#125; test4();&lt;/script&gt; window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); 为什么我们能访问$符号? 因为$符号jQuery框架对外暴露的一个全局变量 JavaScript中如何定义一个全局变量? 所有全局变量是 window 对象的属性 1234567891011 function test () &#123; var customValue = 998; alert(customValue);// 1.没有如下代码customValue就不是一个全局变量,函数执行完毕之后// customValue会被自动释放,test函数以外的地方访问不到customValue// 2.加上如下代码之后customValue就会变成一个全局变量,函数执行完毕也不// 会被释放,test函数以外的地方可以访问customValue// window.customValue = customValue; &#125; test(); alert(customValue); 所以jQuery框架源码实现 1window.jQuery = window.$ = jQuery; 所以想要使用jQuery框架只有两种方式,一种是通过$,一种是通过jQuery jQuery入口函数的其它编写方式如下 123456789101112131415161718&lt;script&gt; // 方式一 $(document).ready(function () &#123; alert(\"hello lnj\"); &#125;); // 方式二 $(function () &#123; alert(\"hello lnj\"); &#125;); // 方式三 jQuery(document).ready(function () &#123; alert(\"hello lnj\"); &#125;); // 方式四 jQuery(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 解决$符号冲突问题 为什么是window.jQuery = window.$ = jQuery;,而不是window.jQuery = jQuery; jQuery框架之所以提供了jQuery访问还提供$访问,就是为了提升开发者的编码效率 $符号冲突怎么办? 很多js的框架都提供了类似jQuery这样的便捷访问方式,所以很有可能某一天我们在使用多个框架的时,多个框架作者提供的便捷访问方式冲突(A框架通过$访问,B框架也通过$访问) ***释放$使用权 当便捷访问符号发生冲突时,我们可以释放$使用权, 释放之后只能使用jQuery 12345678&lt;script&gt; // 在使用jQuery之前指定自定义符号 jQuery.noConflict(); // 使用 jQuery jQuery(\"div p\").hide(); // 使用其他库的 $() $(\"content\").style.display = 'none';&lt;/script&gt; 自定义便捷访问符号 当便捷访问符号发生冲突时,我们可以自定义便捷访问符号 12345678&lt;script&gt; // 在使用jQuery之前指定自定义符号 var nj = jQuery.noConflict(); // 和使用$一样通过自定义符号调用jQuery nj(function () &#123; alert(\"hello lnj\"); &#125;);&lt;/script&gt; 核心函数和静态方法jQuery核心函数 从jQuery文档中可以看出,jQuery核心函数一共3大类4小类 jQuery(callback) 当DOM加载完成后执行传入的回调函数 12345&lt;script&gt; $(function () &#123; alert(\"123\"); &#125;);&lt;/script&gt; jQuery([sel,[context]]) 接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象 1234567891011&lt;script&gt; $(function () &#123; // 利用jquery获取所有div,得到的是一个jQuery对象 var $box = $(\"div\"); console.log($box); // 利用js原生语法获取所有div,得到的是一个js对象 var box = document.getElementsByTagName(\"div\"); console.log(box); &#125;);&lt;/script&gt; 原生JS对象和jQuery对象相互转换 1234567891011121314151617181920212223&lt;script&gt; $(function () &#123; var $box = $(\"#box\");// $box.text(\"新的数据\");// jQuery对象不能使用原生js对象的方法// $box.innerText = \"新的数据\";// 将jQuery对象转换为原生js对象// 注意: 不是eq(0),eq函数返回的是jQuery类型对象,get函数返回的是原生类型对象// var box = $box.get(0); var box = $box[0]; box.innerText = \"新的数据\"; var box2 = document.getElementById(\"box\");// 原生js对象不能使用jQuery对象的方法// box2.text(\"新的数据2\");// 原生js对象只能使用原生的js方法// box2.innerText = \"新的数据2\";// 将原生js对象转换为jQuery对象 var $box2 = $(box); $box2.text(\"新的数据2\"); &#125;);&lt;/script&gt; Tips:为了方便开发者之间沟通和阅读,一般情况下所有jQuery操作相关的变量前面加上$ jQuery(html,[ownerDoc]) 根据 HTML 标记字符串，动态创建DOM 元素 123456789&lt;script&gt; $(function () &#123; var $eles = $(\"&lt;p&gt;我是span&lt;/p&gt;&lt;u&gt;我是u&lt;/u&gt;\"); // 无论是jQuery找到的还是创建的,我们最终拿到的永远都是jQuery对象 console.log($eles); // 将创建好的DOM元素添加到body中 $(\"body\").append($eles); &#125;);&lt;/script&gt; jQuery对象 jQuery对象的本质是什么? jQuery对象的本质是一个伪数组 12345var $div = $(\"div\");console.log($div);var arr = [1, 3, 5];console.log(arr); 什么是伪数组? 有0到length-1的属性 并且有length属性 1var obj = &#123;0:\"lnj\", 1:\"33\", 2:\"male\", length: 3&#125; jQuery静态方法 什么是静态方法? 静态方法对应的是对象方法,对象方法用实例对象调用,而静态方法用类名调用 1234567891011121314151617 &lt;script&gt; window.onload = function () &#123; function AClass()&#123;&#125; AClass.staticMethof = function()&#123; alert('静态方法'); &#125; AClass.prototype.instaceMethod = function()&#123; alert('实例方法'); &#125; //静态方法用类名直接调用 AClass.staticMethof(); //实例方法必须用类的实例对象调用 var instace = new AClass(); instace.instaceMethod(); &#125;&lt;/script&gt; jQuery.holdReady(hold) 暂停或者恢复jQuery.ready()事件 传入true或false 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;04-jQuery静态方法&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; // 使用$直接调用,是静态方法 $.holdReady(true); $(function () &#123; $(\"#first\").click(function () &#123; alert(\"我是你想要的弹窗\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"first\"&gt;点击测试弹出&lt;/button&gt;&lt;button id=\"second\"&gt;解除延迟&lt;/button&gt;&lt;script&gt; $(\"#second\").click(function()&#123; $.holdReady(false); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.each(object,[callback]) 遍历对象或数组 优点统一遍历对象和数组的方式 回调参数的顺序更符合我们的思维模式 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; $(function () &#123; // 3.1遍历数组 var arr = [1, 3, 5, 7, 9]; // 3.1.1通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 没有返回值 var res = arr.forEach(function (ele, idx) &#123; console.log(idx, ele); &#125;); console.log(res); // 3.1.2通过jQuery静态方法遍历数组 // 第一个回调函数参数是当前遍历的索引 // 第二个回调函数参数是遍历到的元素 // 返回值: 被遍历的数组 var $res2 = $.each(arr, function (idx, ele) &#123; console.log(idx, ele); &#125;); console.log($res2); // 3.2遍历对象 var obj = &#123;name: \"lnj\", age:\"33\", gender:\"male\"&#125;; // 3.2.1js对象没有forEach方法,所以通过forin方法遍历对象 for(var key in obj)&#123; console.log(key, obj[key]); &#125; // 3.2.2通过jQuery静态方法遍历对象 $.each(obj,function (key, value) &#123; console.log(key, value); &#125;); &#125;); &lt;/script&gt; $.map(arr|obj,callback) 遍历对象或数组,将回调函数的返回值组成一个新的数组返回 1234567891011121314151617181920212223242526272829303132333435363738$(function () &#123; // 4.1遍历数组 var arr = [1, 3, 5, 7, 9]; // 4.1.1通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 第三个回调函数参数是当前被遍历的数组 // 返回值: 将回调函数返回值收集起来组成一个新的数组 var res = arr.map(function (ele, idx, arr) &#123; console.log(idx, ele, arr); return ele + idx; &#125;); console.log(res); // 4.1.2通过jQuery静态方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 将回调函数返回值收集起来组成一个新的数组 var $res2 = $.map(arr, function (ele,idx) &#123; console.log(idx, ele); return ele + idx; &#125;); console.log($res2); // 4.2遍历对象 var obj = &#123;name: \"lnj\", age:\"33\", gender:\"male\"&#125;; /* obj.map(function (ele, idx, obj) &#123; // 报错,原生JS没有map方法 console.log(idx, ele, obj); &#125;); */ var $res = $.map(obj, function (value, key) &#123; console.log(key, value); return key + value; &#125;); console.log($res);&#125;); $.trim(str) 去掉字符串起始和结尾的空格。 12345678&lt;script&gt; $(function () &#123; var str = \" lnj \"; console.log(\"---\"+str+\"---\"); var $res = $.trim(str); console.log(\"---\"+$res+\"---\"); &#125;);&lt;/script&gt; $.isArray(obj) 判断是否是数组 123456789101112&lt;script&gt; $(function () &#123; // 对象 var obj = &#123;name:\"lnj\",age: \"33\", gender:\"male\"&#125;; // 真数组 var arr = [1, 3, 5, 7, 9]; var $res = $.isArray(obj); console.log($res);// false var $res2 = $.isArray(arr); console.log($res2);// true &#125;);&lt;/script&gt; $.isFunction(obj) 判断是否是函数 jQuery框架本质是一个匿名函数 12345678910111213141516171819&lt;script&gt; $(function () &#123; var obj = &#123;name:\"lnj\",age: \"33\", gender:\"male\"&#125;; var arr = [1, 3, 5, 7, 9]; var fn = function () &#123;&#125; var $res = $.isFunction(obj); console.log($res);// false $res = $.isFunction(arr); console.log($res); $res = $.isFunction(fn); console.log($res); // 通过该方法验证了我们前面所说的,jQuery框架本质是一个匿名函数 (function(window,undefined)&#123; xxxx.... &#125;)(window); $res = $.isFunction($); console.log($res); &#125;);&lt;/script&gt; $.isWindow(obj) 判断是否是window对象 12345678910111213&lt;script&gt; $(function () &#123; var obj = window; var arr = [1, 3, 5, 7, 9]; var arrlike = &#123;0:\"zs\", 1:\"ls\", length:2&#125;; var $res = $.isWindow(obj); console.log($res); // true $res = $.isWindow(arr); console.log($res); // false $res = $.isWindow(arrlike); console.log($res); // false &#125;);&lt;/script&gt; 为什么要讲解以上极度简单的工具方法? 江哥提示: 这是为后面放大招做铺垫,一定要认真记住以上方法哦 基础选择器 视频参考第十章-CSS选择器 选择器 名称 描述 返回 示例 #id id选择器 根据给定的id匹配一个元素 单个元素 $(“#box”);选取id为box元素 .class 类选择器 根据给定的类名匹配元素 集合元素 $(“.box”);选取所有类名为box元素 element 元素选择器 根据给定的元素名称匹配元素 集合元素 $(“p”);选取所有元素 * 通配符选择器 匹配所有元素 集合元素 $(“*”);选取所有元素 selector1,selector2,selectorN 并集选择器 将所有选择器匹配到的元素合并后一起返回 集合元素 $(“div,p,.box”);选取所有元素,所有元素和所有类名为box元素 ##层次选择器 视频参考第十章-CSS选择器 选择器 名称 描述 返回 示例 $(“ancestor descendant”) 后代选择器 选取ancestor元素的所有descendant后代标签(不光是儿子,包括孙子/重孙子等) 集合元素 $(“div span”);选取元素里所有的元素 $(“parent &gt; child”) 子元素选择器 找到选取parent 元素中所有直接子元素child(只有儿子,不包括孙子/重孙子等) 集合元素 $(“div&gt;span”);选取元素下元素名称是的子元素 $(“prev + next”) 相邻兄弟选择器 选取prev元素后面紧跟的那个next元素 集合元素 $(“.one+div”);选取类名为one的下一个同级的元素 $(“prev ~ siblings”) 通用兄弟选择器 选取prev元素后面的所有next元素 集合元素 $(“#two~div”);选取id名为two元素后面所有同级的元素 序选择器 视频参考第十章-CSS选择器 如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可 做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背 属性选择器 视频参考第十章-CSS选择器 如上内容不再一一赘述,观看第十章-CSS选择器,使用时查询文档即可 做开发是脑力活,我们需要掌握的是解决问题的方法,而不是死记硬背 内容过滤选择器 选择器 描述 返回 :empty 选取不包含子元素或文本为空的元素 集合元素 :parent 选取含有子元素或文本的元素 集合元素 :contains(text) 选取含有文本内容为text的元素 集合元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 :empty 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中不包含文本内容或子元素的元素 var $res = $(\"div:empty\"); console.log($res.length); // 找到1个元素 $res.each(function (idx,ele) &#123; console.log(idx, ele); // one &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;!--包含内容不会被找到--&gt;&lt;div class=\"three\"&gt;&lt;!--包含子元素不会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;!--不是指定元素不会被找到--&gt;&lt;/body&gt;&lt;/html&gt; :parent 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含文本内容或子元素的元素 var $res = $(\"div:parent\"); console.log($res.length); $res.each(function (idx, ele) &#123; console.log(idx, ele); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;!--有文本内容会被找到--&gt;&lt;div class=\"three\"&gt;&lt;!--有子元素会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; :contains(text) 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含文本内容为lnj的元素 var $res = $(\"div:contains('lnj')\"); console.log($res.length);// 找到2个元素 $res.each(function (idx, ele) &#123; console.log(idx, ele);// one,three,four &#125;) &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt;lnj&lt;/div&gt;&lt;div class=\"two\"&gt;zs&lt;/div&gt;&lt;div class=\"three\"&gt;lnj&lt;/div&gt;&lt;div class=\"four\"&gt;&lt;!--子元素中包含该文本也会被找到--&gt; &lt;span&gt;lnj&lt;/span&gt;&lt;/div&gt;&lt;span class=\"five\"&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; :has(selector) 和:parent区别,parent只要有子元素就会被找到,:has(selector)不仅要有子元素,而且子元素还必须满足我们的条件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;05-jQuery选择器&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; // 找到所有div中包含后代元素为span的元素 var $res = $(\"div:has('span')\"); console.log($res.length); $res.each(function (idx, ele) &#123; console.log(idx, ele); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"one\"&gt; &lt;!--后代中包含span元素会被找到--&gt; &lt;span&gt;jjj&lt;/span&gt;&lt;/div&gt;&lt;div class=\"two\"&gt;&lt;!--后代中不包含span元素不会被找到--&gt; &lt;p&gt;zs&lt;/p&gt;&lt;/div&gt;&lt;div class=\"three\"&gt;&lt;!--后代中包含span元素会被找到--&gt; &lt;p&gt; &lt;span&gt;lnj&lt;/span&gt; &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 属性相关##属性和属性节点 什么是属性? 属性就是对象身上的变量 只要对象身上都可以添加属性(无论是自定义对象,还是DOM对象) 123456789&lt;script&gt; // 1.自定义一个对象 var obj = &#123;&#125;; console.log(obj); // 2.动态给自定义对象添加属性 obj.name = \"lnj\"; // name就是对象obj的一个属性 obj.age = 33; // age就是对象obj的一个属性 console.log(obj);&lt;/script&gt; image.png 什么是属性节点? 在html中编写的所有标签，里面的属性都是属性节点 &lt;span class = &#39;box&#39; nj = &#39;666&#39;&gt;&lt;/span&gt; // 这里的class和nj就是属性节点 image.png 如果操作属性? 添加或修改属性(没有就会添加,有就会修改) 对象.属性名称 = 值; 对象[&quot;属性名称&quot;] = 值; 获取属性 对象.属性名称 对象[&quot;属性名称&quot;] 如何操作属性节点? 获取属性节点 DOM对象.getAttribute(&quot;属性节点名称&quot;) 设置属性节点 DOM对象.setAttribute(&quot;属性节点名称&quot;, &quot;值&quot;); jQuery中的attr和prop方法 attr(name|pro|key,val|fn)方法 用于设置或获取属性节点的值 12345678910111213141516&lt;script&gt; $(function () &#123; // 1.获取指定属性节点值 var $res = $(\".span1\").attr(\"nj\"); console.log($res); // 2.设置属性节点 $(\".span1\").attr(\"nj\", \"666\"); $(\".span2\").attr(\"id\", \"box1 box2\"); // 3.注意点: // 3.1.获取属性节点时,只会获取找到所有元素中第一个元素的属性节点 $res = $(\"span\").attr(\"class\"); console.log($res); $(\"span\").attr(\"class\", \"lnj\"); &#125;);&lt;/script&gt; removeAttr(name)方法 用于删除指定属性节点 12345678&lt;script&gt; $(function () &#123; // 1.设置属性节点时,会给所有找到元素设置属性节点 $(\"span\").attr(\"test\", \"jonathan\"); // 2.删除属性节点时,会删除所有找到元素的属性节点 $(\"span\").removeAttr(\"test\"); &#125;);&lt;/script&gt; prop(n|p|k,v|f)方法 用于设置或者获取元素的属性值 12345678910&lt;script&gt; $(function () &#123; // 1.设置属性 // 1.1.设置属性时,会设置所有找到元素的属性 $(\"span\").prop(\"demo\", \"lnj\"); // 2.获取属性 // 2.1.获取属性时,只会获取找到第一个元素的属性 console.log($(\"span\").prop(\"demo\")); &#125;);&lt;/script&gt; removeProp(name)方法 123456&lt;script&gt; $(function () &#123; // 删除所有找到元素的demo属性 $(\"span\").removeProp(\"demo\"); &#125;);&lt;/script&gt; attr方法和prop方法区别 既然所有的DOM对象，都有一个attributes属性,而prop可以操作属性,所以也可以操作属性节点 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() 因为如果具有 true 和 false 两个属性的属性节点,如果没有编写默认attr返回undefined,而prop返回false 12345678910111213141516171819&lt;script&gt; $(function () &#123; // 1.可以通过prop获取属性节点 console.log($(\"input\").prop(\"class\")); // 2.可以通过prop设置属性节点 $(\"input\").prop(\"class\", \"tag\"); // 3.如果没有默认值,那么attr获取返回undefined// console.log($(\"input[type=checkbox]\").attr(\"checked\")); // 4.如果没有默认值,那么prop获取返回false console.log($(\"input[type=checkbox]\").prop(\"checked\")); // 5.通过attr设置选中// $(\"input[type=checkbox]\").attr(\"checked\", true); // 6.通过prop设置选中 $(\"input[type=checkbox]\").prop(\"checked\", true) &#125;);&lt;/script&gt; jQuery增删Class jQuery CSS类相关方法都是用于操作DOM对象的class属性节点的值 addClass(class|fn) 给元素添加一个或多个类 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;08-jQueryCSS类&lt;/title&gt; &lt;style&gt; .class1&#123; width: 200px; height: 200px; background-color: red; &#125; .class2&#123; border: 5px solid #000; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.添加一个类// $(\"div\").addClass(\"class1\"); // 2.再添加一个类// $(\"div\").addClass(\"class2\"); // 3.一次性添加多个类(用空格隔开) $(\"div\").addClass(\"class1 class2\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加&lt;/button&gt;&lt;button&gt;删除&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; removeClass([class|fn]) 删除元素的一个或多个类 12345678910111213&lt;script&gt; $(function () &#123; $(\"button\").eq(1).click(function () &#123; // 4.删除一个类// $(\"div\").removeClass(\"class2\"); // 5.再删除一个类// $(\"div\").removeClass(\"class1\"); // 6.一次性删除多个类(用空格隔开) $(\"div\").removeClass(\"class1 class2\"); &#125;); &#125;);&lt;/script&gt; toggleClass(class|fn[,sw]) 添加或删除一个类(存在就删除不存在就添加) 12345678910&lt;script&gt; $(function () &#123; $(\"button\").eq(2).click(function () &#123; // 7.切换一个类// $(\"div\").toggleClass(\"class2\"); // 8.切换多个类 $(\"div\").toggleClass(\"class1 class2\"); &#125;); &#125;); &lt;/script&gt; jQuery代码/文本/值 html([val|fn]) 添加或获取元素中的HTML 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;09-jQuery代码文本值&lt;/title&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; var $btns = $(\"button\"); var $div = $(\"div\"); $btns.eq(0).click(function () &#123; // 1.添加html, 相当于innerHTML// $div.html(\"&lt;p&gt;我是p标签&lt;/p&gt;\");// $div.html(\"&lt;p&gt;&lt;span&gt;我是span标签&lt;/span&gt;&lt;/p&gt;\"); $div.html(\"我是文本\"); &#125;); $btns.eq(1).click(function () &#123; // 2.获取html console.log($div.html()); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;添加html&lt;/button&gt;&lt;button&gt;获取html&lt;/button&gt;&lt;button&gt;添加文本&lt;/button&gt;&lt;button&gt;获取文本&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; text([val|fn]) 添加或获取元素中的文本 text方法能做的html方法都能做,所以一般使用html方法即可 12345678910111213&lt;script&gt; $(function () &#123; $btns.eq(2).click(function () &#123; // 3.添加文本, 相当于innerText // 如下内容不会被转换为标签// $div.text('&lt;p&gt;我是段落&lt;/p&gt;'); $div.text('我是文本'); &#125;); $btns.eq(3).click(function () &#123; // 4.获取文本 console.log($div.text()); &#125;);&lt;/script&gt; val([val|fn|arr]) 添加或获取元素value属性的值 123456789101112&lt;script&gt; $(function () &#123; $btns.eq(4).click(function () &#123; // 4.添加value值 $(\"input\").val(\"我是一个输入框\"); &#125;); $btns.eq(5).click(function () &#123; // 4.获取value值 console.log($(\"input\").val()); &#125;); &#125;);&lt;/script&gt; CSS操作jQuery操作CSS样式 css(name|pro|[,val|fn])方法 用于设置或获取元素CSS样式 格式1:DOM元素.css(&quot;样式名称&quot;, &quot;值&quot;); 格式2:DOM元素.css({&quot;样式名称1&quot;:&quot;值1&quot;,&quot;样式名称2&quot;:&quot;值2&quot;}); 1234567891011121314151617181920212223 &lt;script&gt; $(function () &#123; $(\"button\").click(function () &#123; // 1.单个样式设置// $(\"div\").css(\"width\", \"100px\");// $(\"div\").css(\"height\", \"100px\");// $(\"div\").css(\"background\", \"red\"); // 2.链式设置样式// $(\"div\").css(\"width\", \"100px\").css(\"height\", \"100px\").css(\"background\", \"red\"); // 3.传入对象一次性设置样式 $(\"div\").css(&#123; \"width\":\"100px\", \"height\":\"100px\", \"background\":\"blue\" &#125;); // 4.获取指定样式的值 console.log($(\"div\").css(\"width\")); &#125;); &#125;); &lt;/script&gt; jQuery操作元素尺寸 width([val|fn])方法 设置或获取元素宽度(相当于获取width属性值) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;11-jQuery操作位置和尺寸&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .father&#123; width: 250px; height: 250px; background-color: red; margin-left: 50px; position: relative; &#125; .son&#123; width: 100px; height: 100px; background-color: blue; position: absolute; left: 50px; top: 50px; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取元素宽度(不包括padding和border)// alert($('.son').width()); &#125;); $(\"button\").eq(1).click(function () &#123; // 2.设置元素宽度(不包括padding和border)// $(\".son\").width(\"50px\"); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; height([val|fn])方法 设置或获取元素宽度(相当于获取height属性值) 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) innerHeight()/innerWidth() 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) outerHeight/outerWidth() 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) jQuery操作元素位置 offset([coordinates]) 获取或设置元素相对窗口的偏移位 123456789101112&lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取距离窗口的偏移位(从border开始) alert($('.son').offset().left); // 100 &#125;); $(\"button\").eq(1).click(function () &#123; // 2.设置距离窗口的偏移位 $('.son').offset(&#123;left:10, top:10&#125;); &#125;); &#125;);&lt;/script&gt; position() 获取相对于它最近的具有相对位置(position:relative或position:absolute)的父级元素的距离 123456789101112&lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 1.获取匹配元素相对父元素的偏移 alert($('.son').position().left);// 50 &#125;); $(\"button\").eq(1).click(function () &#123; // 2.无效,不能设置相对定位元素的偏移位 $('.son').position(&#123;left:10, top:10&#125;) &#125;); &#125;);&lt;/script&gt; scrollTop([val]) 设置或获取匹配元素相对滚动条顶部的偏移。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;12-jQuery操作位置&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .scroll&#123; margin-top: 100px; margin-left: 100px; width: 100px; height: 200px; border: 1px solid #000; overflow: auto; &#125; &lt;/style&gt; &lt;script src=\"代码/js/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(\"button\").eq(0).click(function () &#123; // 7.获取匹配元素相对滚动条顶部的偏移// alert($('.scroll').scrollTop());// alert($('html').scrollTop()); // 兼容所有浏览器写法 alert($('html').scrollTop()+$('body').scrollTop()); &#125;); $(\"button\").eq(1).click(function () &#123; // 8.设置匹配元素相对滚动条顶部的偏移// $('.scroll').scrollTop(100);// $('html').scrollTop(100); // 兼容所有浏览器写法 $('html,body').scrollTop(100); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"scroll\"&gt; 我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字我是文字&lt;/div&gt;&lt;button&gt;获取&lt;/button&gt;&lt;button&gt;设置&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt; scrollLeft([val]) 用上面按钮代码自己写,工作后都得靠自己,多锻炼自学能力(如何查看文档,如何编写测试案例等) otherjquery中val()和value区分1.jQuery中的val()方法用来获取或设定输入框或选择框的值。 获取值：$(“##text”).val() 设置值：$(“##text”).val(“value”) 也可以来获取或设置select标签的值 select1 select2 获取值：$(“##select”).val() 设置值：$(“##select”).val(“select1”) 2.jQuery中没有value方法，可以通过attr方法获取或设置标签中的value属性的值","categories":[{"name":"note-js","slug":"note-js","permalink":"https://codeofli.github.io/categories/note-js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"}]},{"title":"javaScript","slug":"js-note/javaScript/javaScript","date":"2019-11-12T02:18:21.000Z","updated":"2019-11-12T02:25:01.213Z","comments":true,"path":"2019/11/js-note/javaScript/javaScript/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/javaScript/javaScript/","excerpt":"[TOC]localStorage只读的localStorage 属性允许你访问一个Document 源（origin）的对象 Storage；其存储的数据能在跨浏览器会话保留。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。","text":"[TOC]localStorage只读的localStorage 属性允许你访问一个Document 源（origin）的对象 Storage；其存储的数据能在跨浏览器会话保留。localStorage 类似 sessionStorage，但其区别在于：存储在 localStorage 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除 。 JavaScriptJavaScript负责页面中的的行为。 它是一门运行在浏览器端的脚本语言。 JS的编写的位置1.可以编写到标签的指定属性中 12&lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt;&lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt; 2.可以编写到script标签中 123&lt;script type=\"text/javascript\"&gt;//编写js代码&lt;/script&gt; 3.可以将代码编写到外部的js文件中，然后通过标签将其引入 script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的script标签用于编写内部代码 1&lt;script type=\"text/javascript\" src=\"文件路径\"&gt;&lt;/script&gt; 输出语句 `alert(“要输出的内容”); 该语句会在浏览器窗口中弹出一个警告框 `document.write(“要输出的内容”); 该内容将会被写到body标签中，并在页面中显示 `console.log(“要输出的内容”); 该内容会被写到开发者工具的控制台中 基本的语法js函数声明不需要；分号，但是赋值语句要加；分号 123456function functionName(arg0,arg1,arg2)&#123;//函数声明&#125;var functionName=function(arg0,arg1,arg2)&#123;//函数表达式&#125;;(注意分号) 注释 单行注释//注释内容 多行注释/*注释内容*/ JS严格区分大小写 JS中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写 JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。 字面量和变量字面量字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN “hello”字面量都是不可以改变的。 由于字面量不是很方便使用，所以在JS中很少直接使用字面量 变量变量可以用来保存字面量，并且可以保存任意的字面量 一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述 声明变量 使用var关键字来声明一个变量var a;var b;var c; 为变量赋值a = 1;b = 2;c = 3; 声明和赋值同时进行 *****var d = 456;var e = 789; 标识符 在JS中所有的可以自主命名的内容，都可以认为是一个标识符，是标识符就应该遵守标识符的规范。 比如：变量名、函数名、属性名 规范：1.标识符中可以含有字母、数字、_、$2.标识符不能以数字开头3.标识符不能是JS中的关键字和保留字4.标识符一般采用驼峰命名法xxxYyyZzz 数据类型 JS中一共分成六种数据类型 基本数据类型+object String 字符串 Number 数值 Boolean 布尔值 Null 空值 Undefined 未定义 Object 对象 其中基本数据类型有 5个 1.String 字符串JS中的字符串需要使用引号引起来双引号或单引号都行 在字符串中使用\\作为转义字符&#39; ==&gt; ‘&quot; ==&gt; “\\n ==&gt; 换行\\t ==&gt; 制表符\\ ==&gt; \\ 使用typeof运算符检查字符串时，会返回”string” 2.Number 数值 JS中所有的整数和浮点数都是Number类型 最大能表示的值：Number.MAX_VALUE= 1.7976931348623157e+308 特殊的数字：能赋值给变量 Infinity 正无穷 a = Infinity ,能赋值 -Infinity 负无穷 NaN 非法数字（Not A Number） 其他进制的数字的表示：0b 开头表示二进制，但是不是所有的浏览器都支持0 开头表示八进制0x 开头表示十六进制 使用typeof检查一个Number类型的数据时，会返回”number”（包括NaN 和 Infinity） 3.Boolean 布尔值 布尔值主要用来进行逻辑判断，布尔值只有两个 true 逻辑的真 false 逻辑的假 使用typeof检查一个布尔值时，会返回”boolean” 4.Null 空值 空值专门用来表示为空的对象，Null类型的值只有一个 null 使用typeof检查一个Null类型的值时会返回”object” 5.Undefined 未定义 如果声明一个变量但是没有为变量赋值此时变量的值就是undefined 该类型的值只有一个 undefined 使用typeof检查一个Undefined类型的值时，会返回”undefined” 引用数据类型 Object 对象 类型转换 类型转换就是指将其他的数据类型，转换为String Number 或 Boolean 转换为String 方式一（强制类型转换）： 调用被转换数据的toString()方法 例子：var a = 123;a = a.toString(); 注意：这个方法不适用于null和undefined由于这两个类型的数据中没有方法，所以调用toString()时会报错 方式二（强制类型转换）： 调用String()函数 例子：var a = 123;a = String(a); 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined” 方式三（隐式的类型转换）: *** **为任意的数据类型 +”” 例子：var a = true;a = a + “”; 原理：和String()函数一样 转换为Number 方式一（强制类型转换）： 调用Number()函数 例子：var s = “123”;s = Number(s); 转换的情况：1.字符串 &gt; 数字 如果字符串是一个合法的数字，则直接转换为对应的数字 如果字符串是一个非法的数字，则转换为NaN 如果是一个空串或纯空格的字符串，则转换为02.布尔值 &gt; 数字 true转换为1 false转换为03.空值 &gt; 数字 null转换为04.未定义 &gt; 数字 undefined 转换为NaN 方式二（强制类型转换）： 调用parseInt()或parseFloat() 这两个函数专门用来将一个字符串转换为数字的 如果对非String使用parseInt()或parseFloat()，它会先将其转换为String然后在操作 parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number 例子： var a = “123.456px”; a = parseInt(a); //123 如果需要可以在parseInt()中指定一个第二个参数，来指定进制 parseFloat() 可以将一个字符串中的有效的小数位提取出来，并转换为Number 例子： var a = “123.456px”; a = parseFloat(a); //123.456 方式三（隐式的类型转换）： 使用一元的+来进行隐式的类型转换 例子：var a = “123”;a = +a; 原理：和Number()函数一样 转换为布尔值 方式一（强制类型转换）： 使用Boolean()函数 例子：var s = “false”;s = Boolean(s); //true 转换的情况字符串 &gt; 布尔 除了空串其余全是true 数值 &gt; 布尔 除了0和NaN其余的全是true null、undefined &gt; 布尔 都是false 对象 &gt; 布尔 都是true 方式二（隐式类型转换）： 为任意的数据类型做两次非运算，即可将其转换为布尔值 例子：var a = “hello”;a = !!a; //true 运算符 运算符也称为操作符 通过运算符可以对一个或多个值进行运算或操作 typeof运算符 用来检查一个变量的数据类型 语法：typeof 变量 它会返回一个用于描述类型的字符串作为结果 运算符算数运算符+对两个值进行加法运算并返回结果-对两个值进行减法运算并返回结果 *对两个值进行乘法运算并返回结果/ 对两个值进行除法运算并返回结果% 对两个值进行取余运算并返回结果 除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。 而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。 任何值和字符串做加法，都会先转换为字符串，然后再拼串 一元运算符 一元运算符只需要一个操作数 一元的+ 就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字 例子：var a = true;a = +a; 一元的 就是负号，可以对一个数字进行符号位取反 例子：var a = 10;a = a; 自增 自增可以使变量在原值的基础上自增1 自增使用 ++ 自增可以使用 前++（++a）后++(a++) 无论是++a 还是 a++都会立即使原变量自增1不同的是++a和a++的值是不同的， ++a的值是变量的新值（自增后的值） a++的值是变量的原值（自增前的值） 自减 自减可以使变量在原值的基础上自减1 自减使用 自减可以使用 前（a）后(a) 无论是a 还是 a都会立即使原变量自减1不同的是a和a的值是不同的， a的值是变量的新值（自减后的值） a的值是变量的原值（自减前的值） 逻辑运算符! 非运算可以对一个布尔值进行取反，true变false false边true 当对非布尔值使用!时，会先将其转换为布尔值然后再取反 我们可以利用!来将其他的数据类型转换为布尔值 &amp;&amp; &amp;&amp;可以对符号两侧的值进行与运算 只有两端的值都为true时，才会返回true。只要有一个false就会返回false。 与是一个短路的与，如果第一个值是false，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为false，则返回第一个值 2.如果第一个值为true，则返回第二个值 || ||可以对符号两侧的值进行或运算 只有两端都是false时，才会返回false。只要有一个true，就会返回true。 或是一个短路的或，如果第一个值是true，则不再检查第二个值 对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值 规则： 1.如果第一个值为true，则返回第一个值 2.如果第一个值为false，则返回第二个值 赋值运算符= 可以将符号右侧的值赋值给左侧变量 += a += 5 相当于 a = a+5 var str = “hello”; str += “world”; = a = 5 相当于 a = a5 = a *= 5 相当于 a = a5 /= a /= 5 相当于 a = a/5 %= a %= 5 相当于 a = a%5 关系运算符 关系运算符用来比较两个值之间的大小关系的 &gt; &gt;= &lt; &lt;= 关系运算符的规则和数学中一致，用来比较两个值之间的关系， 如果关系成立则返回true，关系不成立则返回false。 如果比较的两个值是非数值，会将其转换为Number然后再比较。 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。 相等运算符 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，转换后相等它也会返回true，null == undifined != 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false 不等也会做自动的类型转换。 === 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换， 如果两个值的类型不同，则直接返回false !== 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true 特殊的值： null和undefined 由于undefined衍生自null，所以null == undefined 会返回true。 但是 null === undefined 会返回false。NaN NaN不与任何值相等，报告它自身 NaN == NaN //false 判断一个值是否是NaN 使用isNaN()函数 三元运算符：?: 语法：条件表达式?语句1:语句2; 执行流程： 先对条件表达式求值判断， 如果判断结果为true，则执行语句1，并返回执行结果 如果判断结果为false，则执行语句2，并返回执行结果 优先级： 和数学中一样，JS中的运算符也是具有优先级的， 比如 先乘除 后加减 先与 后或 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高， 优先级越高的越优先计算，优先级相同的，从左往右计算。 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。 流程控制语句 程序都是自上向下的顺序执行的，通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。 分类：1.条件判断语句2.条件分支语句3.循环语句 条件判断语句 条件判断语句也称为if语句 语法一： if(条件表达式){ 语句… } 执行流程： if语句执行时，会先对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则不执行 语法二： if(条件表达式){ 语句… }else{ 语句… } 执行流程： if...else语句执行时，会对条件表达式进行求值判断， 如果值为true，则执行if后的语句 如果值为false，则执行else后的语句 语法三： if(条件表达式){ 语句… }else if(条件表达式){ 语句… }else if(条件表达式){ 语句… }else if(条件表达式){ 语句… }else{ 语句… } 执行流程 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断， 如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。 如果判断结果为false，则继续向下判断，直到找到为true的为止。 如果所有的条件表达式都是false，则执行else后的语句1.条件分支语句switch语句语法:switch(条件表达式){ case 表达式: 语句… break; case 表达式: 语句… break; case 表达式: 语句… break; default: 语句… break;} 执行流程： switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较， 如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。 如果所有的case判断结果都为false，则从default处开始执行代码。 2.循环语句通过循环语句可以反复执行某些语句多次while循环 语法： while(条件表达式){ 语句… } 执行流程： while语句在执行时，会先对条件表达式进行求值判断， 如果判断结果为false，则终止循环 如果判断结果为true，则执行循环体 循环体执行完毕，继续对条件表达式进行求值判断，依此类推 do…while循环 语法: do{ 语句… }while(条件表达式) 执行流程 do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断， 如果判断判断结果为false，则终止循环。 如果判断结果为true，则继续执行循环体，依此类推 和while的区别： while：先判断后执行 do…while: 先执行后判断 do…while可以确保循环体至少执行一次。 for循环 语法： for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){ ③语句… } 执行流程： 首先执行①初始化表达式，初始化一个变量， 然后对②条件表达式进行求值判断，如果为false则终止循环 如果判断结果为true，则执行③循环体 循环体执行完毕，执行④更新表达式，对变量进行更新。 更新表达式执行完毕重复② 死循环while(true){ } for(;;){ } 对象（Object）对象是JS中的引用数据类型对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性使用typeof检查一个对象时，会返回object 对象的分类：1.内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用 - 比如：Math String Number Boolean Function Object…. 2.宿主对象 - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象 - 比如 BOM DOM 3.自定义对象 - 由开发人员自己创建的对象创建对象 方式一： var obj = new Object(); 方式二： var obj = {}; 向对象中添加属性 语法： 对象.属性名 = 属性值; 对象[“属性名”] = 属性值; //这种方式能够使用特殊的属性名 对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。属性值也可以任意的数据类型。 读取对象中的属性 语法： 对象.属性名 对象[“属性名”] //“属性名”可以使字符串常量，也可以是字符串变量 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined 删除对象中的属性 语法： delete 对象.属性名 delete 对象[“属性名”] 遍历使用in检查对象中是否含有指定属性 语法：”属性名” in 对象 如果在对象中含有该属性，则返回true 如果没有则返回false 循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).12345var obj = &#123;'0':'a','1':'b','2':'c'&#125;;for(var i in obj) &#123; console.log(i,\":\",obj[i]);&#125; ​使用对象字面量，在创建对象时直接向对象中添加属性语法：​ var obj = {​ 属性名:属性值,​ 属性名:属性值,​ 属性名:属性值,​ 属性名:属性值​ }​基本数据类型和引用数据类型 基本数据类型​ String Number Boolean Null Undefined 引用数据类型​ Object 基本数据类型的数据，变量是直接保存的它的值。​ 变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。 引用数据类型的数据，变量是保存的对象的引用（内存地址）。​ 如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。 比较两个变量时，对于基本数据类型，比较的就是值，​ 对于引用数据类型比较的是地址，地址相同才相同​ 函数（Function）函数也是一个对象，也具有普通对象的功能（能有属性）函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码使用typeof检查一个函数时会返回function创建函数 函数声明 function 函数名([形参1,形参2…形参N]){ 语句… } 函数表达式 var 函数名 = function([形参1,形参2…形参N]){ 语句… }; 调用函数 语法：函数对象([实参1,实参2…实参N]); fun() sum() alert() Number() parseInt() 当我们调用函数时，函数中封装的代码会按照编写的顺序执行 立即执行函数函数定义完，立即被调用，这种函数叫做立即执行函数立即执行函数往往只会执行一次 (function(a,b){ console.log(“a = “+a); console.log(“b = “+b); })(123,456); 遍历对象 123for(var v in obj)&#123; document.write(\"property：name =\"+v+\"value=\"+obj[v]+\"&lt;br/&gt;\" );&#125; 形参和实参 形参：形式参数 定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开 定义形参就相当于在函数内声明了对应的变量但是并不赋值， 形参会在调用时才赋值。 实参：实际参数 调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参, 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。 如果实参的数量大于形参，多余实参将不会赋值， 如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined 返回值，就是函数执行的结果。 使用return 来设置函数的返回值。 语法：return 值; 该值就会成为函数的返回值，可以通过一个变量来接收返回值 return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。 return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。 如果return后不跟值，或者是不写return则函数默认返回undefined。 break、continue和return break 退出循环 continue 跳过当次循环 return 退出函数 参数，函数的实参也可以是任意的数据类型。 方法（method） 可以将一个函数设置为一个对象的属性， 当一个对象的属性是一个函数时， 我们称这个函数是该对象的方法。 对象.方法名(); 函数名() 函数的属性和方法call()apply() 这两个方法都是函数对象的方法需要通过函数对象来调用 通过两个方法可以直接调用函数，并且可以通过第一个实参来指定函数中this 不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递arguments arguments和this类似，都是函数中的隐含的参数 arguments是一个类数组元素，它用来封装函数执行过程中的实参 所以即使不定义形参，也可以通过arguments来使用实参 arguments中有一个属性callee表示当前执行的函数对象 this（调用函数的那个对象） this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象 1.以函数的形式调用时，this是window 2.以方法的形式调用时，this是调用方法的对象 3.以构造函数的形式调用时，this是新建的那个对象 4.使用call和apply调用时，this是指定的那个对象 5.在全局作用域中this代表window 作用域作用域简单来说就是一个变量的作用范围。在JS中作用域分成两种： 1.全局作用域 ​ 直接在script标签中编写的代码都运行在全局作用域中​ 全局作用域在打开页面时创建，在页面关闭时销毁。​ 全局作用域中有一个全局对象window，window对象由浏览器提供，​ 可以在页面中直接使用，它代表的是整个的浏览器的窗口。​ 在全局作用域中创建的变量都会作为window对象的属性保存​ 在全局作用域中创建的函数都会作为window对象的方法保存​ 在全局作用域中创建的变量和函数可以在页面的任意位置访问。​ 在函数作用域中也可以访问到全局作用域的变量。​ 尽量不要在全局中创建变量 2.函数作用域 ​ 函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。​ 函数作用域在函数执行时创建，在函数执行结束时销毁。​ 在函数作用域中创建的变量，不能在全局中访问。​ 当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，​ 如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，​ 如果找到了则使用，找不到则继续向上找，一直会​ 变量的声明提前​ 在全局作用域中，使用var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。​ 所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。​ 在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，​ 如果没有使用var关键字声明变量，则变量会变成全局变量​ 函数的声明提前​ 在全局作用域中，使用函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建，​ 也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性​ 在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。 this（上下文对象）​ 我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。 指向当前对象 this的不同的情况：1.以函数的形式调用时，this是window2.以方法的形式调用时，this就是调用方法的对象3.以构造函数的形式调用时，this就是新创建的对象 4.构造函数构造函数是专门用来创建对象的函数一个构造函数我们也可以称为一个类通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例通过同一个构造函数创建的对象，我们称为一类对象构造函数就是一个普通的函数，只是他的调用方式不同，如果直接调用，它就是一个普通函数如果使用new来调用，则它就是一个构造函数 例子： 12345678function Person(name , age , gender)&#123; this.name = name; this.age = age; this.gender = gender; this.sayName = function()&#123; alert(this.name); &#125;;&#125; 构造函数的执行流程：1.创建一个新的对象2.将新的对象作为函数的上下文对象（this）3.执行函数中的代码4.将新建的对象返回 instanceof 用来检查一个对象是否是一个类的实例 语法：对象 instanceof 构造函数 如果该对象时构造函数的实例，则返回true，否则返回false Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true 枚举对象中的属性for…in语法： 123for(var 属性名 in 对象)&#123;&#125; for…in语句的循环体会执行多次，对象中有几个属性就会执行几次， 每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性 原型（prototype） 创建一个函数以后，解析器都会默认在函数中添加一个数prototype prototype属性指向的是一个对象，这个对象我们称为原型对象。 当函数作为构造函数使用，它所创建的对象中都会有一个隐含的属性执行该原型对象。 1这个隐含的属性可以通过对象.__proto__来访问。 原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。 我们可以将对象中共有的属性和方法统一添加到原型对象中， 这样我们只需要添加一次，就可以使所有的对象都可以使用。 当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找， 如果在自身中找到了，则直接使用。 如果没有找到，则去原型对象中寻找，如果找到了则使用， 如果没有找到，则去原型的原型中寻找，依此类推。直到找到Object的原型为止，Object的原型的原型为null， 如果依然没有找到则返回undefined hasOwnProperty() 这个方法可以用来检查对象自身中是否含有某个属性 语法：对象.hasOwnProperty(“属性名”) toString方法当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值 如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法 1234//修改Person原型的toStringPerson.prototype.toString = function()&#123; return \"Person[name=\"+this.name+\",age=\"+this.age+\",gender=\"+this.gender+\"]\";&#125;; 垃圾回收（GC）​ 就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾​ 这些垃圾积攒过多以后，会导致程序运行的速度过慢，​ 所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾​ 当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，​ 此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，​ 所以这种垃圾必须进行清理。​ 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，​ 我们不需要也不能进行垃圾回收的操作​ 我们需要做的只是要将不再使用的对象设置null即可 数组（Array） 数组也是一个对象，是一个用来存储数据的对象 和Object类似，但是它的存储效率比普通对象要高 数组中保存的内容我们称为元素 数组使用索引（index）来操作元素 索引指由0开始的整数 数组的操作： 创建数组 var arr = new Array(); var arr = []; 向数组中添加元素 语法； 数组对象[索引] = 值; arr[0] = 123; arr[1] = “hello”; 创建数组时直接添加元素 语法： var arr = [元素1,元素2….元素N]; 例子： var arr = [123,”hello”,true,null]; 获取和修改数组的长度 使用length属性来操作数组的长度 获取长度： 数组.length length获取到的是数组的最大索引+1 对于连续的数组，length获取到的就是数组中元素的个数 修改数组的长度 数组.length = 新长度 如果修改后的length大于原长度，则多出的部分会空出来 如果修改后的length小于原长度，则原数组中多出的元素会被删除 向数组的最后添加元素 数组[数组.length] = 值; 数组的方法 push() 用来向数组的末尾添加一个或多个元素，并返回数组新的长度 语法：数组.push(元素1,元素2,元素N) pop() 用来删除数组的最后一个元素，并返回被删除的元素 unshift() 向数组的开头添加一个或多个元素，并返回数组的新的长度 shift() 删除数组的开头的一个元素，并返回被删除的元素 slice(sart,[end]) 可以从一个数组中截取指定的元素 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回 参数： 1.截取开始位置的索引（包括开始位置） 2.截取结束位置的索引（不包括结束位置） 第二个参数可以省略不写，如果不写则一直截取到最后 参数可以传递一个负值，如果是负值，则从后往前数 splice() 可以用来删除数组中指定元素，并使用新的元素替换 该方法会将删除的元素封装到新数组中返回 参数： 1.删除开始位置的索引 2.删除的个数 3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边reverse() 可以用来反转一个数组，它会对原数组产生影响concat() 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回join([splitor]) 可以将一个数组转换为一个字符串 参数： 需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素 如果不指定连接符则默认使用,sort() 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序 调用以后，会直接修改原数组。 可以自己指定排序的规则，需要一个回调函数作为参数： 我们可以自己来指定排序的规则我们可以在sort()添加一个回调函数，来指定排序规则， 回调函数中需要定义两个形参, 浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边 浏览器会根据回调函数的返回值来决定元素的顺序， 如果返回一个大于0的值，则元素会交换位置 如果返回一个小于0的值，则元素位置不变 如果返回一个0，则认为两个元素相等，也不交换位置 如果需要升序排列，则返回 a-b 如果需要降序排列，则返回b-a 1234567function(a,b)&#123; //升序排列 //return a-b; //降序排列 return b-a;&#125; ​ 遍历数组 遍历数组就是将数组中元素都获取到 一般情况我们都是使用for循环来遍历数组： for(var i=0 ; i&lt;数组.length ; i++){ //数组[i] } 使用forEach()方法来遍历数组（不兼容IE8） 数组.forEach(function(value , index , obj){ }); forEach()方法需要一个回调函数作为参数， 数组中有几个元素，回调函数就会被调用几次， 每次调用时，都会将遍历到的信息以实参的形式传递进来， 我们可以定义形参来获取这些信息。 value:正在遍历的元素 index:正在遍历元素的索引 obj:被遍历对象常用类和方法包装类在JS中为我们提供了三个包装类：String() Boolean() Number() 通过这三个包装类可以创建基本数据类型的对象例子： var num = new Number(2); var str = new String(“hello”); var bool = new Boolean(true); 但是在实际应用中千万不要这么干。 当我们去操作一个基本数据类型的属性和方法时，解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，操作完成以后再将这个临时对象进行销毁。 Date日期的对象，在JS中通过Date对象来表示一个时间创建对象 创建一个当前的时间对象 var d = new Date(); 创建一个指定的时间对象 var d = new Date(“月/日/年 时:分:秒”); 方法：getDate() 当前日期对象是几日（1-31） getDay() 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。 getMonth() 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getTime() 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，到现在时间的毫秒数 计算机底层保存时间都是以时间戳的形式保存的。 Date.now() 可以获取当前代码执行时的时间戳 MathMath属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法我们可以直接使用它来进行数学运算相关的操作方法：Math.PI 常量，圆周率Math.abs() 绝对值运算Math.ceil() 向上取整Math.floor() 向下取整Math.round() 四舍五入取整Math.random() 生成一个01之间的随机数 生成一个xy之间的随机数 Math.round(Math.random()*(y-x)+x);Math.pow(x,y) 求x的y次幂Math.sqrt() 对一个数进行开方Math.max() 求多个数中最大值Math.min() 求多个数中的最小值 字符串的相关的方法使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； length 获取字符串的长度charAt() 根据索引获取指定的字符charCodeAt() 根据索引获取指定的字符编码String.fromCharCode() 根据字符编码获取字符indexOf()lastIndexOf() 从一个字符串中检索指定内容 需要一个字符串作为参数，这个字符串就是要检索的内容， 如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。 可以指定一个第二个参数，来表示开始查找的位置 indexOf()是从前向后找 lastIndexOf()是从后向前找slice(start,[end]) 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量 参数： 第一个：截取开始的位置（包括开始） 第二个：截取结束的位置（不包括结束） 可以省略第二个参数，如果省略则一直截取到最后 可以传负数，如果是负数则从后往前数substr() 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量 substring() 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0， substring()中如果第二个参数小于第一个，自动调整位置toLowerCase() 将字符串转换为小写并返回toUpperCase() 将字符串转换为大写并返回 正则表达相关方法split() 可以根据指定内容将一个字符串拆分为一个数组 参数： 需要一个字符串作为参数，将会根据字符串去拆分数组 可以接收一个正则表达式，此时会根据正则表达式去拆分数组 match() 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来 默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索 我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容 可以为一个正则表达式设置多个匹配模式，且顺序无所谓 match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果 replace() 可以将字符串中指定内容替换为新的内容 参数： 1.被替换的内容，可以接受一个正则表达式作为参数 2.新的内容 空串则为删除”” 默认只会替换第一个 search() 可以搜索字符串中是否含有指定内容 如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串 serach()只会查找第一个，即使设置全局匹配也没用 正则表达式正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，也可以将一个字符串中符合规则的内容提取出来。创建正则表达式 var reg = new RegExp(“正则”,”匹配模式”); 注意：使用构造函数时，由于它的参数是一个字符串，而\\是字符串中转义字符，如果要使用\\则需要使用\\来代替 var reg = /正则表达式/匹配模式 （匹配模式可以多个一起写：/gi） 语法：匹配模式： i:忽略大小写（ignore） g:全局匹配模式（默认为1次） 设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求 正则语法 | 或 [] 或 [^ ] 除了 ​ [x-y] x的ascii到y的ascii码之间的值 [a-z] 小写字母 （也可以[e-i])[A-Z] 大写字母[A-z] 任意字母,但是还包括了其他ASCII在此之中的[0-9] 任意数字 元符号 检查一个字符串中是否含有 . . 表示任意字符 在正则表达式中使用\\作为转义字符 . 来表示. \\ 表示\\ \\w 任意字母、数字、_ [A-z0-9_] \\W 除了字母、数字、_ [ ^A-z0-9_] \\d 任意的数字 [0-9] \\D 除了数字 [ ^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 \\B 除了单词边界 量词 通过量词可以设置一个内容出现的次数 量词只对它前边的一个内容起作用 {n} 正好出现n次 {m,n} 出现mn次 {m,} m次以上 +至少一个，相当于{1,}*个或多个，相当于{0,} ? 0个或1个，相当于{0,1} 边界表达式（不要在java中用，javaScript中用） ^:正则开始 $:正则结束 ：注意结束前一个才是结束匹配 12reg = /^a/;reg = /b$/; 方法：test() 可以用来检查一个字符串是否符合正则表达式 如果符合返回true，否则返回false例子 去掉两端的空格: 12var s = \" f afa \"; s = s.replace(/^\\s*|\\s*$/g,\"\"); DOMDocument Object Model文档对象模型，通过DOM可以来任意来修改网页中各个内容文档 文档指的是网页，一个网页就是一个文档对象 对象指将网页中的每一个节点都转换为对象 转换完对象以后，就可以以一种纯面向对象的形式来操作网页了模型 模型用来表示节点和节点之间的关系，方便操作页面节点（Node） 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点 虽然都是节点，但是节点的类型却是不同的 常用的节点 文档节点 （Document），代表整个网页 元素节点（Element），代表网页中的标签 属性节点（Attribute），代表标签中的属性 文本节点（Text），代表网页中的文本内容 DOM操作 DOM查询 在网页中浏览器已经为我们提供了document对象， 它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。 document查询方法： 根据元素的id属性查询一个元素节点对象： document.getElementById(“id属性值”); 根据元素的name属性值查询一组元素节点对象: document.getElementsByName(“name属性值”); 根据标签名来查询一组元素节点对象： document.getElementsByTagName(“标签名”); 元素的属性： 读取元素的属性： 语法：元素.属性名 例子：ele.name ele.id ele.value ele.className 注意：class属性不能采用这种方式， 读取class属性时需要使用 元素.className 修改元素的属性： 语法：元素.属性名 = 属性值 innerHTML 使用该属性可以获取或设置元素内部的HTML代码 事件（Event） 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。 我们可以为事件来绑定回调函数来响应事件。 绑定事件的方式：​ 1.可以在标签的事件属性中设置相应的JS代码​ 例子： 1&lt;button onclick=\"js代码。。。\"&gt;按钮&lt;/button&gt; ​ 2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件​ 例子： 1234567&lt;button id=\"btn\"&gt;按钮&lt;/button&gt;&lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;;&lt;/script&gt; 文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载， 此时将会无法正常获取到DOM对象，导致DOM操作失败。 解决方式一： 可以将js代码编写到body的下边 12345678910&lt;body&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &lt;/script&gt;&lt;/body&gt; 解决方式二： 将js代码编写到window.onload = function(){}中 window.onload 对应的回调函数会在整个页面加载完毕以后才执行， 所以可以确保代码执行时，DOM对象已经加载完毕了 1234567&lt;script&gt; window.onload = function()&#123; var btn = document.getElementById(\"btn\"); btn.onclick = function()&#123; &#125;; &#125;;&lt;/script&gt; ​ DOM查询通过具体的元素节点来查询元素.getElementsByTagName()通过标签名查询当前元素的指定后代元素 子节点包括便签元素中的文本，子元素自包含标签元素 元素.childNodes 获取当前元素的所有子节点 会获取到空白的文本子节点 childNodes属性会获取包括文本节点在呢的所有节点 根据DOM标签标签间空白也会当成文本节点 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点， 所以该属性在IE8中会返回4个子元素而其他浏览器是9个 元素.children 获取当前元素的所有子元素 元素.firstChild 获取当前元素的第一个子节点，会获取到空白的文本子节点 元素.lastChild 获取当前元素的最后一个子节点 元素.parentNode 获取当前元素的父元素 元素.previousSibling 获取当前元素的前一个兄弟节点 previousElementSibling获取前一个兄弟元素，IE8及以下不支持 元素.nextSibling 获取当前元素的后一个兄弟节点 firstElementChild获取当前元素的第一个子元素 firstElementChild不支持IE8及以下的浏览器， 如果需要兼容他们尽量不要使用 innerHTML和innerText这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性两个属性作用类似，都可以获取到标签内部的内容，不同是innerHTML会获取到html标签，而innerText会自动去除标签如果使用这两个属性来设置标签内部的内容时，没有任何区别的 读取标签内部的文本内容 h1中的文本内容 元素.firstChild.nodeValue document对象的其他的属性和方法document.all 获取页面中的所有元素，相当于document.getElementsByTagName(“*”); document.documentElement 获取页面中html根元素 document.body 获取页面中的body元素 document.getElementsByClassName() 根据元素的class属性值查询一组元素节点对象 这个方法不支持IE8及以下的浏览器 document.querySelector() 根据CSS选择器去页面中查询一个元素 如果匹配到的元素有多个，则它会返回查询到的第一个元素 document.querySelectorAll() 根据CSS选择器去页面中查询一组元素 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个 DOM修改document.createElement(“TagName”) 可以用于创建一个元素节点对象， 它需要一个标签名作为参数，将会根据该标签名创建元素节点对象， 并将创建好的对象作为返回值返回document.createTextNode(“textContent”)可以根据文本内容创建一个文本节点对象 父节点.appendChild(子节点) 向父节点中添加指定的子节点父节点.insertBefore(新节点,旧节点) 将一个新的节点插入到旧节点的前边父节点.replaceChild(新节点,旧节点) 使用一个新的节点去替换旧节点 父节点.removeChild(子节点) 删除指定的子节点 推荐方式：子节点.parentNode.removeChild(子节点) 以上方法，实际就是改变了相应元素（标签）的innerHTML的值。 123456789101112131415161718myClick(\"btn07\",function()&#123; //向city中添加广州 var city = document.getElementById(\"city\"); /* * 使用innerHTML也可以完成DOM的增删改的相关操作 * 一般我们会两种方式结合使用 */ //city.innerHTML += \"&lt;li&gt;广州&lt;/li&gt;\"; //创建一个li var li = document.createElement(\"li\"); //向li中设置文本 li.innerHTML = \"广州\"; //将li添加到city中 city.appendChild(li);&#125;); DOM对CSS的操作读取和修改内联样式使用style属性来操作元素的内联样式 读取内联样式： 语法：元素.style.样式名例子： 元素.style.width 元素.style.height 注意：如果样式名中带有-，则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写 比如：backgroundcolor &gt; backgroundColor borderwidth &gt; borderWidth修改内联样式：语法：元素.style.样式名 = 样式值 通过style修改和读取的样式都是内联样式，由于内联样式的优先级比较高， 所以我们通过JS来修改的样式，往往会立即生效， 但是如果样式中设置了!important，则内联样式将不会生效。 读取元素的当前样式正常浏览器 使用getComputedStyle() 这个方法是window对象的方法，可以返回一个对象，这个对象中保存着当前元素生效样式 参数： 1.要获取样式的元素 2.可以传递一个伪元素，一般传null 例子： 获取元素的宽度 getComputedStyle(box , null)[“width”]; 通过该方法读取到样式都是只读的不能修改 IE8 使用currentStyle 语法： 元素.currentStyle.样式名 例子： box.currentStyle[“width”] 通过这个属性读取到的样式是只读的不能修改 实现兼容性 //对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 1234567891011121314151617/** 定义一个函数，用来获取指定元素的当前的样式* 参数：* obj 要获取样式的元素* name 要获取的样式名*/function getStyle(obj , name)&#123;//对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错 if(window.getComputedStyle)&#123; //正常浏览器的方式，具有getComputedStyle()方法 return getComputedStyle(obj , null)[name]; &#125;else&#123; //IE8的方式，没有getComputedStyle()方法 return obj.currentStyle[name]; &#125; //return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name]; &#125; 其他的样式相关的属性注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角 clientHeight 元素的可见高度，包括元素的内容区和内边距的高度clientWidth 元素的可见宽度，包括元素的内容区和内边距的宽度offsetHeight 整个元素的高度，包括内容区、内边距、边框offfsetWidth 整个元素的宽度，包括内容区、内边距、边框offsetParent 当前元素的定位父元素 离他最近的开启了定位的祖先元素，如果所有的元素都没有开启定位，则返回bodyoffsetLeftoffsetTop 当前元素和定位父元素之间的偏移量 offsetLeft水平偏移量 offsetTop垂直偏移量 scrollHeightscrollWidth 获取元素滚动区域的高度和宽度 scrollTopscrollLeft 获取元素垂直和水平滚动条滚动的距离 判断滚动条是否滚动到底 垂直滚动条 scrollHeight -scrollTop = clientHeight 水平滚动 scrollWidth -scrollLeft = clientWidth 事件（Event）事件对象当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件对象中封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。 可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存 例子： 12345678元素.事件 = function(event)&#123; event = event || window.event;&#125;;元素.事件 = function(e)&#123; e = e || event; &#125;; 获取到鼠标的坐标 clientX和clientY 用于获取鼠标在当前的可见窗口的坐标 div的偏移量，是相对于整个页面的 pageX和pageY 可以获取鼠标相对于当前页面的坐标 但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用var left = event.clientX;var top = event.clientY; 事件的冒泡（Bubble） 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消 可以将事件对象的cancelBubble设置为true，即可取消冒泡 例子： 1234元素.事件 = function(event)&#123; event = event || window.event; event.cancelBubble = true;&#125;; 事件的委派 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能 我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的我们可以尝试将其绑定给元素的共同的祖先元素 target : event中的target表示的触发事件的对象 事件的绑定addEventListener() 通过这个方法也可以为元素绑定响应函数参数： 1.事件的字符串，不要on 2.回调函数，当事件触发时该函数会被调用 3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false 使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照函数的绑定顺序执行 这个方法不支持IE8及以下的浏览器 1234567btn01.addEventListener(\"click\",function()&#123; alert(1);&#125;,false);btn01.addEventListener(\"click\",function()&#123; alert(2);&#125;,false); attachEvent() 在IE8中可以使用attachEvent()来绑定事件参数： 1.事件的字符串，要on 2.回调函数 这个方法也可以同时为一个事件绑定多个处理函数， 不同的是它是后绑定先执行，执行顺序和addEventListener()相反 1234567btn01.attachEvent(\"onclick\",function()&#123;alert(1);&#125;);btn01.attachEvent(\"onclick\",function()&#123;alert(2);&#125;); 12345678910111213141516171819202122232425262728//定义一个函数，用来为指定元素绑定响应函数/* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this *//* * 参数： * obj 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj); &#125;); &#125;&#125; 事件的传播 关于事件的传播网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件， 然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件， 然后在向内传播给后代元素 W3C综合了两个公司的方案，将事件传播分成了三个阶段 1.捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件 2.目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件 3.冒泡阶段 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false IE8及以下的浏览器中没有捕获阶段 常用事件鼠标事件拖拽事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;style type=\"text/css\"&gt; #box1&#123;width: 100px;height: 100px;background-color: red;position: absolute;&#125;#box2&#123;width: 100px;height: 100px;background-color: yellow;position: absolute;left: 200px;top: 200px;&#125; &lt;/style&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; /* * 拖拽box1元素 * - 拖拽的流程 * 1.当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove * 3.当鼠标松开时，被拖拽元素固定在当前位置 onmouseup */ //获取box1 var box1 = document.getElementById(\"box1\"); var box2 = document.getElementById(\"box2\"); var img1 = document.getElementById(\"img1\"); //开启box1的拖拽 drag(box1); //开启box2的 drag(box2); drag(img1);&#125;;/* * 提取一个专门用来设置拖拽的函数 * 参数：开启拖拽的元素 */function drag(obj)&#123; //当鼠标在被拖拽元素上按下时，开始拖拽 onmousedown obj.onmousedown = function(event)&#123; //设置box1捕获所有鼠标按下的事件 /* * setCapture() * - 只有IE支持，但是在火狐中调用时不会报错， * 而如果使用chrome调用，会报错 */ /*if(box1.setCapture)&#123; box1.setCapture(); &#125;*/ obj.setCapture &amp;&amp; obj.setCapture(); event = event || window.event; //div的偏移量 鼠标.clentX - 元素.offsetLeft //div的偏移量 鼠标.clentY - 元素.offsetTop var ol = event.clientX - obj.offsetLeft; var ot = event.clientY - obj.offsetTop; //为document绑定一个onmousemove事件 document.onmousemove = function(event)&#123; event = event || window.event; //当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove //获取鼠标的坐标 var left = event.clientX - ol; var top = event.clientY - ot; //修改box1的位置 obj.style.left = left+\"px\"; obj.style.top = top+\"px\"; &#125;; //为document绑定一个鼠标松开事件 document.onmouseup = function()&#123; //当鼠标松开时，被拖拽元素固定在当前位置 onmouseup //取消document的onmousemove事件 document.onmousemove = null; //取消document的onmouseup事件 document.onmouseup = null; //当鼠标松开时，取消对事件的捕获 obj.releaseCapture &amp;&amp; obj.releaseCapture(); &#125;; /** 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，* 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，* 如果不希望发生这个行为，则可以通过return false来取消默认行为* * 但是这招对IE8不起作用*/ return false; &#125;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 我是一段文字&lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;div id=\"box2\"&gt;&lt;/div&gt;&lt;img src=\"img/an.jpg\" id=\"img1\" style=\"position: absolute;\"/&gt; &lt;/body&gt;&lt;/html&gt; 滚轮事件： onwheel都支持 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;style type=\"text/css\"&gt; #box1&#123;width: 100px;height: 100px;background-color: red;&#125; &lt;/style&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; //获取id为box1的div var box1 = document.getElementById(\"box1\"); //为box1绑定一个鼠标滚轮滚动的事件 /* * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发， * 但是火狐不支持该属性 * * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件 * 注意该事件需要通过addEventListener()函数来绑定 */ box1.onmousewheel = function(event)&#123; event = event || window.event; //event.wheelDelta 可以获取鼠标滚轮滚动的方向 //向上滚 120 向下滚 -120 //wheelDelta这个值我们不看大小，只看正负 //alert(event.wheelDelta); //wheelDelta这个属性火狐中不支持 //在火狐中使用event.detail来获取滚动的方向 //向上滚 -3 向下滚 3 //alert(event.detail); /* * 当鼠标滚轮向下滚动时，box1变长 * 当滚轮向上滚动时，box1变短 */ //判断鼠标滚轮滚动的方向 if(event.wheelDelta &gt; 0 || event.detail &lt; 0)&#123; //向上滚，box1变短 box1.style.height = box1.clientHeight - 10 + \"px\"; &#125;else&#123; //向下滚，box1变长 box1.style.height = box1.clientHeight + 10 + \"px\"; &#125; /* * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false * 需要使用event来取消默认行为event.preventDefault(); * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错 */ event.preventDefault &amp;&amp; event.preventDefault(); /* * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动， * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为 */ return false; &#125;; //为火狐绑定滚轮事件 bind(box1,\"DOMMouseScroll\",box1.onmousewheel);&#125;;function bind(obj , eventStr , callback)&#123; if(obj.addEventListener)&#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr , callback , false); &#125;else&#123; /* * this是谁由调用方式决定 * callback.call(obj) */ //IE8及以下 obj.attachEvent(\"on\"+eventStr , function()&#123; //在匿名函数中调用回调函数 callback.call(obj); &#125;); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body style=\"height: 2000px;\"&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 键盘事件键盘事件：onkeydown 按键被按下 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。onkeyup 按键被松开 键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document keyCode 可以通过keyCode来获取按键的编码通过它可以判断哪个按键被按下除了keyCode，事件对象中还提供了几个属性altKeyctrlKeyshiftKey这个三个用来判断alt ctrl 和 shift是否被按下如果按下则返回true，否则返回false 1234567//console.log(event.keyCode);//判断一个y是否被按下//判断y和ctrl是否同时被按下if(event.keyCode === 89 &amp;&amp; event.ctrlKey)&#123; console.log(\"ctrl和y都被按下了\");&#125; 12345678910input.onkeydown = function(event) &#123; event = event || window.event; //数字 48 - 57 //使文本框中不能输入数字 if(event.keyCode &gt;= 48 &amp;&amp; event.keyCode &lt;= 57) &#123; //在文本框中输入内容，属于onkeydown的默认行为 //如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 return false; &#125;&#125;; BOM浏览器对象模型(browser object model)BOM可以使我们通过JS来操作浏览器在BOM中为我们提供了一组对象，用来完成对浏览器的操作BOM对象Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器Location 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页 而且该操作只在当次访问时有效Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了 一般我们只会使用userAgent来判断浏览器的信息， userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容， 不同的浏览器会有不同的userAgent 火狐的userAgentMozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0 Chrome的userAgentMozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36 IE8Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE9Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE10Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) IE11Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了 123456789101112131415alert(navigator.appName);var ua = navigator.userAgent;console.log(ua);if(firefoxi.test(ua))&#123;alert(\"你是火狐！！！\");&#125;else if(chromei.test(ua))&#123;alert(\"你是Chrome\");&#125;else if(msiei.test(ua))&#123;alert(\"你是IE浏览器~~~\");&#125;else if(\"ActiveXObject\" in window)&#123;alert(\"你是IE11，枪毙了你~~~\");&#125; History 对象可以用来操作浏览器向前或向后翻页length 属性，可以获取到当成访问的链接数量back() 可以用来回退到上一个页面，作用和浏览器的回退按钮一样forward() 可以跳转下一个页面，作用和浏览器的前进按钮一样go() 可以用来跳转到指定的页面 它需要一个整数作为参数 1:表示向前跳转一个页面 相当于forward() 2:表示向前跳转两个页面 -1:表示向后跳转一个页面 -2:表示向后跳转两个页面 Location 该对象中封装了浏览器的地址栏的信息如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）alert(location);如果直接将location属性修改为一个完整的路径，或相对路径则我们页面会自动跳转到该路径，并且会生成相应的历史记录location = “http:www.baidu.com&quot;;location = “01.BOM.html”;assign() 用来跳转到其他的页面，作用和直接修改location一样reload() 用于重新加载当前页面，作用和刷新按钮一样 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面location.reload(true);replace() 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不会生成历史记录，不能使用回退按钮回退 window定时器setInterval() 定时调用 可以将一个函数，每隔一段时间执行一次 参数： 1.回调函数，该函数会每隔一段时间被调用一次 2.每次调用间隔的时间，单位是毫秒 返回值： 返回一个Number类型的数据 这个数字用来作为定时器的唯一标识clearInterval()可以用来关闭一个定时器方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器 clearInterval()可以接收任意参数， 如果参数是一个有效的定时器的标识，则停止对应的定时器 如果参数不是一个有效的标识，则什么也不做 12345678var num = 1;var timer = setInterval(function() &#123; count.innerHTML = num++; if(num == 11) &#123; //关闭定时器 clearInterval(timer); &#125;&#125;, 1000); 延时调用setTimeout 延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择 var timer = setTimeout(function(){console.log(num++);},3000); 使用clearTimeout()来关闭一个延时调用clearTimeout(timer); #类的操作 直接修改元素的类css： 通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式 我们可以通过修改元素的class属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，并且这种方式，可以使表现和行为进一步的分离 1box.className += \" b2\"; //注意有空格，添加class属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445//定义一个函数，用来向一个元素中添加指定的class属性值/* * 参数: * obj 要添加class属性的元素 * cn 要添加的class值 * */function addClass(obj, cn) &#123; if (!hasClass(obj, cn)) &#123; obj.className += \" \" + cn; &#125;&#125;/* * 判断一个元素中是否含有指定的class属性值 * 如果有该class，则返回true，没有则返回false * */function hasClass(obj, cn) &#123; var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); return reg.test(obj.className);&#125;/* * 删除一个元素中的指定的class属性 */function removeClass(obj, cn) &#123; //创建一个正则表达式 var reg = new RegExp(\"\\\\b\" + cn + \"\\\\b\"); //删除class obj.className = obj.className.replace(reg, \"\");&#125;/* * toggleClass可以用来切换一个类 * 如果元素中具有该类，则删除 * 如果元素中没有该类，则添加 */function toggleClass(obj , cn)&#123; //判断obj中是否含有cn if(hasClass(obj , cn))&#123; //有，则删除 removeClass(obj , cn); &#125;else&#123; //没有，则添加 addClass(obj , cn); &#125;&#125; JSON JavaScript Object Notation JS对象表示法 JS中的对象只有JS自己认识，其他的语言都不认识JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互 JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号 其他的和JS语法一致JSON分类： 1.对象 {} 2.数组 [] JSON中允许的值： 1.字符串 2.数值 3.布尔值 4.null 5.对象 6.数组 举例： 12345var arr = '[1,2,3,\"hello\",true]'; var obj2 = '&#123;\"arr\":[1,2,3]&#125;';var arr2 ='[&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;,&#123;\"name\":\"孙悟空\",\"age\":18,\"gender\":\"男\"&#125;]'; JSON工具类 json &gt; js对象JSON.parse() 可以将以JSON字符串转换为js对象 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回 var o = JSON.parse(json);var o2 = JSON.parse(arr); var obj3 = {name:”猪八戒” , age:28 , gender:”男”}; JS对象 &gt; JSONJSON.stringify() -ify/fy，表示”使……化。 可以将一个JS对象转换为JSON字符串 需要一个js对象作为参数，会返回一个JSON字符串 var str = JSON.stringify(obj3);console.log(str); JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错 # 原生js原生js实现复制内容到剪切板1234567891011copy() &#123; const input = document.createElement(\"input\"); document.body.appendChild(input); input.setAttribute(\"value\",this.solution.code); input.select(); if (document.execCommand(\"copy\")) &#123; document.execCommand(\"copy\"); // console.log(\"复制成功\"); &#125; document.body.removeChild(input);&#125; ​ othereval() 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块 如果不希望将其当成代码块解析，则需要在字符串前后各加一个() eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码， 但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患 var str = &apos;{&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;}&apos;; var obj = eval(&quot;(&quot;+str+&quot;)&quot;);编码 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; /* * 在字符串中使用转义字符输入Unicode编码 * \\u四位编码 */ console.log(\"\\u2620\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--在网页中使用Unicode编码 &amp;#编码; 这里的编码需要的是10进制 --&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9760;&lt;/h1&gt; &lt;h1 style=\"font-size: 200px;\"&gt;&amp;#9856;&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 取消默认行为 12345678hrefs[i].onclick = function()&#123; hrefs[i].parentNode.removeChild(hrefs[i]); /* * 点击超链接以后，超链接会跳转页面，这是超链接的默认行为 * 如果我们不想出现默认行为，可以returnfalse，取消 */return false;&#125; 响应函数只在响应时执行，而其他（for循环）早已在window.onload时执行完毕 1234567891011121314//为每个超链接都绑定一个单击响应函数for(var i=0 ; i &lt; allA.length ; i++)&#123; /* * for循环会在页面加载完成之后立即执行， * 而响应函数会在超链接被点击时才执行 * 当响应函数执行时，for循环早已执行完毕 */ alert(\"for循环正在执行\"+i); allA[i].onclick = function()&#123; alert(\"响应函数正在执行\"+i); //alert(allA[i]); return false; &#125;; &#125; confirm()用于弹出一个带有确认和取消按钮的提示框需要一个字符串作为参数，该字符串将会作为提示文字显示出来如果用户点击确认则会返回true，如果点击取消则返回falsevar flag = confirm(“确认删除”+name+”吗?”);","categories":[{"name":"学习笔记-js","slug":"学习笔记-js","permalink":"https://codeofli.github.io/categories/学习笔记-js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://codeofli.github.io/tags/js/"},{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"}]},{"title":"vue","slug":"js-note/vue/vue","date":"2019-11-11T15:23:44.000Z","updated":"2019-11-12T02:17:00.498Z","comments":true,"path":"2019/11/js-note/vue/vue/","link":"","permalink":"https://codeofli.github.io/2019/11/js-note/vue/vue/","excerpt":"第 1 章： Vue 核心1.1. Vue 的基本认识1.1.1. 官网1) 英文官网: https://vuejs.org/2) 中文官网: https://cn.vuejs.org/1.1.2. 介绍描述1) 渐进式 JavaScript 框架2) 作者: 尤雨溪(一位华裔前 Google 工程师)3) 作用: 动态构建用户界面","text":"第 1 章： Vue 核心1.1. Vue 的基本认识1.1.1. 官网1) 英文官网: https://vuejs.org/2) 中文官网: https://cn.vuejs.org/1.1.2. 介绍描述1) 渐进式 JavaScript 框架2) 作者: 尤雨溪(一位华裔前 Google 工程师)3) 作用: 动态构建用户界面 1.1.3. Vue 的特点1) 遵循 MVVM 模式2) 编码简洁, 体积小, 运行效率高, 适合移动/PC 端开发3) 它本身只关注 UI, 可以轻松引入 vue 插件或其它第三库开发项目 1.1.4. 与其它前端 JS 框架的关联1) 借鉴 angular 的模板和数据绑定技术2) 借鉴 react 的组件化和虚拟 DOM 技术 1.1.5. Vue 扩展插件1) vue-cli: vue 脚手架2) vue-resource(axios): ajax 请求3) vue-router: 路由4) vuex: 状态管理5) vue-lazyload: 图片懒加载6) vue-scroller: 页面滑动相关7) mint-ui: 基于 vue 的 UI 组件库(移动端)8) element-ui: 基于 vue 的 UI 组件库(PC 端) 1.2. Vue 的基本使用12345678910111213&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"username\"&gt; &lt;p&gt;Hello, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; username: 'atguigu' &#125; &#125;)&lt;/script&gt; 1.2.3. 使用 vue 开发者工具调试Vue.jsdevtools-翻墙安装方式-推荐 1.2.4.理解Vue的MVVM 1.3. 模板语法1.3.2.模板的理解1) 动态的 html 页面2) 包含了一些 JS 语法代码a. 双大括号表达式b. 指令(以 v-开头的自定义标签属性) 1.3.3. 双大括号表达式1) 语法: 2) 功能: 向页面输出数据3) 可以调用对象的方法 1.3.4. 指令一: 强制数据绑定1) 功能: 指定变化的属性值2) 完整写法: v-bind:xxx=’yyy’ //yyy 会作为表达式解析执行3) 简洁写法: :xxx=’yyy’ 1.3.5. 指令二: 绑定事件监听1) 功能: 绑定指定事件名的回调函数2) 完整写法:v-on:keyup=’xxx’v-on:keyup=’xxx(参数)’v-on:keyup.enter=’xxx’3) 简洁写法:@keyup=’xxx’@keyup.enter=’xx 1.3.6. 编码123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;h2&gt;1. 双大括号表达式&lt;/h2&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg.toUpperCase()&#125;&#125;&lt;/p&gt; &lt;h2&gt;2. 指令一: 强制数据绑定&lt;/h2&gt; &lt;a href=\"url\"&gt;访问指定站点&lt;/a&gt;&lt;br&gt;&lt;!--不能使用--&gt; &lt;a v-bind:href=\"url\"&gt;访问指定站点 2&lt;/a&gt;&lt;br&gt; &lt;a :href=\"url\"&gt;访问指定站点 3&lt;/a&gt;&lt;br&gt; &lt;h2&gt;3. 指令二: 绑定事件监听&lt;/h2&gt; &lt;button v-on:click=\"handleClick\"&gt;点我&lt;/button&gt; &lt;button @click=\"handleClick\"&gt;点我 2&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123;// data 的所有属性都会成功 vm 对象的属性, 而模板页面中可以直接访问 msg: 'NBA I Love This Game!', url: 'http://www.baidu.com' &#125;, methods: &#123; handleClick () &#123; alert('处理点击') &#125; &#125; &#125;)&lt;/script&gt; 1.3.8 v-model和双向数据绑定`v-model 只能运用在 表单元素和组件中 12345678&lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt;&lt;!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定 --&gt;&lt;input type=\"text\" v-bind:value=\"msg\" style=\"width:100%;\"&gt;&lt;!-- 使用 v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 --&gt;&lt;!-- input(radio, text, address, email....) select checkbox textarea --&gt;&lt;input type=\"text\" style=\"width:100%;\" v-model=\"msg\"&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。 1.4. 计算属性和监视1.4.2. 计算属性1) 在 computed 属性对象中定义计算属性的方法2) 在页面中使用来显示计算的结果 1.4.3. 监视属性1) 通过通过 vm 对象的$watch()或 watch 配置来监视指定的属性2) 当属性变化时, 回调函数自动调用, 在函数内部进行计算 watch`属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 1.监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; + &lt;input type=\"text\" v-model=\"lastName\"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen', fullName: 'jack - chen' &#125;, methods: &#123;&#125;, watch: &#123; 'firstName': function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + ' - ' + this.lastName; &#125;, 'lastName': function (newVal, oldVal) &#123; this.fullName = this.firstName + ' - ' + newVal; &#125; &#125; &#125;); &lt;/script&gt; 2.监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125;); var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: \"/login\", component: login &#125;, &#123; path: \"/register\", component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; '$route': function (newVal, oldVal) &#123; if (newVal.path === '/login') &#123; console.log('这是登录组件'); &#125; &#125; &#125; &#125;); &lt;/script&gt; 1.4.4. 计算属性高级1) 通过 getter/setter 实现对属性数据的显示和监视2) 计算属性存在缓存, 多次读取只执行一次 getter 计算 computed计算属性的使用// 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了； 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值； 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; + &lt;input type=\"text\" v-model=\"lastName\"&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123;&#125;, computed: &#123; fullName() &#123; return this.firstName + ' - ' + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 2.定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=\"button\" value=\"修改fullName\" @click=\"changeName\"&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'jack', lastName: 'chen' &#125;, methods: &#123; changeName() &#123; this.fullName = 'TOM - chen2'; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + ' - ' + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(' - '); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; 1.4.5. 编码12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"demo\"&gt; 姓: &lt;input type=\"text\" placeholder=\"First Name\" v-model=\"firstName\"&gt;&lt;br&gt; 名: &lt;input type=\"text\" placeholder=\"Last Name\" v-model=\"lastName\"&gt;&lt;br&gt; 姓名 1(单向): &lt;input type=\"text\" placeholder=\"Full Name\" v-model=\"fullName1\"&gt;&lt;br&gt; 姓名 2(单向): &lt;input type=\"text\" placeholder=\"Full Name\" v-model=\"fullName2\"&gt;&lt;br&gt; 姓名 3(双向): &lt;input type=\"text\" placeholder=\"Full Name2\" v-model=\"fullName3\"&gt;&lt;br&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Kobe', lastName: 'bryant', fullName2: 'Kobe bryant' &#125;, computed: &#123; fullName: function () &#123; return this.firstName + \" \" + this.lastName &#125;, fullName3: &#123; get: function () &#123; return this.firstName + \" \" + this.lastName &#125;, set: function (value) &#123; var names = value.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;, watch: &#123; lastName: function (newVal, oldVal) &#123; this.fullName2 = this.firstName + ' ' + newVal &#125; &#125; &#125;) vm.$watch('firstName', function (val) &#123; this.fullName2 = val + ' ' + this.lastName &#125;) ``watch、computed和methods`之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 1.5. class 与 style 绑定1.5.2. 理解1) 在应用界面中, 某个(些)元素的样式是变化的2) class/style 绑定就是专门用来实现动态样式效果的技术 1.5.3. class 绑定（使用class样式）1) :class=’xxx’2) 表达式是字符串: ‘classA’3) 表达式是对象: {classA:isA, classB: isB}4) 表达式是数组: [‘classA’, ‘classB’] 1.数组 1&lt;h1 :class=\"['red', 'thin']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 2.数组中使用三元表达式 1&lt;h1 :class=\"['red', 'thin', isactive?'active':'']\"&gt;这是一个邪恶的H1&lt;/h1&gt; 3.数组中嵌套对象 1&lt;h1 :class=\"['red', 'thin', &#123;'active': isactive&#125;]\"&gt;这是一个邪恶的H1&lt;/h1&gt; 4.直接使用对象 1&lt;h1 :class=\"&#123;red:true, italic:true, active:true, thin:true&#125;\"&gt;这是一个邪恶的H1&lt;/h1&gt; 注意如果类名中有-，必须用&#39;&#39;括起来,不然没有用 1&lt;li :class=\"&#123;'page-item': true,active: true&#125;\"&gt;&lt;/li&gt; 1.5.4. style 绑定1) :style=”{ color: activeColor, fontSize: fontSize + ‘px’ }”2) 其中 activeColor/fontSize 是 data 属性 1.5.5. 编吗12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .classA &#123; color: red; &#125; . classB &#123; background: blue; &#125; . classC &#123; font-size: 20px; &#125;&lt;/style&gt;&lt;div id=\"demo\"&gt; &lt;h2&gt;1. class 绑定: :class='xxx'&lt;/h2&gt; &lt;p class=\"classB\" :class=\"a\"&gt;表达式是字符串: 'classA'&lt;/p&gt; &lt;p :class=\"&#123;classA: isA, classB: isB&#125;\"&gt;表达式是对象: &#123;classA:isA, classB: isB&#125;&lt;/p&gt; &lt;p :class=\"['classA', 'classC']\"&gt; 表达式是数组: ['classA', 'classB']&lt;/p&gt; &lt;h2&gt;2. style 绑定&lt;/h2&gt; &lt;p :style=\"&#123;color, fontSize&#125;\"&gt;style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&lt;/p&gt; &lt;button @click=\"update\"&gt;更新&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el : '#demo', data : &#123; a: 'classA', isA: true, isB: false, color: 'red', fontSize: '20px' &#125;, methods : &#123; update () &#123; this.a = 'classC' this.isA = false this.isB = true this.color = 'blue' this.fontSize = '30px' &#125; &#125; &#125;)&lt;/script&gt; 1.6. 条件渲染1.6.2. 条件渲染指令1) v-if 与 v-else2) v-show 1.6.3. 比较 v-if 与 v-show3)如果需要频繁切换 v-show 较好4)当条件不成立时, v-if 的所有子节点不会解析(项目中使用) 1.6.4. 编码1234567891011121314151617&lt;div id=\"demo\"&gt; &lt;h2 v-if=\"ok\"&gt;表白成功&lt;/h2&gt; &lt;h2 v-else&gt;表白失败&lt;/h2&gt; &lt;h2 v-show=\"ok\"&gt;求婚成功&lt;/h2&gt; &lt;h2 v-show=\"!ok\"&gt;求婚失败&lt;/h2&gt; &lt;br&gt; &lt;button @click=\"ok=!ok\"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; ok: false &#125; &#125;)&lt;/script&gt; 1.7. 列表渲染1) 列表显示指令数组: v-for / index对象: v-for / key2) 列表的更新显示删除 item替换 item3) 列表的高级处理列表过滤列表排序 注意事项 由于 JavaScript 的限制，Vue 不能检测以下数组的变动： 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 1.7.2. 编码1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"demo\"&gt; &lt;h2&gt;测试: v-for 遍历数组&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(p, index) in persons\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; &lt;button @click=\"deleteItem(index)\"&gt;删除&lt;/button&gt; &lt;button @click=\"updateItem(index, &#123;name:'Jok',age:15&#125;)\"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;测试: v-for 遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=\"(value, key) in persons[0]\"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; persons: [ &#123;id: 1, name: 'Tom', age: 13&#125;, &#123;id: 2, name: 'Jack', age: 12&#125;, &#123;id: 3, name: 'Bob', age: 14&#125; ] &#125;, methods: &#123; deleteItem(index) &#123; this.persons.splice(index, 1) &#125;, updateItem(index, p) &#123; // this.persons[index] = p // 页面不会更新 this.persons.splice(index, 1, p) &#125; &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"demo\"&gt; &lt;input type=\"text\" name=\"searchName\" placeholder=\"搜索指定用户名\" v-model=\"searchName\"&gt; &lt;ul&gt; &lt;li v-for=\"(p, index) in filterPerson\" :key=\"index\"&gt; &#123;&#123;index&#125;&#125;--&#123;&#123;p.name&#125;&#125;--&#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click=\"setOrderType(1)\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"setOrderType(2)\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"setOrderType(0)\"&gt;原本顺序&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; orderType: 0, //0 代表不排序, 1 为升序, 2 为降序 searchName: '', persons: [ &#123;id: 1, name: 'Tom', age: 13&#125;, &#123;id: 2, name: 'Jack', age: 12&#125;, &#123;id: 3, name: 'Bob', age: 17&#125;, &#123;id: 4, name: 'Cat', age: 14&#125;, &#123;id: 4, name: 'Mike', age: 14&#125;, &#123;id: 4, name: 'Monica', age: 16&#125; ] &#125;, methods: &#123; setOrderType (orderType) &#123; this.orderType = orderType &#125; &#125;, computed: &#123; filterPerson() &#123; let &#123;orderType, searchName, persons&#125; = this // 过滤 persons = persons.filter(p =&gt; p.name.indexOf(searchName)!=-1) // 排序 if(orderType!==0) &#123; persons = persons.sort(function (p1, p2) &#123; if(orderType===1) &#123; return p1.age-p2.age &#125; else &#123; return p2.age-p1.age &#125; &#125;) &#125; r eturn persons &#125; &#125; &#125;)&lt;/script&gt; 1.8. 事件处理1.8.2. 绑定监听1) v-on:xxx=”fun”2) @xxx=”fun”3) @xxx=”fun(参数)”4) 默认事件形参: event event 是原生 DOM 事件5) 隐含属性对象: $event 1.8.3. 事件修饰符1) .prevent : 阻止事件的默认行为 event.preventDefault()2) .stop : 停止事件冒泡 event.stopPropagation() 事件修饰符 .stop 阻止冒泡 1234&lt;!-- 使用 .stop 阻止冒泡 --&gt;&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt;&lt;/div&gt; .prevent 阻止默认事件 12&lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; .capture 添加事件侦听器时使用事件捕获模式 1234&lt;!-- 使用 .capture 实现捕获触发事件的机制 --&gt;&lt;div class=\"inner\" @click.capture=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 1234&lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt;&lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt;&lt;/div&gt; .once 事件只触发一次 12&lt;!-- 使用 .once 只触发一次事件处理函数 --&gt;&lt;a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\"&gt;有问题，先去百度&lt;/a&gt; 1.8.4. 按键修饰符1) .keycode : 操作的是某个 keycode 值的键2) .keyName : 操作的某个按键名的键(少部分) 1.8.5. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=\"example\"&gt; &lt;h2&gt;1. 绑定监听&lt;/h2&gt; &lt;button v-on:click=\"test1\"&gt;Greet&lt;/button&gt; &lt;button @click=\"test1\"&gt;Greet2&lt;/button&gt; &lt;button @click=\"test2($event, 'hello')\"&gt;Greet3&lt;/button&gt; &lt;h2&gt;2. 事件修饰符&lt;/h2&gt; &lt;!-- 阻止事件默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"test3\"&gt;百度一下&lt;/a&gt; &lt;br/&gt; &lt;br/&gt; &lt;!-- 停止事件冒泡 --&gt; &lt;div style=\"width: 200px;height: 200px;background: red\" @click=\"test4\"&gt; &lt;div style=\"width: 100px;height: 100px;background: green\" @click.stop=\"test5\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;h2&gt;3. 按键修饰符&lt;/h2&gt; &lt;input @keyup.8=\"test6\"&gt; &lt;input @keyup.enter=\"test6\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(el: '#example', data: &#123; name: 'Vue.js' &#125;, methods: &#123; test1 (event) &#123; // 方法内 `this` 指向 vm // alert('Hello ' + this.name + '!') // `event` 是原生 DOM 事件 alert(event.target.innerHTML) &#125;, test2 (event, msg) &#123; alert(event.target.innerHTML + '---' + msg) &#125;, test3() &#123; alert('阻止事件的默认行为') &#125;, test4() &#123; alert('out') &#125;, test5() &#123; alert('inner') &#125;, test6(event) &#123; alert(event.keyCode + '---' + event.target.value) &#125; &#125; &#125;)&lt;/script&gt; 1.9. 表单输入绑定1.9.2. 使用 v-model 对表单数据自动收集1) text/textarea2) checkbox3) radio4) select 1.9.3. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div id=\"demo\"&gt; &lt;form @submit.prevent=\"handleSubmit\"&gt; &lt;span&gt;用户名: &lt;/span&gt; &lt;input type=\"text\" v-model=\"user.username\"&gt;&lt;br&gt; &lt;span&gt;密码: &lt;/span&gt; &lt;input type=\"password\" v-model=\"user.pwd\"&gt;&lt;br&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=\"radio\" id=\"female\" value=\"female\" v-model=\"user.sex\"&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" id=\"male\" value=\"male\" v-model=\"user.sex\"&gt; &lt;label for=\"male\"&gt;男&lt;/label&gt;&lt;br&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=\"checkbox\" id=\"basket\" value=\"basketball\" v-model=\"user.likes\"&gt; &lt;label for=\"basket\"&gt;篮球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"foot\" value=\"football\" v-model=\"user.likes\"&gt; &lt;label for=\"foot\"&gt;足球&lt;/label&gt; &lt;input type=\"checkbox\" id=\"pingpang\" value=\"pingpang\" v-model=\"user.likes\"&gt; &lt;label for=\"pingpang\"&gt;乒乓&lt;/label&gt;&lt;br&gt; &lt;span&gt;城市: &lt;/span&gt; &lt;select v-model=\"user.cityId\"&gt; &lt;option value=\"\"&gt;未选择&lt;/option&gt; &lt;option v-for=\"city in allCitys\" :value=\"city.id\"&gt; &#123;&#123; city.name &#125;&#125; &lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;span&gt;介绍: &lt;/span&gt; &lt;textarea v-model=\"user.desc\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#demo', data: &#123; user: &#123; username: '', pwd: '', sex: 'female', likes: [], cityId: '', desc: '', &#125;, allCitys: [&#123;id: 1, name: 'BJ'&#125;, &#123;id: 2, name: 'SZ'&#125;,&#123;id: 4, name: 'SH'&#125;], &#125;, methods: &#123; handleSubmit (event) &#123; alert(JSON.stringify(this.user)) &#125; &#125; &#125;)&lt;/script&gt; 1.10. Vue 实例生命周期1.10.2. 生命周期流程图 vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点 updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 1.10.3. vue 生命周期分析1)初始化显示 beforeCreate() created() beforeMount() mounted() 2)更新状态: this.xxx = value beforeUpdate()updated() 3)销毁 vue 实例: vm.$destory() beforeDestory()estoryed() 1.10.4. 常用的生命周期方法1) created()/mounted(): 发送 ajax 请求, 启动定时器等异步任务2) beforeDestory(): 做收尾工作, 如: 清除定时器 1.10.5. 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div&gt; &lt;button @click=\"destoryVue\"&gt;destory vue&lt;/button&gt; &lt;p v-show=\"isShowing\"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vue = new Vue(&#123; el: 'div', data: &#123; msg: '尚硅谷 IT 教育', isShowing: true, persons: [] &#125;, beforeCreate () &#123; console.log('beforeCreate() msg=' + this.msg) e.log('created() msg='+this.msg) this.intervalId = setInterval(() =&gt; &#123; console.log('-----') this.isShowing = !this.isShowing &#125;, 1000) &#125;, beforeMount () &#123; console.log('beforeMount() msg='+this.msg) &#125;, mounted () &#123; console.log('mounted() msg='+this.msg) &#125;, beforeUpdate() &#123; console.log('beforeUpdate isShowing='+this.isShowing) &#125;, updated () &#123; console.log('updated isShowing='+this.isShowing) &#125;, beforeDestroy () &#123; console.log('beforeDestroy() msg='+this.msg) clearInterval(this.intervalId) &#125;, destroyed () &#123; console.log('destroyed() msg='+this.msg) &#125;, methods: &#123; destoryVue () &#123; vue.$destroy() &#125; &#125; &#125;)&lt;/script&gt; 1.11. 过渡&amp;动画1.11.2. vue 动画的理解1) 操作 css 的 trasition 或 animation2) vue 会给目标元素添加/移除特定的 class3) 过渡的相关类名xxx-enter-active: 指定显示的 transitionxxx-leave-active: 指定隐藏的 transitionxxx-enter/xxx-leave-to: 指定隐藏时的样式 1.11.3. 基本过渡动画的编码1) 在目标元素外包裹&lt;transition name=&quot;xxx&quot;&gt;2) 定义 class 样式指定过渡样式: transition指定隐藏时的样式: opacity/其它 1.11.4. 编码 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt; .fade-enter-active, .fade-leave-active &#123; transition: opacity .5s &#125; . fade-enter, .fade-leave-to &#123; opacity: 0 &#125; / * 可以设置不同的进入和离开动画 */ .slide-fade-enter-active &#123; transition: all .3s ease; &#125; . slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0); &#125; . slide-fade-enter, .slide-fade-leave-to &#123; transform: translateX(10px); opacity: 0; &#125;&lt;/style&gt;&lt;div id=\"demo1\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle1 &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;div id=\"demo2\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle2 &lt;/button&gt; &lt;transition name=\"slide-fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo1', data: &#123; show: true &#125; &#125;) new Vue(&#123; el: '#demo2', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435361.11.5. 编码 2&lt;style&gt; .bounce-enter-active &#123; animation: bounce-in .5s; &#125; . bounce-leave-active &#123; animation: bounce-in .5s reverse; &#125; @ keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125; &#125;&lt;/style&gt;&lt;div id=\"test2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;br&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\" style=\"display: inline-block\"&gt;Look at me!&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: '#test2', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 1.12. 过滤器1.12.2. 理解过滤器1) 功能: 对要显示的数据进行特定格式化后再显示2) 注意: 并没有改变原本的数据, 可是产生新的对应的数据 1.12.3. 定义和使用过滤器1) 定义过滤器 1234Vue.filter(filterName, function(value[,arg1,arg2,...])&#123; // 进行一定的数据处理 return newValue&#125;) 2)使用过滤器 12&lt;div&gt;&#123;&#123;myData | filterName&#125;&#125;&lt;/div&gt;&lt;div&gt;&#123;&#123;myData | filterName(arg)&#125;&#125;&lt;/div&gt; 1.12.4. 编码123456789101112131415161718192021&lt;div id=\"test\"&gt; &lt;p&gt;当前时间为: &#123;&#123;currentTime&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 1 为: &#123;&#123;currentTime | dateStr&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 2 为: &#123;&#123;currentTime | dateStr('YYYY-MM-DD')&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间 3 为: &#123;&#123;currentTime | dateStr('HH:mm:ss')&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/moment.js/2.19.0/moment.js\"&gt;&lt;/script&gt;&lt;script&gt; // 注册过滤器 Vue.filter('dateStr', function (value, format) &#123; return moment(value).format(format || 'YYYY-MM-DD HH:mm:ss') &#125;) new Vue(&#123; el: '#test', data: &#123; currentTime: new Date() &#125; &#125;)&lt;/script&gt; 1.13. 内置指令与自定义指令1.13.2. 常用内置指令1) v:text : 更新元素的 textContent2) v-html : 更新元素的 innerHTML3) v-if : 如果为 true, 当前标签才会输出到页 面 4) v-else: 如果为 false, 当前标签才会输出到页面5) v-show : 通过控制 display 样式来控制显示/隐藏6) v-for : 遍历数组/对象7) v-on : 绑定事件监听, 一般简写为@8) v-bind : 强制绑定解析表达式, 可以省略 v-bind9) v-model : 双向数据绑定10) ref : 指定唯一标识, vue 对象通过$els 属性访问这个元素对象11) v-cloak : 防止闪现, 与 css 配合: [v-cloak] { display: none } 1.13.3. 自定义指令1) 注册全局指令 123Vue.directive('my-directive', function(el, binding)&#123; el.innerHTML = binding.value.toupperCase()&#125;) 2) 注册局部指令 1234567directives : &#123; 'my-directive' : &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toupperCase() &#125; &#125;&#125; 3) 使用指令 1v-my-directive='xxx' 1.13.4. 编码 1(内置指令 ）1234567891011121314151617181920212223242526272829303132&lt;style&gt; [v-cloak] &#123; display: none &#125;&lt;/style&gt;&lt;div id=\"example\"&gt; &lt;p v-text=\"url\"&gt;&lt;/p&gt; &lt;p v-html=\"url\"&gt;&lt;/p&gt; &lt;img :id=\"myid\" :src=\"imageSrc\"&gt; &lt;p&gt; &lt;span ref=\"message\"&gt;atguigu.com&lt;/span&gt; &lt;button @click=\"showMsg\"&gt;显示左侧文本&lt;/button&gt; &lt;/p&gt; &lt;p v-cloak&gt;&#123;&#123;url&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; alert('模拟加载慢') new Vue(&#123; el: '#example', data: &#123; url: '&lt;a href=\"http://www.atguigu.com\"&gt;尚硅谷&lt;/a&gt;', myid: 'abc123', imageSrc: 'http://cn.vuejs.org/images/logo.png' &#125;, methods: &#123; showMsg: function () &#123; alert(this.$refs.message.textContent) &#125; &#125; &#125;)&lt;/script&gt; 1.13.5. 编码 2(自定义指令)需求: 自定义 2 个指令 功能类型于 v-text, 但转换为全大写 功能类型于 v-text, 但转换为全小写123456789101112131415161718192021222324252627282930313233&lt;div id=\"demo1\"&gt; &lt;p v-upper-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-lower-text=\"msg\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id=\"demo2\"&gt; p v-upper-text=\"msg2\"&gt;&lt;/p&gt;&lt;p v-lower-text=\"msg2\"&gt;&lt;/p&gt; &lt;!--局部指令, 此处不能使用--&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //注册全局指令 Vue.directive('upper-text', function (el, binding) &#123; el.innerHTML = binding.value.toUpperCase() &#125;) new Vue(&#123; el: '#demo1', data: &#123; msg: 'NBA love this game!' &#125;, directives: &#123; // 注册局部指令 'lower-text': &#123; bind (el, binding) &#123; el.innerHTML = binding.value.toLowerCase() &#125; &#125; &#125; &#125;) new Vue(&#123; el: '#demo2', data: &#123; msg2: 'I Like You' &#125; &#125;)&lt;/script 1.14. 自定义插件1.14.2. 说明1) Vue 插件是一个包含 install 方法的对象2) 通过 install 方法给 Vue 或 Vue 实例添加方法, 定义全局指令等 1.14.3. 编码1) 插件 JS 12345678910111213141516171819202122/**- 自定义 Vue 插件 */(function () &#123; const MyPlugin = &#123;&#125; MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; alert('Vue 函数对象方法执行') &#125; // 2. 添加全局资源 Vue.directive('my-directive', function (el, binding) &#123; el.innerHTML = \"MyPlugin my-directive \" + binding.value &#125;) // 3. 添加实例方法 Vue.prototype.$myMethod = function () &#123; alert('vue 实例对象方法执行') &#125; &#125; window.MyPlugin = MyPlugin&#125;)() 2) 页面使用插件 1234567891011121314151617181920&lt;div id=\"demo\"&gt; &lt;!--使用自定义指令--&gt; &lt;p v-my-directive=\"ms》g\"&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"vue-myPlugin.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //使用自定义插件 Vue.use(MyPlugin) var vm = new Vue(&#123; el: '#demo', data: &#123; msg: 'atguigu' &#125; &#125;) //调用自定义的静态方法 Vue.myGlobalMethod() //调用自定义的对象方法 vm.$myMethod()&lt;/script&gt; 第 2 章： vue 组件化编码2.1. 使用 vue-cli 创建模板项目2.1.1. 说明1) vue-cli 是 vue 官方提供的脚手架工具2) github: https://github.com/vuejs/vue-cli3) 作用: 从 https://github.com/vuejs-templates 下载模板项目 2.1.2. 创建 vue 项目1npm install -g @vue/cli cli 2.x安装拉取 2.x 模板 (旧版本) Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： 1npm install -g @vue/cli-init 1234vue init webpack vue_demo(project_name)cd vue_demonpm installnpm run dev 访问: http://localhost:8080/ 2.1.3. 模板项目的结构|– build : webpack 相关的配置文件夹(基本不需要修改)|– dev-server.js : 通过 express 启动后台服务器|– config: webpack 相关的配置文件夹(基本不需要修改)|– index.js: 指定的后台服务的端口号和静态资源文件夹|– node_modules|– src : 源码文件夹|– components: vue 组件及其相关资源文件夹|– App.vue: 应用根主组件|– main.js: 应用入口 js|– static: 静态资源文件夹（build打包原封不动的放到dist文件夹中）|– .babelrc: babel 的配置文件|– .eslintignore: eslint 检查忽略的配置|– .eslintrc.js: eslint 检查的配置|– .gitignore: git 版本管制忽略的配置|– index.html: 主页面文件|– package.json: 应用包配置文件|– README.md: 应用描述说明的 readme 文件 .editorconfig配置格式 cli 3.x安装 创建项目 1vue create hello-world 在c:user/xxx/.vuerc里可以删除预设的vuecli配置 rc-&gt; run command vuecli3配置文件的查看和修改1vue ui 自定义配置文件vue.config.js 1234// vue.config.jsmodule.exports = &#123; // 选项...&#125; 2.2. 项目的打包与发布2.2.1. 打包:1npm run build 2.2.2. 发布 1: 使用静态服务器工具包npm install -g serveserve dist访问: http://localhost:5000 2.2.3. 发布 2: 使用动态 web 服务器(tomcat)修改配置: .config/index.js 123456789build: &#123; // Template for index.html index: path.resolve(__dirname, '../dist/index.html'), // Paths assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/vue_demo',&#125; 重新打包:npm run build修改 dist 文件夹为项目名称: xxx将 xxx 拷贝到运行的 tomcat 的 webapps 目录下访问: http://localhost:8080/xx 2.3. eslint2.3.1. 说明1) ESLint 是一个代码规范检查工具2) 它定义了很多特定的规则, 一旦你的代码违背了某一规则, eslint会作出非常有用的提示3) 官网: http://eslint.org/4) 基本已替代以前的 JSLint 2.3.2. ESLint 提供以下支持1) ES2) JSX3) style 检查4) 自定义错误和提示 2.3.3. ESLint 提供以下几种校验1) 语法错误校验2) 不重要或丢失的标点符号， 如分号3) 没法运行到的代码块（使用过 WebStorm 的童鞋应该了解）4) 未被使用的参数提醒5) 确保样式的统一规则， 如 sass 或者 less6) 检查变量的命名 2.3.4. 规则的错误等级有三种1) 0： 关闭规则。2) 1： 打开规则， 并且作为一个警告（信息打印黄色字体）3) 2： 打开规则， 并且作为一个错误（信息打印红色字体 ) 2.3.5. 相关配置文件1) .eslintrc.js : 全局规则配置文件‘rules’: {‘no-new’: 1}2) 在 js/vue 文件中修改局部规则/* eslint-disable no-new */new Vue({el: ‘body’,components: { App }})3) .eslintignore: 指令检查忽略的文件*.js*.vu 2.4. 组件定义与使用2.4.1. vue 文件的组成(3 个部分)1) 模板页面 123&lt;template&gt;页面模板&lt;/template&gt; 2) JS 模块对象 12345678&lt;script&gt; export default &#123; data() &#123;return &#123;&#125;&#125;, methods: &#123;&#125;, computed: &#123;&#125;, components: &#123;&#125; &#125;&lt;/script&gt; 3) 样式 1234&lt;style&gt; 样式定义&lt;/style&gt; 2.4.2. 基本使用1) 引入组件2) 映射成标签3) 使用组件标签 123456789101112&lt;template&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;hello-world&gt;&lt;/hello-world&gt;&lt;/template&gt;&lt;script&gt; import HelloWorld from './components/HelloWorld' export default &#123; components: &#123; HelloWorld &#125; &#125;&lt;/script&gt; 2.4.3. 关于标签名与标签属性名书写问题 1) 写法一: 一模一样2) 写法二: 大写变小写, 并用-连接 2.5. 组件间通信2.5.1. 组件间通信基本原则1) 不要在子组件中直接修改父组件的状态数据2) 数据在哪, 更新数据的行为(函数)就应该定义在哪 2.5.2. vue 组件间通信方式1) props2) vue 的自定义事件3) 消息订阅与发布(如: pubsub 库)4) slot5) vuex(后面单独讲) 2.6. 组件间通信 1: props2.6.1. 使用组件标签时 1&lt;my-component name='tom' :age='3' :set-name='setName'&gt;&lt;/my-component&gt; 2.6.2. 定义 MyComponent 时1) 在组件内声明所有的 props2) 方式一: 只指定名称(类型要为字符串) 1props: ['name', 'age', 'setName'] 3) 方式二: 指定名称和类型 12345props: &#123; name: String, age: Number, setNmae: Function&#125; 4) 方式三: 指定名称/类型/必要性/默认值 123props: &#123;name: &#123;type: String, required: true, default:xxx&#125;,&#125; 2.6.3. 注意1) 此方式用于父组件向子组件传递数据2) 所有标签属性都会成为组件对象的属性, 模板页面可以直接引用3) 问题:a. 如果需要向非子后代传递数据必须多层逐层传递b. 兄弟组件间也不能直接 props 通信, 必须借助父组件才可以 2.7. 组件间通信 2: vue 自定义事件子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func=\"getMsg\"&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=\"getMsg\"&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=\"x-template\" id=\"son\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"向父组件传值\" @click=\"sendMsg\" /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component('son', &#123; template: '#son', // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit('func', 'OK'); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=\"myh1\"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=\"mycom\"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 2.7.1. 绑定事件监听使用 this.$refs 来获取元素和组件 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"获取元素内容\" @click=\"getElement\" /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=\"myh1\"&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=\"mycom\"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com', &#123; template: '&lt;h5&gt;这是一个子组件&lt;/h5&gt;', data() &#123; return &#123; name: '子组件' &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 123456// 方式一: 通过 v-on 绑定@delete_todo=\"deleteTodo\"// 方式二: 通过$on()this.$refs.xxx.$on('delete_todo', function (todo) &#123; this.deleteTodo(todo)&#125;) 2.7.2. 触发事件12// 触发事件(只能在父组件中接收)this.$emit(eventName, data) 2.7.3. 注意:1) 此方式只用于子组件向父组件发送消息(数据)2) 问题: 隔代组件或兄弟组件间通信此种方式不合适 2.8. 组件间通信 3: 消息订阅与发布(PubSubJS 库)1npm install pubsub-js 1import PubSub from 'pubsub-js' 2.8.1. 订阅消息 1PubSub.subscribe('msg', function(msg, data)&#123;&#125;) 2.8.2. 发布消息 1PubSub.publish('msg', data) 2.8.3. 注意 1) 优点: 此方式可实现任意关系组件间通信(数据)2.8.4. 事件的 2 个重要操作(总结) 1) 绑定事件监听 (订阅消息)目标: 标签元素 &lt;button&gt;事件名(类型): click/focus回调函数: function(event){}2) 触发事件 (发布消息)DOM 事件: 用户在浏览器上对应的界面上做对应的操作自定义: 编码手动触发 组件间通信 插槽4: slot2.9.1. 理解此方式用于父组件向子组件传递标签数据 编译作用域父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 2.9.2. 子组件: Child.vue 1234567&lt;template&gt; &lt;div&gt; &lt;slot name=\"xxx\"&gt;不确定的标签结构 1&lt;/slot&gt; &lt;div&gt;组件确定的标签结构&lt;/div&gt; &lt;slot name=\"yyy\"&gt;不确定的标签结构 2&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 2.9.3. 父组件: Parent.vue 1234&lt;child&gt; &lt;div slot=\"xxx\"&gt;xxx 对应的标签结构&lt;/div&gt; &lt;div slot=\"yyy\"&gt;yyy 对应的标签结构&lt;/div&gt;&lt;/child&gt; 自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 第 3 章： vue-ajax3.1. vue 项目中常用的 2 个 ajax 库3.1.1. vue-resourcevue 插件, 非官方库, vue1.x 使用广泛 3.1.2. axios通用的 ajax 请求库, 官方推荐, vue2.x 使用广泛 3.2. vue-resource 的使用3.2.1. 在线文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md3.2.2. 下载 1npm install vue-resource --save 3.2.3. 编码 12345678910111213// 引入模块import VueResource from 'vue-resource'// 使用插件Vue.use(VueResource)// 通过 vue/组件对象发送 ajax 请求this.$http.get('/someUrl').then((response) =&gt; &#123;// success callbackconsole.log(response.data) //返回结果数据&#125;, (response) =&gt; &#123;// error callbacbconsole.log(response.statusText) //错误信息&#125;) 3.3. axios 的使用3.3.1. 效果ajax_test.gif3.2. 在线文档https://github.com/pagekit/vue-resource/blob/develop/docs/http.md3.3. 下载: 1npm install axios --save 3.4. 编码 12345678910// 引入模块import axios from 'axios'// 发送 ajax 请求axios.get(url).then(response =&gt; &#123;console.log(response.data) // 得到返回结果数据&#125;).catch(error =&gt; &#123;console.log(error.message)&#125; ) 第 4 章： vue UI 组件库4.1. 常用1) Mint UI:a. 主页: http://mint-ui.github.io/#!/zh-cnb. 说明: 饿了么开源的基于 vue 的移动端 UI 组件库2) Elmenta. 主页: http://element-cn.eleme.io/#/zh-CNb. 说明: 饿了么开源的基于 vue 的 PC 端 UI 组件库4.2. 使用 Mint UI4.2.1. 下载: 1npm install --save mint-ui 4.2.2. 实现按需打包 下载 1npm install --save-dev babel-plugin-component 2.修改 babel 配置 123456\"plugins\": [\"transform-runtime\",[\"component\", [ &#123; \"libraryName\": \"mint-ui\", \"style\": true &#125;]]] 4.2.3. mint-ui 组件分类 1) 标签组件 2) 非标签组件 4.2.4. 使用 mint-ui 的组件 1)index.html 1234567891011121314151617&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" /&gt;&lt;script src=\"https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js\"&gt;&lt;/scrip t&gt; &lt;script&gt; if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false); &#125; i f(!window.Promise) &#123; document.writeln('&lt;script src=\"https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js\" '+'&gt;'+'&lt;'+'/'+'script&gt;'); &#125;&lt;/script &gt; 2) main.jsimport {Button} from ‘mint-ui’Vue.component(Button.name, Button)3) App.vue 12345678910111213&lt;template&gt; &lt;mt-button @click=\"handleClick\" type=\"primary\" style=\"width: 100%\"&gt;Test&lt;/mt-button&gt;&lt;/template&gt;&lt;script&gt; import &#123;Toast&#125; from 'mint-ui' export default &#123; methods: &#123; handleClick () &#123; Toast('点击了测试'); &#125; &#125; &#125;&lt;/script&gt; 第 5 章： vue-router5.1. 理解5.1.1. 说明 1) 官方提供的用来实现 SPA 的 vue 插件2) github: https://github.com/vuejs/vue-router3) 中文文档: http://router.vuejs.org/zh-cn/4) 下载: 1npm install vue-router --save 5.1.2. 相关 API 说明1) 1234VueRouter(): 用于创建路由器的构建函数new VueRouter(&#123; // 多个配置项&#125;) 2) 路由配置 12345678910routes: [ &#123; // 一般路由 path: '/about', component: About &#125;, &#123; // 自动跳转路由 path: '/', redirect: '/about' &#125;] 3) 注册路由器 1234import router from './router'new Vue(&#123; router&#125;) 4) 使用路由组件标签 12341. &lt;router-link&gt;: 用来生成路由链接 &lt;router-link to=\"/xxx\"&gt;Go to XXX&lt;/router-link&gt;2. &lt;router-view&gt;: 用来显示当前路由组件界面 &lt;router-view&gt;&lt;/router-view&gt; 编程式路由导航1) this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) 1router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 2) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面)3) this.$router.back(): 请求(返回)上一个记录路由4) this.$router.go(-1): 请求(返回)上一个记录路由5) this.$router.go(1): 请求下一个记录路由 5.2. 基本路由5.2.2. 路由组件Home.vueAbout.vue5.2.3. 应用组件: App.vue 1234567&lt;div&gt; &lt;!--路由链接--&gt; &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;router-link to=\"/home\"&gt;Home&lt;/router-link&gt; &lt;!--用于渲染当前路由组件--&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 5.2.4. 路由器模块: src/router/index.js 12345678910111213141516171819202122232425// 声明使用vue-router插件/*内部定义并注册了2个组件标签(router-link/router-view),给组件对象添加了2个属性: 1. $router: 路由器 2. $route: 当前路由 */Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/about' &#125;, &#123; path: '/about', component: About &#125;, &#123; path: '/home', component: Home &#125; ]&#125;） 5.2.5. 注册路由器: main.js12345678import Vue from 'vue'import router from './router'// 创建 vue 配置路由器new Vue(&#123;el: '#app',router,render: h =&gt; h(app)&#125;) 5.2.6. 优化路由器配置linkActiveClass: ‘active’, // 指定选中的路由链接的 class5.2.7. 总结: 编写使用路由的 3 步 1) 定义路由组件2) 注册路由3) 使用路由 12&lt;router-link&gt;&lt;router-view&gt; 注意注册VueRouter路由是的属性不是routers是==routes== 1234567Vue.use(VueRouter)export default new VueRouter(&#123; routes: [ &#123;&#125; ]&#125;） 5.3. 嵌套路由5.3.2. 子路由组件News.vueMessage.vue 5.3.3. 配置嵌套路由: router.js123456789101112path: '/home', component: home, children: [ &#123; path: 'news', component: News &#125;, &#123; path: 'message', component: Message &#125; ] 5.3.4. 路由链接: Home.vue123&lt;router-link to=\"/home/news\"&gt;News&lt;/router-link&gt;&lt;router-link to=\"/home/message\"&gt;Message&lt;/router-link&gt;&lt;router-view&gt;&lt;/route-view 5.4. 向路由组件传递数据5.4.2. 方式 1: 路由路径携带参数(param/query)1) 配置路由 123456children: [ &#123; path: 'mdetail/:id', component: MessageDetail &#125;] 2) 路由路径 1&lt;router-link :to=\"'/home/message/mdetail/'+m.id\"&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt; 3) 路由组件中读取请求参数 123456789this.$route.params.idwatch: &#123; $route: function () &#123; // 改变当前路由组件参数数据时自动调用 console.log('$route()') const id = this.$route.params.id this.detail = messageDetails.find(detail =&gt; detail.id===id*1) &#125;&#125; $route.query 类型: Object 一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。 5.4.3. 方式 2: &lt;router-view&gt;属性携带数据1&lt;router-view :msg=\"msg\"&gt;&lt;/router-view&gt; 5.5. 缓存路由组件对象5.5.1. 理解 1) 默认情况下, 被切换的路由组件对象会死亡释放, 再次回来时是重新创建的2) 如果可以缓存路由组件对象, 可以提高用户体验5.5.2. 编码实现 123&lt;keep-alive&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 实现跳转时判断是否登录main.js 1234567891011121314151617181920212223242526272829303132router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.title) &#123; document.title = to.meta.title &#125; const flag = to.meta.withOutLogin console.log(flag) console.log(store.state.user) // 判断该路由是否需要登录权限 if (!flag &amp;&amp; !store.state.user) &#123; request(&#123; url: \"/user/info\", method: \"GET\" &#125;) .then(res =&gt; &#123; console.log(res); if(res.data.success)&#123; next() const user = res.data.extend.user; store.commit(RECEIVE_USER, &#123; user &#125;) &#125;else&#123; next('/login') &#125; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; else &#123; next() // 确保一定要有next()被调用 &#125;&#125;) 5.7 reoute.routes里的meta属性meta能给每个route指定附加值. 可以实现通过路径判断是否显示组件 1234567&#123; path: '/msite', component: Msite, meta: &#123; showFooter: true &#125;&#125; 1&lt;FooterGuide v-show=\"$route.meta.showFooter\"&gt;&lt;/FooterGuide&gt; 第 6 章： vuex6.1. vuex 理解6.1.1. vuex 是什么 1) github 站点: https://github.com/vuejs/vuex2) 在线文档: https://vuex.vuejs.org/zh-cn/3) 简单来说: 对 vue 应用中多个组件的共享状态进行集中式的管理(读/写)6.1.2. 状态自管理应用 1) state: 驱动应用的数据源 2) view: 以声明方式将 state 映射到视图3) actions: 响应在 view 上的用户输入导致的状态变化(包含 n 个更新状态的方法) 6.1.3. 多组件共享状态的问题 1) 多个视图依赖于同一状态2) 来自不同视图的行为需要变更同一状态3) 以前的解决办法a. 将数据以及操作数据的行为都定义在父组件b. 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递)4) vuex 就是用来解决这个问题的 6.2. vuex 核心概念和 API6.2.1. state1) vuex 管理的状态对像 2) 它应该是唯一的 123const state = &#123; xxx: initValue&#125; 12345import &#123; mapState, mapActions &#125; from \"vuex\";computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 6.2.2. mutations1) 包含多个直接更新 state 的方法(回调函数)的对象2) 谁来触发: action 中的 commit(‘mutation 名称’)3) 只能包含同步的代码, 不能写异步代码 12345const mutations = &#123; yyy (state, &#123;data1&#125;) &#123; // 更新 state 的某个属性 &#125;&#125; 6.2.3. actions1) 包含多个事件回调函数的对象2) 通过执行: commit()来触发 mutation 的调用, 间接更新 state3) 谁来触发: 组件中: $store.dispatch(‘action 名称’, data1) // ‘zzz’4) 可以包含异步代码(定时器, ajax) 12345const actions = &#123; zzz (&#123;commit, state&#125;, data1) &#123; commit('yyy', &#123;data1&#125;) &#125;&#125; 6.2.4. getters1) 包含多个计算属性(get)的对象2) 谁来读取: 组件中: $store.getters.xxx 123456const getters = &#123; mmm (state) &#123; return .. &#125;&#125; 6.2.5. modules1) 包含多个 module2) 一个 module 是一个 store 的配置对象3) 与一个组件(包含有共享数据)对应 6.2.6. 向外暴露 store 对象123456export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 6.2.7. 组件中123456789import &#123;mapState, mapGetters, mapActions&#125; from 'vuex'export default &#123; computed: &#123; ...mapState(['xxx']), ...mapGetters(['mmm']), &#125; m ethods: mapActions(['zzz'])&#125; &#123; &#123;xxx&#125;&#125; &#123;&#123;mmm&#125;&#125; @click=\"zzz(data)\" 6.2.8. 映射 store1234import store from './store'new Vue(&#123; store&#125; 6.2.9. store 对象1) 所有用 vuex 管理的组件中都多了一个属性$store, 它就是一个 store 对象2) 属性: 12state: 注册的 state 对象getters: 注册的 getters 对象 3) 方法:dispatch(actionName, data): 分发调用 action 6.3使用案例使用时安装 1npm install --save vuex 6.3. demo1: 计数器5.3.1 定义store模块store.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*** vuex 的 store 对象模块*/import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)/*state 对象类似于 data*/const state = &#123; count: 0 // 初始化状态数据&#125; /* mutations 对象包含个方法: 能直接更新 state一个方法就是一个 mutationmutation 只能包含更新 state 的同步代码, 也不会有逻辑mutation 由 action 触发调用: commit('mutationName') */const mutations = &#123; INCREMENT(state) &#123; state.count++ &#125;, DECREMENT (state) &#123; // ctrl + shift + x state.count-- &#125;&#125;/* actions 对象 包含个方法: 触发 mutation 调用, 间接更新 state 一个方法就是一个 action action 中可以有逻辑代码和异步代码 action 由组件来触发调用: this.$store.dispatch('actionName') */const actions = &#123; increment (&#123;commit&#125;) &#123; commit('INCREMENT') &#125;, decrement (&#123;commit&#125;) &#123; commit('DECREMENT') &#125;, incrementIfOdd (&#123;commit, state&#125;) &#123; if(state.count%2===1) &#123; commit('INCREMENT') &#125; &#125;, incrementAsync (&#123;commit&#125;) &#123; setTimeout(() =&gt; &#123; commit('INCREMENT') &#125;, 1000) &#125;&#125;/*getters 对象包含多个 get 计算计算属性方法*/const getters = &#123; oddOrEven (state) &#123; return state.count%2===0 ? '偶数' : '奇数' &#125;, count (state) &#123; return state.count &#125;&#125; //向外暴露 store 实例对象export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;） 6.3.2 在vue中注册 main.js 123456789import Vue from 'vue'import app from './app1.vue'// import app from './app.vue'import store from './store'new Vue(&#123; el: '#app', render: h =&gt; h(app), store // 所有组件都多个一个属性: $store&#125;) 6.3.3. app.vue(未优化前)12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;p&gt;clicked: &#123;&#123;$store.state.count&#125;&#125; times, count is &#123;&#123;oddOrEven&#125;&#125;&lt;/p&gt;&lt;button @click=\"increment\"&gt;+&lt;/button&gt;&lt;button @click=\"decrement\"&gt;-&lt;/button&gt;&lt;button @click=\"incrementIfOdd\"&gt;increment if odd&lt;/button&gt;&lt;button @click=\"incrementAsync\"&gt;increment async&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;computed: &#123; oddOrEven () &#123; return this.$store.getters.oddOrEven &#125;&#125;, methods: &#123; increment () &#123; this.$store.dispatch('increment') &#125;, decrement () &#123; this.$store.dispatch('decrement') &#125;, incrementIfOdd () &#123; this.$store.dispatch('incrementIfOdd') &#125;, incrementAsync () &#123; this.$store.dispatch('incrementAsync') &#125; &#125;&#125; &lt;/script&gt;&lt;style&gt; &lt;/style&gt; 6.3.4. app2.vue(优化后) 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;clicked: &#123;&#123;count&#125;&#125; times, count is &#123;&#123;oddOrEven2&#125;&#125;&lt;/p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;button @click=\"incrementIfOdd\"&gt;increment if odd&lt;/button&gt; &lt;button @click=\"incrementAsync\"&gt;increment async&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123;mapGetters, mapActions&#125; from 'vuex' export default &#123; computed: mapGetters(&#123; // 名称不一样 oddOrEven2: 'oddOrEven', count: 'count' &#125;), methods: mapActions(['increment', 'decrement', 'incrementIfOdd', 'incrementAsync']) // 名称一样 &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 6.5. vuex 结构分析 使用注意只有当前组件使用的数据不需要使用vuex管理 vue使用-me使用bootstarp1安装 需要安装jquery,因为bootstrap是依赖于jquery的。我们同样使用npm安装jquery。bootstrap也需要安装popper.js 123npm install --save jquerynpm install --save popper.jsnpm install --save bootstrap@4 2.在 vue.config.js 文件写入以下内容： 1234567891011121314151617/**Vue-CLI项目的核心配置文件*/const webpack = require(\"webpack\");module.exports = &#123; configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\", \"window.jQuery\": \"jquery\", Popper: [\"popper.js\", \"default\"] &#125;) ] &#125;&#125;; 2引入 12345678//使用bootstarpimport $ from 'jquery'import \"bootstrap/dist/css/bootstrap.css\";import \"bootstrap/dist/js/bootstrap.min.js\";new Vue(&#123; $, render: h =&gt; h(App),&#125;).$mount('#app') 使用 Font AwesomeFont Awesome：http://fontawesome.dashgame.com/ npm 安装 font-awesome 1npm install font-awesome --save-dev 1font-awesome引入在 mani.js 文件中引入 font-awesome 1import 'font-awesome/css/font-awesome.css' or 1import 'font-awesome/scss/font-awesome.scss' 1然后在组件中使用即可实现： 1&lt;span class=\"fa fa-camera-retro fa-lg\"&gt;&lt;/span&gt; vue-cli 3.x配置跨域代理1234567891011121314151617181920// vue.config.jsmodule.exports = &#123; // 修改的配置 // 将baseUrl: '/api',改为baseUrl: '/', baseUrl: '/', devServer: &#123; proxy: &#123; '/api': &#123; target: 'http://www.example.org', changeOrigin: true, ws: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125;// .env.developmentVUE_APP_BASE_API=/api vue项目使用.env文件配置全局环境变量官方文档 关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 关于文件名：必须以如下方式命名，不要乱起名，也无需专门手动控制加载哪个文件 .env 全局默认配置文件，不论什么环境都会加载合并 .env.development 开发环境下的配置文件 .env.production 生产环境下的配置文件 其他","categories":[],"tags":[{"name":"js vue","slug":"js-vue","permalink":"https://codeofli.github.io/tags/js-vue/"}]},{"title":"ssm-crud","slug":"java-note/ssm-crud/ssm-crud","date":"2019-10-21T07:25:49.000Z","updated":"2019-11-13T12:20:05.926Z","comments":true,"path":"2019/10/java-note/ssm-crud/ssm-crud/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/ssm-crud/ssm-crud/","excerpt":"[TOC]web路径 web路径： 1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题 2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名; 就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath());%&gt; $&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt;","text":"[TOC]web路径 web路径： 1.不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题 2.以/开始的开始的相对路径，找资源，以服务器为标准（http//localhost/端口号)需要加项目名; 就是http//localhost/端口号/crud/…12345&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath());%&gt; $&#123;APP_PATH&#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css --&gt; maven配置文件D:\\apache-maven-3.6.1\\conf\\settings.xml 设置镜像阿里mirrors 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 配置maven的jdk 12345678910111213&lt;profile&gt; &lt;id&gt;jdk18&lt;/id&gt; &lt;activation&gt; &lt;activaByDefault&gt;true&lt;/activaByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; maven使用spring单元测试test写在src/test/mapper/目录下 推荐Spring的项目就可以使用spring的单元测试，可以依赖注入我们需要的组件 1.导入springTest模块(meven导包) 2.@ContextConfiguration指定spring配置文件内容,@RunWith(SpringJUnit4ClassRunner.class) 3.直接autoWrited要使用的组件即可 1234567** * 测试dao工作层 * @author test */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class MapperTest &#123; mybatis不在同一目录下如果需要mapper和mapper.xml文件不在一个文件夹里还能映射成功的话，需要在spring配置文件中，分别将mapper和mapper.xml的包添加扫描； 1234567891011121314151617&lt;!-- ============配置和mybatis的整合============== --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;property name=\"dataSource\" ref=\"pooledDataSource\"&gt;&lt;/property&gt; &lt;!-- 指定mybatis的mapper文件位置 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mapper接口实现加入ioc容器 --&gt; &lt;!-- 批量生成mapper代理对象 批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写） --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.atguigu.crud.dao\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; maven中classpath路径在Maven工程中，classpath的路径指java resources路径下的目录，即 src/main/java、 src/main/resource、src/test/java 、src/test/resource 四个目录 所以在配置路径时需要注意文件名是否重名，导致加载文件失败 jsr303数据校验12345678910&lt;!--jsr303数据检验支持 （Hibernate Validator Engine Relocation Artifact） --&gt; &lt;!-- jrs303数据校验支持：tomcat7以上的服务器，tomcat7以下的服务器：el表达式，不是最新的。额外给服务器的lib包中替换新的标准的el--&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt; 数据校验JSR303Hibernate Validator JSR 303提供的标准注解如表所示。 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 表JSR 303注解 Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解，如表所示。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 表 Hibernate Validator扩展注解 使用Hibernate Validator步骤： a.jar（注意各个jar之间可能存在版本不兼容）hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jarvalidation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar b配置 1&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt; 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 c.直接使用注解 12345678public class Student &#123;```@Past//当前时间以前private Date birthday ;```&#125; ​ 在校验的Controller中 ，给校验的对象前增加 @Valid 12public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123; &#123;...&#125; mybatis分页插件PageHleper1234567891011121314151617181920212223/** * 导入jackson包 * * @author lmz * @date 2019年7月15日-上午8:59:36 * @param pageNumber * @return */ @RequestMapping(\"/emps\") @ResponseBody // 告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） public Msg getEmpsWithJson(@RequestParam(value = \"pageNumber\", defaultValue = \"1\") Integer pageNumber) &#123; // 引入分页插件PageHleper // 在查询之前调用即可 PageHelper.startPage(pageNumber, 5); // startPage之后紧跟着的查询就是分页查询 List&lt;Employee&gt; emps = employeeService.getAll(); // 用PageInfo对结果进行包装 // 将pagaInfo交给页面就可以了，封装了详细的分页信息，包括有我们的查询数据 // 传入连续显示的页数 PageInfo&lt;Employee&gt; page = new PageInfo&lt;Employee&gt;(emps, 5); return Msg.success().add(\"pageInfo\", page); &#125; sprigMVC自带HttpputFormContentFilter12345678910111213141516171819/** * 解决方案 * 要能支持直接发送PUT之类的请求，还要封装请求体中的数据 * 1、配置上HttpputFormContentFilter； * 2、作用：将请求体中的数据解析包装成一个map。 * 3、request被重新包装，request.getParameter()被重写，就会从自己封装的map中取数据 * 员工更新方法 * @param employee * @return */@PutMapping(\"/emp/&#123;empId&#125;\")@ResponseBodypublic Msg saveEmp(Employee employee,HttpServletRequest request)&#123; System.out.println(\"requestScope中的值：\"+request.getParameter(\"email\")); System.out.println(employee); employeeService.updateEmp(employee); return Msg.success();&#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"ssm","slug":"ssm","permalink":"https://codeofli.github.io/tags/ssm/"}]},{"title":"springMvc","slug":"java-note/springMvc/springMvc","date":"2019-10-20T07:24:32.000Z","updated":"2019-11-13T12:51:59.242Z","comments":true,"path":"2019/10/java-note/springMvc/springMvc/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/springMvc/springMvc/","excerpt":"[TOC]springmvc:1.jarspring-aop.jarspring-bean.jarspring-context.jarspring-core.jarspring-web.jarspring-webmvc.jarcommons-logging.jar报错NoClassDefFoundError：缺少jar","text":"[TOC]springmvc:1.jarspring-aop.jarspring-bean.jarspring-context.jarspring-core.jarspring-web.jarspring-webmvc.jarcommons-logging.jar报错NoClassDefFoundError：缺少jar 2.第一个SpringMVC程序Servet - Springmvcjsp -&gt;Servlet (Springmvc)-&gt;Jsp url springmvc配置文件 springmvc.xml选中常用的命名空间：beans aop context mvc 普通的servlet流程：请求-url-pattern -交给对应的servlet去处理 如果现在想用springmvc，而不是普通的servlet，如何告知程序？-如何让springmvc 介入程序：需要配置一个 Springmvc自带的servlet 通过以下配置，拦截所有请求，交给SpringMVC处理： 1234567891011121314 &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中：.action /:一切请求 ，注意不是 /*/user:拦截以 /user开头的请求/user/abc.do :只拦截该请求.action:只拦截 .action结尾的请求 项目中同时兼容 springMVC和Servlet 1234567891011121314&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 通过 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; 123456&lt;context:component-scan base-package=\"pers.nicolas.handler\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器(InternalResourceViewResolver) --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; 指定springmvc配置文件的路径，如果要省略，必须放到 默认路径：/WEB-INF/（web.xml配置中）servetname的值-servlet.xml 可以提示工具自动生成alt+/ ,选 映射是 去匹配@RequestMapping注解可以和方法名、类名不一致通过method指定 请求方式（get post delete put） @RequestMapping(value=”welcome”,method=RequestMethod.POST)//映射 设置name=”xxxx”的情况：params= {“name2=zs”,”age!=23”} name2:必须有name=”name2”参数 age!=23 : a.如果有name=”age”，则age值不能是23 b.没有age!name2 ：不能name=”name2”的属性 ant风格的请求路径? 单字符 任意个字符（0或多个） 任意目录 @RequestMapping(value=”welcome3/**/test”)接受示例： a href=”welcome3/abc/xyz/abccc/test” … 通过@PathVariable获取动态参数**12345@RequestMapping(value = \"welcome5/&#123;name&#125;\")public String welcome5(@PathVariable(\"name\") String name ) &#123; System.out.println(name); return \"success\" ;&#125; 1234567891011121314151617181920212223//接口/类、注解、配置@Controller@RequestMapping(\"handler\") // 映射public class SpringMVCHandler &#123; @RequestMapping(value = \"welcome\", method = RequestMethod.POST, params = &#123; \"name=zs\", \"age!=23\", \"!height\" &#125;) // 映射 public String welcome() &#123; return \"success\"; // /views/success.jsp &#125; @RequestMapping(value = \"welcome2\", headers = &#123; \"Accept=text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Encoding=gzip, deflate\" &#125;) // 映射 public String welcome2() &#123; return \"success\"; // /views/success.jsp &#125; @RequestMapping(value = \"welcome3/**/test\") public String welcome3() &#123; return \"success\"; // /views/success.jsp &#125;@RequestMapping(value = \"welcome4/&#123;name&#125;\") // 映射public String welcome4(@PathVariable(\"name\") String name) &#123; System.out.println(name); return \"success\"; // /views/success.jsp &#125;&#125; 请求方式和获取参数REST风格 ：软件编程风格 Springmvc:GET :查POST ：增DELETE ：删PUT ：改 普通浏览器 只支持get post方式 ；其他请求方式 如 delelte|put请求是通过 过滤器新加入的支持。 springmvc实现 ：put|post请求方式的步骤a.增加过滤器 123456789&lt;!-- 增加HiddenHttpMethodFilte过滤器：目的是给普通浏览器 增加 put|delete请求方式 --&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilte&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; b.表单 1234&lt;form action=\"handler/testRest/1234\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\"/&gt; &lt;input type=\"submit\" value=\"删\"&gt;&lt;/form&gt; i:必须是post方式ii:通过隐藏域 的value值 设置实际的请求方式 DELETE|PUT c.控制器 123456@RequestMapping(value=\"testRest/&#123;id&#125;\",method=RequestMethod.DELETE)public String testDelete(@PathVariable(\"id\") Integer id) &#123; System.out.println(\"delete：删 \" +id); //Service层实现 真正的增 return \"success\" ;//默认使用了请求转发的跳转方式&#125; 通过 method=RequestMethod.DELETE 匹配具体的请求方式 此外，可以发现 ，当映射名相同时@RequestMapping(value=”testRest)，可以通过method处理不同的请求。 过滤器中 处理put|delete请求的部分源码： 1234567891011protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;HttpServletRequest requestToUse = request; if (\"POST\".equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123; String paramValue = request.getParameter(this.methodParam); if (StringUtils.hasLength(paramValue)) &#123; requestToUse = new HttpMethodRequestWrapper(request, paramValue); &#125; &#125; filterChain.doFilter(requestToUse, response);&#125; 原始请求：request，改请求默认只支持get post header但是如果 是”POST” 并且有隐藏域 则，过滤器 将原始的请求 request加入新的请求方式DELETE，并将原始请求 转为 requestToUse 请求（request+Delete请求）最后将requestToUse 放入 请求链中， 后续再事情request时 实际就使用改造后的 requestToUse 获取参数方法2@RequestParam(“uname”) String name,@RequestParam(value=”uage”,required=false,defaultValue=”23”) @RequestParam(“uname”):接受前台传递的值，等价于request.getParameter(“uname”); required=false:该属性 不是必须的。defaultValue=”23”：默认值23 获取请求头信息 @RequestHeaderpublic String testRequestHeader(@RequestHeader(“Accept-Language”) String al ) { 通过@RequestHeader(“Accept-Language”) String al 获取请求头中的Accept-Language值，并将值保存再al变量中 通过mvc获取cookie值（JSESSIONID）@CookieValue(前置知识： 服务端在接受客户端第一次请求时，会给该客户端分配一个session （该session包含一个sessionId）),并且服务端会在第一次响应客户端时 ，请该sessionId赋值给JSESSIONID 并传递给客户端的cookie中 小结： SpringMVC处理各种参数的流程/逻辑：请求： 前端发请求a-&gt; @RequestMappting(“a”)处理请求中的参数xyz： @RequestMappting(“a”) public String aa(@Xxx注解(“xyz”) xyz) { }使用对象（实体类Student）接受请求参数12345 @RequestMapping(value = \"testObjectProperties\") // 映射public String testObjectProperties(Student student) &#123; //student属性必须和from表单中的属性name值一致（支持级联属性） System.out.println(student); return \"success\"; &#125; 1234567&lt;form action=\"handler/testObjectProperties\" method=\"post\"&gt; id:&lt;input type=\"text\" name=\"id\"&gt;&lt;br/&gt; name:&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; homeAddress:&lt;input type=\"text\" name=\"address.homeAddress\"&gt;&lt;br/&gt; schoolAddress:&lt;input type=\"text\" name=\"address.schoolAddress\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;br/&gt;&lt;/form&gt; 在SpringMVC中使用原生态的Servlet APIHttpServletRequest ：直接将 servlet-api中的类、接口等 写在springMVC所映射的方法参数中即可： 12345@RequestMapping(value=\"testServletAPI\")public String testServletAPI(HttpServletRequest request,HttpServletResponse response) &#123; System.out.println(request); return \"success\" ;&#125; 1.处理模型数据如果跳转时需要带数据：V、M,则可以使用以下方式：ModelAndView、ModelMap 、Map(java.tuil.map)、Model -数据放在了request作用域 @SessionAttributes、@ModelAttribute 示例：public String testModel(Model model| Map&lt;String,Object&gt; m) { m.put(x,”..”); 就会将x对象 放入request域中 1234567891011121314151617@RequestMapping(value = \"testModelAndView\")public ModelAndView testModelAndView() &#123; // ModelAndView:既有数据，又有视图 ModelAndView mv = new ModelAndView(\"success\"); Student student = new Student(); student.setId(3); student.setName(\"zs\"); mv.addObject(\"student\", student); // 相当于request.setAtrribute(); return mv;&#125;@RequestMapping(value = \"testModelMap\") // 映射public String testModelMap(ModelMap mm) &#123; Student student1 = new Student(); student1.setId(3); student1.setName(\"zs\"); mm.put(\"student1\", student1); // request域 return \"success\"; // view&#125; 如何将上述数据放入session中？@SessionAttributes(..)在类上声明 1@SessionAttributes(value = &#123;\"student3\",\"student2\"&#125;) //如果在request域中存放studen3,student2对象，则同时放在session域中 1@SessionAttributes(types =&#123;Student.class,Address.class&#125;) //如果在request域中存放student,address类的对象，则同时放在session域中 @ModelAttributei.经常在 更新时使用ii.在不改变原有代码的基础之上，插入一个新方法。 通过@ModelAttribute修饰的方法 ，会在每次请求前先执行；并且该方法的参数map.put()可以将 对象 放入 即将查询的参数中；必须满足的约定：map.put(k,v) 其中的k 必须是即将查询的方法参数 的首字母小写testModelAttribute(Student xxx) ，即student；如果不一致，需要通过@ModelAttribute声明。如下： 1234567891011121314151617@ModelAttribute//在任何一次请求前，都会先执行@ModelAttribute修饰的方法// 在请求该类的每个方法前均会被调用的设计是基于一个思想：一个控制器一个功能public void queryStudentById(Map&lt;String,Object&gt; map) &#123; //模拟调用三层查询数据库的操作 Student student = new Student(); student.setId(31); student.setName(\"zs\"); student.setAge(23); map.put(\"stu\", student) ;//约定：map的key 就是方法参数 类型的首字母小写&#125;//修改:Zs-ls@RequestMapping(value=\"testModelAttribute\")public String testModelAttribute(@ModelAttribute(\"stu\")Student student) &#123; student.setName(student.getName());//将名字修改为ls System.out.println(student.getId()+\",\"+student.getName()+\",\"+student.getAge()); return \"success\";&#125; 一个Servlet 对应一个功能：增删改查 对应于 4个Servlet 更新： Servlet - SpringMVC的Controller 查询@ModelAttributepublic void query(){ } 修改public String update(){ } @ModelAttribute会在 该类的每个方法执行前 均被执行一次，因为使用时需要注意。 2.视图、视图解析器视图的顶级接口:View视图解析器：ViewResolver 常见的视图和解析器：InternalResourceView、InternalResourceViewResolver public class JstlView extends InternalResourceView： springMVC解析jsp时 会默认使用InternalResourceView，如果发现Jsp中包含了jstl语言相关的内容，则自动转为JstlView。 JstlView 可以解析jstl\\实现国际化操作 国际化： 针对不同地区、不同国家 ，进行不同的显示 中国:（大陆、香港） 欢迎美国： welcome i18n_zh_CN.propertiesresource.welcome=你好resource.exit=退出 i18n.properties 具体实现国际化步骤：a.创建资源文件基名_语言_地区.properties基名_语言.properties 常见的资源文件命名 资源文件名 简介 基名_en.properties 所有英文语言的资源 基名_en_US.properties 针对美国地区、英文语言的资源 基名_zh.properties 所有的中文语言的资源 基名_zh_CN.properties 针对中国大陆的、中文语言的资源 基名_zh_HK.properties 针对中国香港的、中文语言的资源 基名.properties 默认资源文件。如果请求相应语言的资源文件不存在，将使用此资源文件。例如，若是中国大陆地区用户，应该访问“基名_zh_CN.properties”，而如果不存在此文件，就会去访问默认的“基名.properties”。 b.配置springmvc.xml，加载资源文件 12345&lt;!-- 加载国际化资源文件 1.将ResourceBundleMessageSource在程序加载时 加入springmvc： springmvc在启动时，会自动查找一个叫messageSource的bean，如果有则自动加载 2.如果配置了ResourceBundleMessageSource，程序会在响应时介入 --&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basename\" value=\"i18n\"&gt;&lt;/property&gt;&lt;/bean&gt; ResourceBundleMessageSource会在springmvc响应程序时 介入（解析国际化资源文件） c.通过jstl使用国际化 jstl.jar standar.jar springmvc在启动时，会自动查找一个id=”messageSource”的bean，如果有 则自动加载 InternalResourceViewResolver其他功能：1.&lt;mvc:view-controller …&gt;index.jsp -&gt; Controller(@RequsetMapping(“a”)) -&gt;succes.jsp 要用SpringMVC实现：index.jsp -&gt; succes.jsp ： 12&lt;!-- view-name也会被视图解析器添加前缀和后缀 --&gt;&lt;mvc:view-controller path=\"testMvcViewController\" view-name=\"success\"/&gt; 以上注解 ，会让所有的请求 转入mvc:..中匹配映射地址，而会忽略调@RequsetMapping()；如果想让 @RequsetMapping(“a”) 和mvc:..共存，则需要加入一个注解：&lt;1234```xml&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 2.指定请求方式指定跳转方式：return “forward:/views/success.jsp”; forward(请求转发): redirect（重定向）: ，需要注意 此种方式，不会被视图解析器加上前缀(/views)、后缀(.jsp) 3.处理静态资源：html css js 图片 视频可以与用户交互、因为时间/地点的不同 而结果不同的内容：动态（百度：天气 ） 在SpringMVC中，如果直接访问静态资源：404 。原因：之前将所有的请求 通过通配符“/” 拦截，进而交给 SPringMVC的入口DispatcherServlet去处理：找该请求映射对应的 @requestMapping http://localhost:8888/SpringMVCProject/img.png @RequsetMapping(“img.png”)return sucess 解决：如果是 需要mvc处理的，则交给@RequsetMapping(“img.png”)处理；如果不需要springmvc处理，则使用 tomcat默认的Servlet去处理。tomcat默认的Servlet去处理：如果有 对应的请求拦截,则交给相应的Servlet去处理；如果没有对应的servlet，则直接访问。tomcat默认的Servlet在哪里？在tomcat配置文件\\conf\\web.xml中 &lt;servlet&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;servlet-class&gt;xxx.xxx.xx.ABCServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;abc&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;解决静态资源方案：如果有springmvc对应的@requestMapping则交给spring处理；如果没有对应@requestMapping,则交给服务器tomcat默认的servlet去处理 ：实现方法，只需要增加2个注解即可 springmvc.xml： 1234&lt;!-- 该注解会让springmvc在接受请求没有对应映射时，将该请求交给服务器默认的servlet处理(直接访问) --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 总结：要让springmvc访问静态资源，只需要加入以下2个注解： 1234&lt;!-- 该注解会让springmvc在接受请求没有对应映射时，将该请求交给服务器默认的servlet处理(直接访问) --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--此配置是springmvc的基础配置，很多功能都需要该注解来调整 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 4.类型转换a.Spring自带一些 常见的类型转换器：public String testDelete(@PathVariable(“id”) String id) ，即可以接受int类型数据id 也可以接受String类型的id b.可以自定义类型转换器i.编写 自定义类型转器的类 （实现Converter接口） 123456789101112public class MyConverter implements Converter&lt;String,Student&gt;&#123;@Override public Student convert(String source) &#123;//source:2-zs-23 //source接受前端传来的String:2-zs-23 String[] studentStrArr = source.split(\"-\") ; Student student = new Student(); student.setId( Integer.parseInt( studentStrArr[0]) ); student.setName(studentStrArr[1]); student.setAge(Integer.parseInt(studentStrArr[2] )); return student; &#125;&#125; ii.配置：将MyConverter加入到springmvc中 1234567891011121314&lt;!-- 1将 自定义转换器 纳入SpringIOC容器 --&gt; &lt;bean id=\"myConverter\" class=\"org.lanqiao.converter.MyConverter\"&gt;&lt;/bean&gt;&lt;!-- 2将myConverter再纳入 SpringMVC提供的转换器Bean --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;ref bean=\"myConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 3将conversionService注册到annotation-driven中 --&gt;&lt;!--此配置是SpringMVC的基础配置，很功能都需要通过该注解来协调 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt;&lt;/mvc:annotation-driven&gt; 测试转换器： 1234@RequestMapping(value=\"testConverter\")public String testConverter(@RequestParam(\"studentInfo\") Student student) &#123;// 前端：2-zs-23 System.out.println(student.getId()+\",\"+student.getName()+\",\"+student.getAge()); return \"success\"; &#125; 其中@RequestParam(“studentInfo”)是触发转换器的桥梁：@RequestParam(“studentInfo”)接受的数据 是前端传递过来的：2-zs-23 ，但是 需要将该数据 复制给 修饰的目的对象Student；因此SPringMVC可以发现 接收的数据 和目标数据不一致，并且 这两种数据分别是 String、Student,正好符合public Student convert(String source)转换器。 5.数据格式化​ SimpleDateForamt sdf = new SimpleDateFormat(“yyyy-MM-dd hh:mm:ss”);SPringMVC提供了很多注解，方便我们数据格式化实现步骤：a.配置 123456789&lt;!-- 配置数据格式化注解所依赖的beanFormattingConversionServiceFactoryBean既能实现数据日期格式化，又能实现类型转换 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\" &gt; &lt;set&gt; &lt;ref bean=\"myConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; b.通过注解使用 12@DateTimeFormat(pattern = \"yyyy-MM-dd\") //接受前台传来的数据，转换为日期private Date birthday;//相应实体bean的属性 1234567891011@RequestMapping(value=\"testDateTimeStringFormat\")//如果student的格式化错误，会将错误转入BindingResult中public String testDateTimeStringFormat(Student student,BindingResult result) &#123; System.out.println(student); if(result.getErrorCount() &gt; 0) &#123; for (FieldError error : result.getFieldErrors()) &#123; System.out.println(error.getDefaultMessage()); &#125; &#125; return \"success\";&#125; @NumberFormat(parttern=”###,#”) 1.错误消息：public String testDateTimeFormat(Student student, BindingResult result ,Map&lt;String,Object&gt; map) {需要验证的数据是 Student中的birthday, SPringMVC要求 如果校验失败 则将错误信息自动放入该对象之后紧挨着的 BindingResult中。即Student student, BindingResult result之间 不能有其他参数。 如果要将控制台的错误消息 传到jsp中显示，则可以将 错误消息对象放入request域中，然后 在jsp中 从request中获取。 2.数据校验JSR303Hibernate Validator JSR 303提供的标准注解如表所示。 注解 简介 @Null 被注释的元素必须为 null。 @NotNull 被注释的元素必须不为 null。 @AssertTrue 被注释的元素必须为 true。 @AssertFalse 被注释的元素必须为 false。 @Min(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @Max(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于或等于value。 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于或等于value。 @Size(max, min) 被注释的元素的取值范围必须是介于min和max之间。 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内。 @Past 被注释的元素必须是一个过去的日期。 @Future 被注释的元素必须是一个将来的日期。 @Pattern(value) 被注释的元素必须符合指定的正则表达式。 表JSR 303注解 Hibernate Validator 是JSR 303的扩展。Hibernate Validator 提供了 JSR 303中所有内置的注解，以及自身扩展的4个注解，如表所示。 注解 简介 @Email 被注释的元素值必须是合法的电子邮箱地址。 @Length 被注释的字符串的长度必须在指定的范围内。 @NotEmpty 被注释的字符串的必须非空。 @Range 被注释的元素必须在合适的范围内。 表 Hibernate Validator扩展注解 使用Hibernate Validator步骤： a.jar（注意各个jar之间可能存在版本不兼容）hibernate-validator-5.0.0.CR2.jar classmate-0.8.0.jar jboss-logging-3.1.1.GA.jarvalidation-api-1.1.0.CR1.jar hibernate-validator-annotation-processor-5.0.0.CR2.jar b配置 1&lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt; 此时mvc:annotation-driven的作用：要实现Hibernate Validator/JSR303 校验（或者其他各种校验），必须实现SpringMVC提供的一个接口：ValidatorFactory LocalValidatorFactoryBean是ValidatorFactory的一个实现类。&lt;mvc:annotation-driven &gt;会在springmvc容器中 自动加载一个LocalValidatorFactoryBean类，因此可以直接实现数据校验。 c.直接使用注解 123public class Student &#123;​ @Past//当前时间以前private Date birthday ;​12&#125; ​ 在校验的Controller中 ，给校验的对象前增加 @Valid 12public String testDateTimeFormat(@Valid Student student, BindingResult result ,Map&lt;String,Object&gt; map) &#123; &#123;...&#125; 3.Ajax请求SpringMVC，并且JSON格式的数据a.jarjackson-annotations-2.8.9.jarjackson-core-2.8.9.jarjackson-databind-2.8.9.jar b。@ResponseBod修饰的方法，会将该方法的返回值 以一个json数组的形式返回给前台 ​ 123456789101112131415@ResponseBody//告诉SpringMVC，此时的返回 不是一个 View页面，而是一个 ajax调用的返回值（Json数组） @RequestMapping(value=\"testJson\") public List&lt;Student&gt; testJson() &#123; //Controller-Service-dao //StudentService studentService = new StudentServiceImp();// List&lt;Student&gt; students = studentService.qeuryAllStudent(); //模拟调用service的查询操作... List&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(stu1) ; students.add(stu2) ; students.add(stu3) ; return students; &#125; 前台：服务端将返回值结果 以json数组的形式 传给了result。 1234567891011$(\"#testJson\").click(function()&#123; //通过ajax请求springmvc $.post( \"handler/testJson\",//服务器地址 //&#123;\"name\":\"zs\",\"age\":23&#125; function(result)&#123;//服务端处理完毕后的回调函数 List&lt;Student&gt; students， 加上@ResponseBody后， students实质是一个json数组的格式 for(var i=0;i&lt;result.length ;i++)&#123; alert(result[i].id +\"-\"+result[i].name +\"-\"+result[i].age); &#125; &#125; ); 1.SpringMVC实现文件上传：和Servlet方式的本质一样，都是通过commons-fileupload.jar和commons-io.jarSpringMVC可以简化文件上传的代码，但是必须满足条件：实现MultipartResolver接口 ；而该接口的实现类SpringMVC也已经提供了CommonsMultipartResolver 具体步骤：（直接使用CommonsMultipartResolver实现上传）a.jar包commons-fileupload.jar、commons-io.jarb.配置CommonsMultipartResolver将其加入SpringIOC容器 12345678&lt;!-- 配置CommonsMultipartResolver,用于实现文件上传 springIoc容器在初始化时，会自动Id=\"multipartResolver\"的bean，并自动加入容器中 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;!-- 上传单个文件的最大值，单位Byte;如果-1，表示无限制 --&gt; &lt;property name=\"maxUploadSize\" value=\"102400\"&gt;&lt;/property&gt;&lt;/bean&gt; c.处理方法 12345678910111213141516171819//文件上传处理方法@RequestMapping(value=\"testUpload\") //abc.pngpublic String testUpload(@RequestParam(\"desc\") String desc , @RequestParam(\"file\") MultipartFile file ) throws IOException &#123; System.out.println(\"文件描述信息：\"+desc); //jsp中上传的文件：file InputStream input = file.getInputStream() ;//IO String fileName = file.getOriginalFilename() ; OutputStream out = new FileOutputStream(\"d:\\\\\"+fileName) ; byte[] bs = new byte[1024]; int len = -1; while(( len = input.read(bs)) !=-1 ) &#123; out.write(bs, 0, len); &#125; out.close(); input.close(); //将file上传到服务器中的 某一个硬盘文件中 System.out.println(\"上传成功！\"); return \"success\";&#125; 123456&lt;!-- enctype=\"mulipart/form-data\"告诉浏览器我是要上传文件不是普通的请求 --&gt;&lt;form action=\"handler/testUpload\" method=\"post\" enctype=\"mulipart/form-data\"&gt; describe:&lt;input type=\"text\" name=\"desc\"&gt;&lt;br /&gt; file:&lt;input type=\"file\" name=\"file\"&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;br /&gt;&lt;/form&gt; 框架： 将原来自己写的1000行代码，变成：框架帮你写900行，剩下100行自己写 控制器：handler servlet controller action 2拦截器拦截器的原理和过滤器相同。SpringMVC：要想实现拦截器，必须实现一个接口HandlerInterceptor ctrl+shift+r ：自己编写的代码.java .jsp .htmlctrl+shift+t ：jar中的代码 a.编写拦截器implements HandlerInterceptorb.配置：将自己写的拦截器 配置到springmvc中（spring） 1234&lt;!-- 将自己写的拦截器 配置到springmvc中（spring）,默认拦截全部请求 --&gt;&lt;mvc:interceptors &gt; &lt;bean class=\"pers.nicolas.interceptor.MyInterceptor\"&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt; 1234567891011&lt;!-- 将自己写的拦截器 配置到springmvc中（spring）,默认拦截全部请求 --&gt;&lt;mvc:interceptors &gt; &lt;!-- 配置具体的拦截路径 --&gt; &lt;mvc:interceptor&gt; &lt;!--指定拦截的路径，ant风格 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--指定不拦截的路径，ant风格 --&gt; &lt;mvc:exclude-mapping path=\"/handler/testInterceptor\"/&gt; &lt;bean class=\"pers.nicolas.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 拦截器1拦截请求- 拦截器2拦截请求 - 请求方法 - 拦截器2处理相应-拦截器1处理相应- 拦截器2的afterCompletion()拦截-拦截器1的afterCompletion()拦截 如果有多个拦截器，则每个拦截器的preHandle postHandle afterCompletion都会在相应时机各被触发一次. 3.异常处理SpringMVC： HandlerExceptionResolver接口， 该接口的每个实现类 都是异常的一种处理方式： a.@ExceptionHandler注解ExceptionHandler,ExceptionResolver： 主要提供了@ExceptionHandler注解，并通过该注解处理异常 123456//该方法 可以捕获本类中 抛出的ArithmeticException异常@ExceptionHandler(&#123;ArithmeticException.class,ArrayIndexOutOfBoundsException.class &#125;)public String handlerArithmeticException(Exception e) &#123; System.out.println(e +\"============\"); return \"error\" ;&#125; @ExceptionHandler标识的方法的参数 必须在异常类型(Throwable或其子类) ，不能包含其他类型的参数(Model可以，可以查看官方文档) 异常处理路径：最短（接近的）优先如果有方法抛出一个ArithmeticException异常，而该类中 有2个对应的异常处理法你发： 12345@ExceptionHandler(&#123;Exception.class &#125;)public ModelAndView handlerArithmeticException2(Exception e) &#123;&#125;@ExceptionHandler(&#123;ArithmeticException.class &#125;)public ModelAndView handlerArithmeticException1(Exception e) &#123;&#125; 则优先级： 最短（接近的）优先。 @ExceptionHandler默认只能捕获 当前类中的异常方法。如果发生异常的方法 和处理异常的方法 不在同一个类中：@ControllerAdvice 总结：如果一个方法用于处理异常，并且只处理当前类中的异常：@ExceptionHandler 如果一个方法用于处理异常，并且处理所有类中的异常： 类前加@ControllerAdvice、 处理异常的方法前加@ExceptionHandler b.@ResponseStatusResponseStatusExceptionResolver：自定义异常显示页面 @ResponseStatus 1234567891011@ResponseStatus(value=HttpStatus.FORBIDDEN,reason=\"数组越界222!!!\")public class MyArrayIndexOutofBoundsException extends Exception &#123;//自定义异常&#125;@RequestMapping(\"testMyException\") public String testMyException(@RequestParam(\"i\") Integer i) throws MyArrayIndexOutofBoundsException &#123; if(i == 3) &#123; throw new MyArrayIndexOutofBoundsException();//抛出异常 &#125; return \"success\" ;&#125; 12345678910111213@RequestMapping(\"testMyException2\")public String testMyException2(@RequestParam(\"i\") Integer i) &#123; if(i == 3) &#123; return \"redirect:testResponseStatus\" ;//跳转到某一个 异常处理方法里 &#125; return \"success\" ;&#125;@ResponseStatus(value = HttpStatus.CONFLICT, reason = \"test exception！\")@RequestMapping(\"testResponseStatus\")public String testResponseStatus()&#123; return \"success\";&#125; c.DefaultHandlerExceptionResolver异常处理的实现类：DefaultHandlerExceptionResolver:SPringMVC在一些常见异常的基础上（300 500 404），新增了一些异常，例如： @see org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler @see #handleNoSuchRequestHandlingMethod @see #handleHttpRequestMethodNotSupported ：如果springmvc的处理方法限制为post方式，如果实际请求为get,则会触发此异常显示的页面 @see #handleHttpMediaTypeNotSupported @see #handleMissingServletRequestParameter @see #handleServletRequestBindingException @see #handleTypeMismatch @see #handleHttpMessageNotReadable @see #handleHttpMessageNotWritable @see #handleMethodArgumentNotValidException @see #handleMissingServletRequestParameter @see #handleMissingServletRequestPartException @see #handleBindException d.SimpleMappingExceptionResolver：通过配置来实现异常的处理 12345678910111213141516&lt;!--SimpleMappingExceptionResolver:以配置的方式处理异常 --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;!-- 如果发生异常，异常对象会被保存在 exceptionAttribute的value值中；并且会放入request域中 ；异常变量的默认值是 exception--&gt; &lt;!--&lt;property name=\"exceptionAttribute\" value=\"exception\"&gt;&lt;/property&gt;--&gt; &lt;property name=\"exceptionMappings\"&gt; &lt;props&gt; &lt;!-- 相当于catch(ArithmeticException ex)&#123; 跳转：error &#125; --&gt; &lt;prop key=\"java.lang.ArithmeticException\"&gt; error &lt;/prop&gt; &lt;prop key=\"java.lang.NullPointerException\"&gt; error &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; SSM整合：Spring - SpringMVC - MyBatis 1.Spring - MyBatis : 需要整合：将MyBatis的SqlSessionFactory 交给Spring 2Spring - SpringMVC ： 就是将Spring - SpringMVC 各自配置一遍 思路： SqlSessionFactory -&gt; SqlSession -&gt;StudentMapper -&gt;CRUD可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring SM整合步骤：1.jarmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jarspring-context-support.jar spring-core.jar spring-context.jarspring-beans.jar spring-aop.jar spring-web.jar commons-logging.jarcommons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar 2.类-表 Student类 -student表 3.-（与Spring整合时，conf.xml可省）–MyBatis配置文件conf.xml（数据源、mapper.xml） –可省，将该文件中的配置 全部交由spring管理 spring配置文件 applicationContext.xml 4.通过mapper.xml将 类、表建立映射关系 5.之前使用MyBatis: conf.xml -&gt;SqlSessionFacotry 1234567891011&lt;!-- web项目中，spring介入项目 --&gt;&lt;!-- needed for ContextLoaderListener --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中 配置Spring配置文件（applicationContext.xml） （Web项目）：web.xml 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 6.使用Spring整合MyBatis ：将MyBatis的SqlSessionFactory 交给Spring 注意xml文件路径有classpath:存在,和整合sm最大不同 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 加载db.properties文件 --&gt;&lt;bean id=\"config\" class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 数据库信息(替代了mybatis中的配置文件conf.xml) --&gt;&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- cof.xml: 数据源、mapper.xml --&gt;&lt;!-- 在SpringIoc容器中 创建Mybatis的核心类SqlSessionFactory --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;!-- 加载mapper.xml配置文件 --&gt; &lt;!-- 注意有classpath:存在,和整合sm最大不同 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:pers/nicolas/mapper/*.xml\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将mybatis的SqlSessionFactory交给spring --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;!-- xxxxMapper --&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt;&lt;/bean&gt; 7.继续整合SpringMVC：将springmvc加入项目即可a.加入SpringMVC需要的jarspring-webmvc.jar b.给项目加入SpringMVC支持web.xml: dispatcherServlet（alt+/） 1234567891011121314151617&lt;!-- web项目整合springmvc --&gt;&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-controller.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; c.编写springmvc配置文件：applicationContext-controller.xml：视图解析器、基础配置 12345678910&lt;!-- 将控制器所在的包加入springIOC容器 --&gt;&lt;context:component-scan base-package=\"pers.nicolas.controller\"&gt;&lt;/context:component-scan&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- springMVC基础配置、标配 --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; d.示例","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"springMvc","slug":"springMvc","permalink":"https://codeofli.github.io/tags/springMvc/"}]},{"title":"spring","slug":"java-note/spring/spring","date":"2019-10-19T07:23:24.000Z","updated":"2019-11-13T12:20:17.181Z","comments":true,"path":"2019/10/java-note/spring/spring/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/spring/spring/","excerpt":"2002 Rod Johnon Spring 2003 ,IOC AopSpring data,spring boot,spring cloud,spring framework ,spring social [TOC]IOC :控制反转（DI：依赖注入）1.搭建Spring环境下载jarhttp://maven.springframework.org/release/org/springframework/spring/spring-framework-4.3.9.RELEASE-dist.zip开发spring至少需要使用的jar(5个+1个):spring-aop.jar 开发AOP特性时需要的JARspring-beans.jar 处理Bean的jar spring-context.jar 处理spring上下文的jar spring-core.jar spring核心jarspring-expression.jar spring表达式三方提供的日志jarcommons-logging.jar 日志","text":"2002 Rod Johnon Spring 2003 ,IOC AopSpring data,spring boot,spring cloud,spring framework ,spring social [TOC]IOC :控制反转（DI：依赖注入）1.搭建Spring环境下载jarhttp://maven.springframework.org/release/org/springframework/spring/spring-framework-4.3.9.RELEASE-dist.zip开发spring至少需要使用的jar(5个+1个):spring-aop.jar 开发AOP特性时需要的JARspring-beans.jar 处理Bean的jar spring-context.jar 处理spring上下文的jar spring-core.jar spring核心jarspring-expression.jar spring表达式三方提供的日志jarcommons-logging.jar 日志 2.编写配置文件为了编写时有一些提示、自动生成一些配置信息：方式一：增加sts插件可以给eclipse增加 支持spring的插件：spring tool suite(https://spring.io/tools/sts/all)下载springsource-tool-suite-3.9.4.RELEASE-e4.7.3a-updatesite.zip,然后在Eclipse中安装：Help-Install new SoftWare.. - Add 方式二： 直接下载sts工具（相当于一个集合了Spring tool suite的Eclipse）: https://spring.io/tools/sts/ 新建：bean configuration .. - applicationContext.xml 3.开发Spring程序(IOC)123ApplicationContext conext = new ClassPathXmlApplicationContext(\"applicationContext.xml\") ; //执行从springIOC容器中获取一个 id为student的对象Student student = (Student)conext.getBean(\"student\") ; 可以发现，springioc容器 帮我们new了对象，并且给对象赋了值 SpringIOC发展史：1.Student student = new Student();student.setXxx(); 2.简单工厂 3.ioc （超级工厂） IOC（控制反转,Inversion of Control）也可以称之为DI（依赖注入,Dependency Injection）：控制反转：将 创建对象、属性值 的方式 进行了翻转，从new、setXxx() 翻转为了 从springIOC容器getBean()依赖注入：将属性值 注入给了属性，将属性 注入给了bean，将bean注入给了ioc容器； ​总结：ioc/di ，无论要什么对象，都可以直接去springioc容器中获取，而不需要自己操作（new\\setXxx()） 因此之后的ioc分为2步：1 先给springioc中存放对象并赋值 2 拿 DI:依赖注入 ，Teacher Course : cname teacher IOC容器赋值：如果是简单类型（8个基本+String），value； 如果是对象类型，ref=”需要引用的id值”，因此实现了 对象与对象之间的依赖关系 conext.getBean(需要获取的bean的id值) 依赖注入3种方式：1.set注入：通过setXxx()赋值赋值，默认使用的是 set方法();依赖注入底层是通过反射实现的。&lt;property…&gt; 2.构造器注入：通过构造方法赋值 需要注意：如果 的顺序 与构造方法参数的顺序不一致，则需要通过type或者index或name指定。 3.p命名空间注入1234引入p命名空间 xmlns:p=\"http://www.springframework.org/schema/p\"&lt;bean id=\"course\" class=\"org.lanqiao.entity.Course\" p:courseHour=\"300\" p:courseName=\"hadoop\" p:teacher-ref=\"teacher\"&gt; 本质也是反射 简单类型： p:属性名=”属性值”引用类型（除了String外）： p:属性名-ref=”引用的id”注意多个 p赋值的时候 要有空格。 注意：无论是String还是Int/short/long，在赋值时都是 value=”值” ，当参数重载时默认为String优先因此建议 此种情况 需要配合 name\\type进行区分 示例： 注入各种集合数据类型: List Set map properties set、list、数组 各自都有自己的标签 ，但是也可以混着用 ###value与注入方式的区别： 使用子元素注入 而使用value属性注入 参数值位置 写在首尾标签（）的中间(不加双引号) 写在value的属性值中（必须加双引号） type属性 有（可选） 可以通过type属性指定数据类型 无 参数值包含特殊字符（&lt;， &amp;）时的处理方法 两种处理方法。 一、使用标记 二、使用XML预定义的实体引用 一种处理方法。即使用XML预定义的实体引用 其中，XML预定义的实体引用，如表所示。 实体引用 表示的符号 &lt; &lt; &amp; &amp; &gt; &gt; 给对象类型赋值null ： 123&lt;property name=\"name\" &gt; &lt;null/&gt; --&gt;注意 没有&lt;value&gt; &lt;/property&gt; 赋空值 “” 123&lt;property name=\"name\" &gt; &lt;value&gt;&lt;/value&gt; &lt;/property&gt; 在ioc中定义bean的前提：该bean的类 必须提供了 无参构造 4.自动装配（只适用于 ref类型 ）：​ 约定优于配置 自动装配：&lt;bean … class=”org.lanqiao.entity.Course” autowire=”byName|byType|constructor|no” &gt; byName本质是byIdbyName: 自动寻找：其他bean的id值=该Course类的属性名byType: 其他bean的类型(class) 是否与 该Course类的ref属性类型一致 （注意，此种方式 必须满足：当前Ioc容器中 只能有一个Bean满足条件 ）constructor： 其他bean的类型(class) 是否与 该Course类的构造方法参数 的类型一致；此种方式的本质就是byType 可以在头文件中 一次性将该ioc容器的所有bean 统一设置成自动装配：&lt;beans xmlns=”http://www.springframework.org/schema/beans&quot;…default-autowire=”byName”&gt; 自动装配虽然可以减少代码量，但是会降低程序的可读性，使用时需要谨慎。 使用注解定义bean：通过注解的形式 将bean以及相应的属性值 放入ioc容器 1&lt;context:component-scan base-package=\"pers.nicolas.aop\"&gt;&lt;/context:component-scan&gt; 在启动的时候，会根据base-package在 该包中扫描所有类，查找这些类是否有注解@Component(“studentDao”),如果有，则将该类 加入spring Ioc容器。 @Component细化： dao层注解：@Repositoryservice层注解：@Service控制器层注解：@Controller 12345678910@Service(\"StudentService\") //注意添加scan扫描包public class StudentServiceImpl implements IStudentService&#123; @Autowired //自动装配，byType @Qualifier(\"stuDao\") // byIdName IStudentDao studentDao = new StudentDaoImp(); public void setStudentDao(IStudentDao studentDao) &#123; this.studentDao = studentDao; &#125;&#125; 使用注解实现事务（声明式事务） 目标：通过事务 使以下方法 要么全成功、要么全失败public void addStudent(){ //增加班级 //增加学生 //crdu} a. jar包spring-tx-4.3.9.RELEASEojdbc.jarcommons-dbcp.jar 连接池使用到数据源commons-pool.jar 连接池spring-jdbc-4.3.9.RELEASE.jaraopalliance.jar b.配置jdbc\\mybatis\\spring增加事务tx的命名空间 123456789101112131415161718192021&lt;!-- 配置数据库 --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"oracle.jdbc.OracleDriver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:MLDN\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"scott\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"tigger\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"10\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"6\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器txManager --&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 增加对事务的支持 --&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; c.使用 将需要 成为事务的方法 前增加注解：@Transactional(readOnly=false,propagation=Propagation.REQUIRED) AOP：面向方面编程一个普通的类 -&gt; 有特定功能的类 a.继承类 b.实现接口 c.注解 d.配置 public class MyFilter exntends/implements Xx{ } 类 -&gt; “通知” ：实现接口 前置通知实现步骤：ThrowsAdvice a.jar aopaliance.jar aspectjweaver.jar b.配置 c.编写 aop：每当之前add()之前 自动执行一个方法log(); addStudent(); 业务方法（IStudentService.java中的 addStudent()） before(); 自动执行的通知，即aop前置通知12345678910111213&lt;!-- 前置通知类 --&gt; &lt;bean id=\"LogBefore\" class=\"pers.nicolas.aop.LogBefore\"&gt; &lt;/bean&gt; &lt;!-- 将方法和通知进行关联 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=\"execution(public void pers.nicolas.service.StudentServiceImpl.deleteStudentByNo(int)) or execution(public void pers.nicolas.service.StudentServiceImpl.addStudent(pers.nicolas.entity.Student))\" id=\"pointcut\" /&gt; &lt;!-- advisor相当于连接切入点和切面的线 --&gt; &lt;aop:advisor advice-ref=\"LogBefore\" pointcut-ref=\"pointcut\" /&gt;&lt;/aop:config&gt; 表达式expression的常见示例如表所示。expression=*”execution(…)”* 举例 含义 public boolean addStudent(org.lanqiao.entity.Student)) 所有返回类型为boolean、参数类型为org.lanqiao.entity.Student的addStudent()方法。 public boolean org.lanqiao.service.IStudentService. addStudent(org.lanqiao.entity.Student) org.lanqiao.service.IStudentService类（或接口）中的addStudent()方法，并且返回类型是boolean、参数类型是org.lanqiao.entity.Student public * addStudent(org.lanqiao.entity.Student) “*”代表任意返回类型 public void *( org.lanqiao.entity.Student) “*”代表任意方法名 public void addStudent(..) “..”代表任意参数列表 * org.lanqiao.service..(..) org.lanqiao.service.IStudentService包中，包含的所有方法（不包含子包中的方法） * org.lanqiao.service...(..) org.lanqiao.service.IStudentService包中，包含的所有方法（包含子包中的方法） execution(* com.atguigu.crud.service..*(..)) expression常见示例 org.lanqiao.service org.lanqiao.service.impl public class Xxx{ @Test a(){}} 如果出现异常：类似java.lang.NoClassDefFoundError: org/apache/commons/pool/impl/GenericObjectPool则说明缺少jar 后置通知：AfterReturningAdvice a.通知类 ，普通实现接口b.业务类、业务方法 StudentServiceImpl中的addStudent()c.配置： 将业务类、通知 纳入springIOC容器 定义切入点（一端）、定义通知类（另一端），通过pointcut-ref将两端连接起来 异常通知：ThrowsAdvice ​ 根据异常通知接口的定义可以发现，异常通知的实现类 必须编写以下方法：​ public void afterThrowing([Method, args, target], ThrowableSubclass)： a.public void afterThrowing(Method, args, target, ThrowableSubclass) b.public void afterThrowing( ThrowableSubclass)环绕通知：MethodInterceptor 在目标方法的前后、异常发生时、最终等各个地方都可以 进行的通知，最强大的一个通知； 可以获取目标方法的 全部控制权（目标方法是否执行、执行之前、执行之后、参数、返回值等） 在使用环绕通知时，目标方法的一切信息 都可以通过invocation参数获取到环绕通知 底层是通过拦截器实现的。 1234567891011121314151617public Object invoke(MethodInvocation invocation) throws Throwable &#123; Object result = null; try &#123; System.out.println(\"around advice[before advice]\"); // invocation.proceed()之前后的代码：前后置通知 result = invocation.proceed();// 控制目标方法的执行 xxx(),result就是目标方法的返回值 // invocation.proceed()之后的代码：后置通知 System.out.println(\"\"); System.out .println(\"around advice[after advice]: traget object :\" + invocation.getThis() + \", function name:=\" + invocation.getMethod().getName() + \",returnValue=\" + result + \",args=\" + invocation.getArguments()); &#125; catch (Exception e) &#123; // 异常通知 System.out.println(\"around advice[exception advice]\"); &#125; return result; &#125; 二、实现注解实现 通知 aopa.jar 与 实现接口 的方式相同b.配置 将业务类、通知 纳入springIOC容器 开启注解对AOP的支持aop:aspectj-autoproxy 业务类 addStudent - 通知 c.编写 通知：@Aspect //声明该类 是一个 通知public class LogBeforeAnnotation { } 注意：通过注解形式 将对象增加到 ioc容器时，需要设置 扫描器&lt;context:component-scan base-package=”org.lanqiao.aop”&gt; 扫描器 会将 指定的包 中的 @Componet @Service @Respository @Controller修饰的类产生的对象 增加到IOC容器中@Aspect不需要 加入扫描器，只需要开启即可：aop:aspectj-autoproxy 通过注解形式 实现的aop，如果想获取 目标对象的一些参数，则需要使用一个对象：JoinPoint 注解形式的返回值：a.声明返回值 的参数名： @AfterReturning( pointcut= “execution(public * addStudent(..))” ,returning=”returningValue” ) public void myAfter(JoinPoint jp,Object returningValue) {//returningValue是返回值，但需要告诉spring System.out.println(“返回值：”+returningValue );注解形式实现aop时，通知的方法的参数不能多、少 实现接口形式、注解形式 只捕获声明的特定类型的异常，而其他类型异常不捕获。cath() 1234567891011121314151617181920212223242526272829303132333435363738394041@Component(\"logAnnotaiton\")@Aspect // 声明此类是一个通知public class LogAopAnnotation &#123; //前置通知 @Before(\"execution(public * addStudent(..))\") // 属性：定义切点 public void MyBefore(JoinPoint jp) &#123; System.out.println(\"&lt;[Annotation]前置 advice&gt;: target object:\" + jp.getTarget() + \",methodName:\" + jp.getSignature().getName() + \",arguments:\" + Arrays.toString(jp.getArgs())); &#125; //后置通知 @AfterReturning(pointcut = \"execution(public * addStudent(..))\",returning = \"returningValue\") // 属性：定义切点,要得到返回值必须通过注解声明 public void AfterReturning(JoinPoint jp,Object returningValue) &#123; System.out.println(\"&lt;[Annotation]后置advice&gt; target object:\" + jp.getTarget() + \",methodName:\" + jp.getSignature().getName() + \",arguments:\" + Arrays.toString(jp.getArgs())+\",returnVlaue:\"+returningValue); &#125; //Exception Advice:如果只捕获指定异常，可以通过通过注解throwing指定 @AfterThrowing(pointcut = \"execution(public * addStudent(..))\",throwing = \"e\") public void MyException(JoinPoint jp,NullPointerException e) &#123; System.out.println(\"&lt;[Annotation]exception advice&gt; e:\"+e.getMessage()); &#125; //环绕通知,参数ProceedingJoinPoint @Around(\"execution(public * addStudent(..))\") public void MyAroud(ProceedingJoinPoint jp)&#123; try &#123; System.out.println(\"&lt;[Annotation【Around】]前置 advice&gt;\"); //方法之前，前置通知 jp.proceed();//方法执行 //方法之后，后前置通知 System.out.println(\"&lt;[Annotation【Around】]后置 advice&gt;\"); &#125;catch(Throwable e) &#123;//方法异常，异常通知 System.out.println(\"&lt;[Annotation【Around】]exception advice&gt;\"); &#125;finally &#123;//最终执行，最终通知 System.out.println(\"&lt;[Annotation【Around】]最终 advice&gt;\"); &#125; &#125; //最终通知 @After(\"execution(public * addStudent(..))\") public void MyAfter() &#123; System.out.println(\"&lt;[Annotation]最终advice&gt;\"); &#125;&#125; 三、通过 配置将 类-&gt;通知基于Schema配置类似 于 实现接口的方式 接口方式通知：public class LogAfter implements AfterReturningAdviceSchema方式通知： a.编写一个普通类 public class LogAfter {} b.将该类 通过配置，转为一个“通知” 如果要获取目标对象信息：注解、schema：JoinPoint接口：Method method, Object[] args, Object target schema形式 和注解形式相似，不同之处： 注解形式 使用了注册@After， schmema形式进行了多余的配置 12345678910111213141516&lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=\"execution(public void pers.nicolas.service.StudentServiceImpl.addStudent(pers.nicolas.entity.Student))\" id=\"pointcut_schema\" /&gt; &lt;!-- schema方式 --&gt; &lt;aop:aspect ref=\"LogSchema\"&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:after-returning method=\"afterReturning\" returning=\"returnValue\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:after-throwing method=\"MyException\" throwing=\"e\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;aop:around method=\"around\" pointcut-ref=\"pointcut_schema\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 1.Spring开发Web项目 及 拆分Spring配置文件a.Spring开发Web项目 Web项目如何初始化SpringIOC容器 ：思路：当服务启动时（tomcat），通过监听器将SpringIOC容器初始化一次（该监听器 spring-web.jar已经提供） 因此用spring开发web项目 至少需要7个jar： spring-java的6个jar + spring-web.jar，注意：web项目的jar包 是存入到WEB-INF/lib中 web项目启动时 ，会自动加载web.xml，因此需要在web.xml中加载 监听器（ioc容器初始化）。 Web项目启动时，启动实例化Ioc容器： 1234567891011121314&lt;!-- 指定 Ioc容器（applicationContext.xml）的位置--&gt; &lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;!-- 配置spring-web.jar提供的监听器，此监听器 可以在服务器启动时 初始化Ioc容器。 初始化Ioc容器（applicationContext.xml） ， 1.告诉监听器 此容器的位置：context-param 2.默认约定的位置 :WEB-INF/applicationContext.xml --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; b.拆分Spring配置文件​ java项目：​ applicationContext1.xml​ applicationContext2.xml​ applicationContext3.xml ApplicationContext conext = new ClassPathXmlApplicationContext(“applicationContext3.xml”) ; Web项目： 根据什么拆分？ i.三层结构 UI(html/css/jsp 、Servlet) applicationController.xml Service :applicationService.xml Dao:applicationDao.xml 公共 数据库:applicationDB.xml ii.功能结构 学生相关配置 applicationContextStudent.xml 班级相关配置 applicationContextClass.xml 合并：如何将多个配置文件 加载 （1） 12345678910&lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-Dao.xml, classpath:applicationContext-Service.xml, classpath:applicationContext-Controller.xml &lt;/param-value&gt;&lt;/context-param&gt; ​ （2）推荐 12345678&lt;context-param&gt; &lt;!-- 监听器的父类ContextLoader中有一个属性contextConfigLocation，该属性值 保存着 容器配置文件applicationContext.xml的位置 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml, classpath:applicationContext-*.xml &lt;/param-value&gt;&lt;/context-param&gt; （3）只在web.xml中加载主配置文件， 123&lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; ​ 然后在主配置问加中，加载其他配置文件: 1&lt;import resource=\"applicationContext-*.xml\"/&gt; Web项目： 2.Spring整合MyBatisSpring - MyBatis 思路： SqlSessionFactory -&gt; SqlSession -&gt;StudentMapper -&gt;CRUD可以发现 ，MyBatis最终是通过SqlSessionFactory来操作数据库，Spring整合MyBatis 其实就是 将MyBatis的SqlSessionFactory 交给Spring SM整合步骤：1.jarmybatis-spring.jar spring-tx.jar spring-jdbc.jar spring-expression.jarspring-context-support.jar spring-core.jar spring-context.jarspring-beans.jar spring-aop.jar spring-web.jar commons-logging.jarcommons-dbcp.jar ojdbc.jar mybatis.jar log4j.jar commons-pool.jar 2.类-表 3.MyBatis配置文件conf.xml 4.通过mapper.xml将 类、表建立映射关系 5.之前使用MyBatis: conf.xml -&gt;SqlSessionFacotry 现在整合的时候，需要通过Spring管理SqlSessionFacotry ，因此 产生qlSessionFacotry 所需要的数据库信息 不在放入conf.xml 而需要放入spring配置文件中 配置Spring配置文件（applicationContext.xml） 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 加载db.properties文件 --&gt; &lt;bean id=\"config\"class=\"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;array&gt; &lt;value&gt;classpath:db.properties&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 数据库信息(替代了mybatis中的配置文件conf.xml) --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxIdle\" value=\"$&#123;maxIdle&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 在SpringIoc容器中 创建mybatis的核心类SqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;!-- 加载mybatis配置文件，如果只有映射，不需要写conf.xml文件--&gt;&lt;!-- &lt;property name=\"configLocation\" value=\"classpath:conf.xml\"&gt;&lt;/property&gt; --&gt; &lt;!-- 加载mapper.xml配置文件 --&gt; &lt;property name=\"mapperLocations\" value=\"pers/nicolas/mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 第3种方式批量生成mapper代理对象批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写）--&gt;&lt;bean id=\"mappers\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 6.使用Spring-MyBatis整合产物开发程序 目标：通过spring产生mybatis最终操作需要的 动态mapper对象(StudentMapper对象) Spring产生 动态mapper对象 有3种方法： a.第一种方式DAO层实现类 继承 SqlSessionDaoSupport类 1234567 SqlSessionDaoSupport类提供了一个属性 SqlSession &lt;!-- 第一种方式生成mapper代理对象 --&gt;&lt;bean id=\"studentMapper\" class=\"pers.nicolas.dao.impl.StudentDaoImpl\"&gt;&lt;!-- 将Spring配置的sqlSessionFactory交给Mapper（Dao) --&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; b.第二种方式 就是省略掉 第一种方式的 实现类 直接MyBatis提供的 Mapper实现类：org.mybatis.spring.mapper.MapperFactoryBean 缺点：每个mapper都需要一个配置一次 12345&lt;!-- 第二种方式生成mapper代理对象 --&gt;&lt;bean id=\"studentMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"mapperInterface\" value=\"pers.nicolas.mapper.StudentMapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; c.第三种方式 批量配置 实现类 1234567&lt;!-- 第3种方式批量生成mapper代理对象批量产生的mapper对象在SpringIOC容器中的id值默认就是接口mapper名(首字母小写）--&gt;&lt;bean id=\"mappers\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"pers.nicolas.mapper\"&gt;&lt;/property&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; # spring注解版一个接口指定实现类接口定义 12345package com.yoj.used;public interface MyInterface &#123; void className();&#125; 实现类1 1234567@Service(\"impl1\")public class Implement1 implements MyInterface&#123; @Override public void className() &#123; System.out.println(Implement1.class); &#125;&#125; 实现类2 1234567@Service(\"impl2\")public class Implement2 implements MyInterface &#123; @Override public void className() &#123; System.out.println(Implement2.class); &#125;&#125; 1.@AutoWired+@Qualifier(“impl2”)指定 123@Autowired@Qualifier(\"impl2\")MyInterface myInterface; 2.使用@Resource注入，根据@Service指定的名称区分 12@Resource(name = \"impl2\")MyInterface myInterface; my同一类中内部调用aop失效","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://codeofli.github.io/tags/spring/"}]},{"title":"springBoot","slug":"java-note/springBoot/springBoot","date":"2019-10-17T07:27:48.000Z","updated":"2019-11-13T12:20:19.839Z","comments":true,"path":"2019/10/java-note/springBoot/springBoot/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/springBoot/springBoot/","excerpt":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架；整个Spring技术栈的一个大整合；J2EE开发的一站式解决方案； 2、微服务2014，martin fowler微服务：架构风格（服务微化）一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 ##环境准备谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入注意：即使指定了对象加载的配置文件，但是如果主配置文件中存在该对象并能成功解析，那么直接使用先找到的对象，application.properties&gt;application.yml 配置文件 12345678910111213person:# lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 last-name: zhangsan javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； *@ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;······ 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码12345678910111213#diea properties默认使用utf-8#配置person的值person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=false#对象person.maps.k1=v1 person.maps.k2=14#listperson.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件是yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 注意：即使指定了对象加载的配置文件，但是如果主配置文件中存在该对象并能成功解析，那么直接使用先找到的对象，application.properties&gt;application.yml 使用@PropertySource也需要@ConfigurationProperties(prefix = “person”)注解 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"$&#123;person.last-name&#125;\") private String lastName; //@Value(\"#&#123;11*2&#125;\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 123456789@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;)//导入Spring的配置文件让其生效@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot02ConfigApplication.class, args); &#125;&#125; 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值12345678910person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c#hello默认值person.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 12#2.0以上版本java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.servlet.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports(){AutoConfigurationImportSelector类中}方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 1HttpProperties.class 新版本已更名 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223242526272829//springboot新版本============================CONDITIONS EVALUATION REPORT=====================================================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 9、常用配置属性123#视图解析器前后缀spring.mvc.view.prefix=/WEB-INF/spring.mvc.view.suffix=.jsp 使用@ConditionalOnProperty来控制Configuration是否生效1. 简介 Spring Boot通过@ConditionalOnProperty来控制Configuration是否生效 2. 说明12345678910111213141516171819@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Documented@Conditional(OnPropertyCondition.class)public @interface ConditionalOnProperty &#123; String[] value() default &#123;&#125;; //数组，获取对应property名称的值，与name不可同时使用 String prefix() default &quot;&quot;;//property名称的前缀，可有可无 String[] name() default &#123;&#125;;//数组，property完整名称或部分名称（可与prefix组合使用，组成完整的property名称），与value不可同时使用 String havingValue() default &quot;&quot;;//可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置 boolean matchIfMissing() default false;//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之报错 boolean relaxedNames() default true;//是否可以松散匹配，至今不知道怎么使用的 &#125; &#125; 3. 使用方法 通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。 4. code12345678910111213@Configuration//在application.properties配置\"mf.assert\"，对应的值为true@ConditionalOnProperty(prefix=\"mf\",name = \"assert\", havingValue = \"true\")public class AssertConfig &#123; @Autowired private HelloServiceProperties helloServiceProperties; @Bean public HelloService helloService()&#123; HelloService helloService = new HelloService(); helloService.setMsg(helloServiceProperties.getMsg()); return helloService; &#125;&#125; 5. 收获springboot注解丰富，我们可以利用好这些注解来实现我们自定义的starter配置，减少硬编码的校验，降低组件间的耦合性!!! 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用(配置）；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%nSpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== java/resources都是内路径的根路径（classpath） 12345\"classpath:/META-INF/resources/\", \"classpath:/resources/\",\"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc http://localhost:8080/asserts/js/Chart.min.js ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 12#定义自己的静态资源文件夹spring.resources.static-locations=classpath:/hello/,classpath:/atguigu/ 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=\"$&#123;session.user&#125;： &lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter（@deprecate）类型；不能标注@EnableWebMvc==; 实现接口WebMvcConfigurer为2支持 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter; &#125; ==2.0以上版本会拦截静态资源== 12345678//静态文件@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //静态文件 registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\"); //webjar文件 registry.addResourceHandler(\"/webjars/**\").addResourceLocations(\"/webjars/\");&#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE thymeleaf默认为classpath:/templates/xxx.html 123 // thymeleaf默认就会拼串// classpath:/templates/xxxx.htmlreturn \"emp/list\"; 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;\" href=\"#\" th:href=\"@&#123;/main.html&#125;\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; // redirect: 表示重定向到一个地址 /代表当前项目路径// forward: 表示转发到一个地址 thymeleaf的视图解析器代码 123456789101112131415161718192021222324252627282930313233public class ThymeleafViewResolver extends AbstractCachingViewResolver implements Ordered &#123;@Override protected View createView(final String viewName, final Locale locale) throws Exception &#123; // First possible call to check \"viewNames\": before processing redirects and forwards if (!this.alwaysProcessRedirectAndForward &amp;&amp; !canHandle(viewName, locale)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; &#125; // Process redirects (HTTP redirects) if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" is a redirect, and will not be handled directly by ThymeleafViewResolver.\", viewName); final String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length(), viewName.length()); final RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()); return (View) getApplicationContext().getAutowireCapableBeanFactory().initializeBean(view, viewName); &#125; // Process forwards (to JSP resources) if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123; // The \"forward:\" prefix will actually create a Servlet/JSP view, and that's precisely its aim per the Spring // documentation. See http://docs.spring.io/spring-framework/docs/4.2.4.RELEASE/spring-framework-reference/html/mvc.html#mvc-redirecting-forward-prefix vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" is a forward, and will not be handled directly by ThymeleafViewResolver.\", viewName); final String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length(), viewName.length()); return new InternalResourceView(forwardUrl); &#125; // Second possible call to check \"viewNames\": after processing redirects and forwards if (this.alwaysProcessRedirectAndForward &amp;&amp; !canHandle(viewName, locale)) &#123; vrlogger.trace(\"[THYMELEAF] View \\\"&#123;&#125;\\\" cannot be handled by ThymeleafViewResolver. Passing on to the next resolver in the chain.\", viewName); return null; &#125; vrlogger.trace(\"[THYMELEAF] View &#123;&#125; will be handled by ThymeleafViewResolver and a \" + \"&#123;&#125; instance will be created for it\", viewName, getViewClass().getSimpleName()); return loadView(viewName, locale); &#125; springboot在WebMvcAutoConfiguration.java中默认配置的格式是 1234/** * Date format to use. For instance, `dd/MM/yyyy`. */private String dateFormat; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:value=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function()&#123; //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 123456789101112* Default implementation of &#123;@link ErrorAttributes&#125;. Provides the following attributes * when possible: * &lt;ul&gt; * &lt;li&gt;timestamp - The time that the errors were extracted&lt;/li&gt; * &lt;li&gt;status - The status code&lt;/li&gt; * &lt;li&gt;error - The error reason&lt;/li&gt; * &lt;li&gt;exception - The class name of the root exception (if configured)&lt;/li&gt; * &lt;li&gt;message - The exception message&lt;/li&gt; * &lt;li&gt;errors - Any &#123;@link ObjectError&#125;s from a &#123;@link BindingResult&#125; exception * &lt;li&gt;trace - The exception stack trace&lt;/li&gt; * &lt;li&gt;path - The URL path when the exception was raised&lt;/li&gt; * &lt;/ul&gt; ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 1234567891011121314@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125;//1、浏览器客户端返回的都是json//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 123BasicErrorController中获取状态码的方法protected HttpStatus getStatus(HttpServletRequest request) &#123; Integer statusCode = (Integer) request.getAttribute(\"javax.servlet.error.status_code\"); 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、（html）页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 12345678910111213141516171819202122@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125;//2.0以上版本=============== @Bean //一定要将这个定制器加入到容器中public WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; aa()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableServletWebServerFactory server) &#123; server.setPort(9000); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 2.0版本 ![](E:\\pictures\\Language\\spring boot\\images\\configurable继承.png) 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；2.0springboot的autoConfigure类： 12345678910111213141516171819202122232425262728293031@Configuration@ConditionalOnWebApplication@EnableConfigurationProperties(ServerProperties.class)public class EmbeddedWebServerFactoryCustomizerAutoConfiguration &#123; /** * Nested configuration if Tomcat is being used. */ @Configuration @ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;) public static class TomcatWebServerFactoryCustomizerConfiguration &#123; @Bean public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) &#123; return new TomcatWebServerFactoryCustomizer(environment, serverProperties); &#125; &#125; @Configuration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, ServletWebServerFactoryConfiguration.EmbeddedJetty.class, ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)public class ServletWebServerFactoryAutoConfiguration &#123; EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor WebServerFactoryCustomizerBeanPostProcessor（2.0版本） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器//2.0版本 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof WebServerFactory) &#123; postProcessBeforeInitialization((WebServerFactory) bean); &#125; return bean; &#125; private Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;&gt;(getWebServerFactoryCustomizerBeans()); this.customizers.sort(AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers; &#125; 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 123456789101112131415161718192021222324public class SpringApplication &#123;protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( \"Unable create a default ApplicationContext, \" + \"please specify an ApplicationContextClass\", ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass); &#125; 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 1private void createWebServer()//2.0版本 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); 1ServletWebServerFactory factory = getWebServerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory(TomcatServletWebServerFactory)创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 1this.webServer = factory.getWebServer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 12345public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;this.onRefresh(); // 创建servlet容器this.registerListeners();this.finishBeanFactoryInitialization(beanFactory); //创建我们自己定义的bean组件 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer ![](E:\\pictures\\Language\\spring boot\\images\\ServletContainerInitializer目录.png) 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 123456789//自己的SpringBootServletInitializer的子类重写了configure方法public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker详见docker.md 六.SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 12345678910spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC driver-class-name: com.mysql.jdbc.Driver com.mysql.cj.jdbc.Drive Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； 1//class com.zaxxer.hikari.HikariDataSource 2.0版本默认使用 ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； 1DataSourceInitializerInvoker 2.0版本还包括了这个类 ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 12345678910111213141516171819202122schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.31.39:3307/jdbc driver-class-name: com.mysql.cj.jdbc.Driver #DDL schema: - classpath:department.sql #DML data: - classpath:insert-dept.sql #2.0需要开启 initialization-mode: always 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 3、整合MyBatis123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt;#2.0注释 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id);//声明自增主键，这样就能拿到自增的主键值 @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789//使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 1234567891011121314//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；@JsonIgnoreProperties(&#123;\"handler\",\"hibernateLazyInitializer\"&#125;)//解决json报错public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 //打印控制台图标 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println(\"SpringApplicationRunListener...starting...\"); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println(\"SpringApplicationRunListener...finished...\"); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println(\"ApplicationRunner...run....\"); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie //结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"atguigu.hello\")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples Springboot 部署jar包(官方推荐)jar包方式启动，也就是使用spring boot内置的tomcat运行。服务器上面只要你配置了jdk1.8及以上，就ok。不需要外置tomcat1.打成jar包 2.将jar包放到任意目录，执行下面的命令 1234567$ nohup java -jar test.jar &gt;temp.txt &amp;nohup java -jar yoj.jar &gt;yoj.txt &amp;ubuntu@VM-0-5-ubuntu:~$ java -Dfile.encoding=utf-8 -jar yoj-0.0.1-SNAPSHOT.jar &gt; yoj.txt &amp;java -Dfile.encoding=utf-8 -jar -Dserver.port=8080 xxx.jar //这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。 nohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令： 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 案例\\1. nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 \\2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 服务器注意事项1.mysql字符集需要设置为utf-82.spring boot 的control==@RequestMapping字符串必须由“/”开始== 不然本地能访问，但是服务器不能访问 1@RequestMapping(\"/set/&#123;pageNumber&#125;\") return 不能加斜杆 return “problem/set”; spring boot 加密导入jar包123456&lt;!-- https://mvnrepository.com/artifact/com.github.ulisesbocchio/jasypt-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; jasypt.encryptor. password: 加密密码的字符串 123456789jasypt: encryptor: password: lmz#配置数据源spring: datasource: url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC username: root password: 123456 编写测试类 12345678910111213141516171819202122232425262728package com.yoj;import org.jasypt.encryption.StringEncryptor;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class EncryptTest &#123; @Autowired StringEncryptor encryptor; @Test public void test()&#123; String userName = encryptor.encrypt(\"root\"); System.out.println(userName); String password = encryptor.encrypt(\"123456\"); System.out.println(password); String originUserName = encryptor.decrypt(\"2IL6K8NI+eUHYpu8AsfB7Q==\"); System.out.println(originUserName); String originPassword = encryptor.decrypt(\"+u6jN11/Ykzl5kHU0rg2Ew==\"); System.out.println(originPassword); &#125;&#125; 将得到的加密串，写到数据库配置 123456789jasypt: encryptor: password: lmz#配置数据源spring: datasource: url: jdbc:mysql://localhost:3306/yoj?serverTimezone=UTC username: ENC(&#123;2IL6K8NI+eUHYpu8AsfB7Q==&#125;) password: NEC(&#123;vojGG7u7QZ3mN1DsX1gA1g==&#125;) 常见问题test测试插入，数据并没有保存到数据库使用junit测试插入，测试显示成功，但是数据并没有保存到数据库。是因为在junit下，插入数据会自动回滚，所以测试显示成功但实际上不能插入。若要插入到数据库，只需在测试方法上添加@Rollback(false)注解即可。","categories":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"springBoot","slug":"springBoot","permalink":"https://codeofli.github.io/tags/springBoot/"}]},{"title":"python-crawler","slug":"python/python-crawler/python-crawler","date":"2019-10-16T13:27:10.000Z","updated":"2019-11-13T12:20:22.616Z","comments":true,"path":"2019/10/python/python-crawler/python-crawler/","link":"","permalink":"https://codeofli.github.io/2019/10/python/python-crawler/python-crawler/","excerpt":"requests库requests库的安装http://www.python-requests.org Win平台: “以管理员身份运行” cmd，执行 pip install requests requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get(url, params=None, **kwargs) 获取HTML网页的主要方法，对应于HTTP的GET requests.head(url, **kwargs) 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post(url, data=None, json=None, **kwargs) 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put(url, data=None, **kwargs) 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch(url, data=None, **kwargs) 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete(url, **kwargs) 向HTML页面提交删除请求，对应于HTTP的DELETE","text":"requests库requests库的安装http://www.python-requests.org Win平台: “以管理员身份运行” cmd，执行 pip install requests requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get(url, params=None, **kwargs) 获取HTML网页的主要方法，对应于HTTP的GET requests.head(url, **kwargs) 获取HTML网页头信息的方法，对应于HTTP的HEAD requests.post(url, data=None, json=None, **kwargs) 向HTML网页提交POST请求的方法，对应于HTTP的POST requests.put(url, data=None, **kwargs) 向HTML网页提交PUT请求的方法，对应于HTTP的PUT requests.patch(url, data=None, **kwargs) 向HTML网页提交局部修改请求，对应于HTTP的PATCH requests.delete(url, **kwargs) 向HTML页面提交删除请求，对应于HTTP的DELETE requests库的get方法： requests.get(url, params=None, kwargs)∙ url : 拟获取页面的url链接∙ params : url中的额外参数，字典或字节流格式，可选∙ kwargs: 12个控制访问的参数 123456789101112def get(url, params=None, **kwargs): r\"\"\"Sends a GET request. :param url: URL for the new :class:`Request` object. :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`. :param \\*\\*kwargs: Optional arguments that ``request`` takes. :return: :class:`Response &lt;Response&gt;` object :rtype: requests.Response \"\"\" kwargs.setdefault('allow_redirects', True) return request('get', url, params=params, **kwargs) 主要方法解析requests.request(method, url, kwargs)∙ method : 请求方式，对应get/put/post等7种∙ url : 拟获取页面的url链接∙ kwargs: 控制访问的参数，共13个 method : 请求方式 1234567r = requests.request('GET', url, **kwargs)r = requests.request('HEAD', url, **kwargs)r = requests.request('POST', url, **kwargs)r = requests.request('PUT', url, **kwargs)r = requests.request('PATCH', url, **kwargs)r = requests.request('delete', url, **kwargs)r = requests.request('OPTIONS', url, **kwargs) \\kwargs: 控制访问的参数，均为可选项**params : 字典或字节序列，作为参数增加到url中data : 字典、字节序列或文件对象，作为Request的内容 json : JSON格式的数据，作为Request的内容 headers : 字典， HTTP定制头 cookies : 字典或CookieJar， Request中的cookie auth : 元组，支持HTTP认证功能 files : 字典类型，传输文件 timeout : 设定超时时间，秒为单位 proxies : 字典类型，设定访问代理服务器，可以增加登录认证 allow_redirects : True/False，默认为True，重定向开关stream : True/False，默认为True，获取内容立即下载开关verify : True/False，默认为True，认证SSL证书开关cert : 本地SSL证书路径 Response对象Response对象包含服务器返回的所有信息，也包含请求的Request信息 Response 对象的属性 属性 说明 r.status_code HTTP请求的返回状态， 200表示连接成功， 404表示失败 r.text HTTP响应内容的字符串形式，即， url对应的页面内容 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP响应内容的二进制形式 Response的编码 r.encoding 从HTTP header中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.encoding：如果header中不存在charset，则认为编码为ISO‐8859‐1r.text根据r.encoding显示网页内容r.apparent_encoding ：根据网页内容分析出的编码方式可以看作是r.encoding的备选 request库的异常 异常 说明 requests.ConnectionError 网络连接错误异常，如DNS查询失败、拒绝连接等 requests.HTTPError HTTP错误异常 requests.URLRequired URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求URL超时，产生超时异常 r.raise_for_status() 如果不是200，产生异常 requests.HTTPError r.raise_for_status()在方法内部判断r.status_code是否等于200，不需要增加额外的if语句，该语句便于利用try‐except进行异常处理 爬取网页通用的代码(块)框架1234567891011121314151617import requestsdef getHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return 'processing exception'if __name__ == \"__main__\": url = 'https://www.baidu.com/' print(getHTMLText(url))response = requests.get('https://www.baidu.com/')print(type(response)) HTTP协议HTTP， Hypertext Transfer Protocol，超文本传输协议HTTP是一个基于“请求与响应”模式的、无状态的应用层协议HTTP协议采用URL作为定位网络资源的标识， URL格式如下：http://host[:port][path]host: 合法的Internet主机域名或IP地址port: 端口号，缺省端口为80path: 请求资源的路径 HTTP URL的理解：URL是通过HTTP协议存取资源的Internet路径，一个URL对应一个数据资源 http协议对资源的操作 方法 说明 GET 请求获取URL位置的资源 HEAD 请求获取URL位置资源的响应消息报告，即获得该资源的头部信息 POST 请求向URL位置的资源后附加新的数据 PUT 请求向URL位置存储一个资源，覆盖原URL位置的资源 PATCH 请求局部更新URL位置的资源，即改变该处资源的部分内容 DELETE 请求删除URL位置存储的资源 理解patch和put的区别假设URL位置有一组数据UserInfo，包括UserID、 UserName等20个字段需求：用户修改了UserName，其他不变• 采用PATCH，仅向URL提交UserName的局部更新请求• 采用PUT，必须将所有20个字段一并提交到URL，未提交字段被删除PATCH的最主要好处：节省网络带宽 http协议与requests库 TTP协议方法 Requests库方法 功能一致性 GET requests.get() 一致 HEAD requests.head() 一致 POST requests.post() 一致 PUT requests.put() 一致 PATCH requests.patch() 一致 DELETE requests.delete() 一致 Requests库网络爬取实战实例2：亚马逊商品页面的爬取 12345678910import requestsurl = 'https://item.jd.com/2967929.html'kv = &#123;'user-agent':'Mozilla/5.0'&#125;try: r = requests.get(url,headers=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(r.status_code)except: 'processing exception' 实例3：百度/360搜索关键字提交 百度的关键词接口：http://www.baidu.com/s?wd=keyword 123456789101112# https://item.jd.com/2967929.htmlimport requestsurl = 'http://www.baidu.com/s'kv = &#123;'wd':'python'&#125;try: r = requests.get(url,params=kv) r.raise_for_status() r.encoding = r.apparent_encoding print(len(r.text)) print(r.status_code)except: 'processing exception' 实例4：网络图片的爬取和存储 123456789101112131415161718import requests,osurl = 'http://image.nationalgeographic.com.cn/2017/0211/20170211061910157.jpg'root = 'E://img//'path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) r.raise_for_status() with open(path,'wb') as f: f.write(r.content) f.close() print('save file successfully') else: print('file exist')except: 'processing exception' 网络爬虫的相关问题 网络爬虫的限制来源审查：判断User‐Agent进行限制检查来访HTTP协议头的User‐Agent域，只响应浏览器或友好爬虫的访问• 发布公告： Robots协议告知所有爬虫网站的爬取策略，要求爬虫遵守 Robots协议Robots Exclusion Standard，网络爬虫排除标准 作用：网站告知网络爬虫哪些页面可以抓取，哪些不行形式：在网站根目录下的robots.txt文件 http://www.baidu.com/robots.txthttp://news.sina.com.cn/robots.txthttp://www.qq.com/robots.txthttp://news.qq.com/robots.txthttp://www.moe.edu.cn/robots.txt （无robots协议） Robots协议使用网络爬虫：自动或人工识别robots.txt，再进行内容爬取约束性：Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险 beautifulSoup库https://www.crummy.com/software/BeautifulSoup/ https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/ Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库. 安装 1pip install beautifulsoup4 使用 12345678910111213141516from bs4 import BeautifulSouphtml_doc = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"soup = BeautifulSoup(html_doc, 'html.parser')print(soup.prettify()) Beautiful Soup库解析器1soup = BeautifulSoup('&lt;html&gt;data&lt;/html&gt;'， 'html.parser') 解析器 使用方法 条件 bs4的HTML解析器 BeautifulSoup(mk,’html.parser’) 安装bs4库 lxml的LXML解析器 BeautifulSoup(mk,’lxml’) pip install lxml lxml的XML解析器 BeautifulSoup(mk,’xml’) pip install lxml html5lib的解析器 BeautifulSoup(mk,’html5lib’) pip install html5lib BeautifulSoup类的基本元素 1&lt;p class=\"title\"&gt; … &lt;/p&gt; 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字， …的名字是’p’，格式： .name Attributes 标签的属性，字典形式组织，格式： .attrs NavigableString 标签内非属性字符串， &lt;&gt;…&lt;/&gt;中字符串，格式： .string Comment 标签内字符串的注释部分，一种特殊的Comment类型 Tag 标签 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用&lt;&gt;和&lt;/&gt;标明开头和结尾 Name 标签的名字， …的名字是’p’，格式： .name Attributes 标签的属性，字典形式组织，格式： .attrs NavigableString 标签内非属性字符串， &lt;&gt;…&lt;/&gt;中字符串，格式： .string Comment 标签内字符串的注释部分，一种特殊的Comment类型 任何存在于HTML语法中的标签都可以用soup.&lt;tag&gt;访问获得当HTML文档中存在多个相同&lt;tag&gt;对应内容时， soup.&lt;tag&gt;返回第一个 基于bs4库的HTML内容遍历方法 标签树的下行遍历 属性 说明 .contents 子节点的列表，将所有儿子节点存入列表 .children 子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 BeautifulSoup类型是标签树的根节点 标签树的下行遍历 1234for child in soup.body.children: print(child) 遍历儿子节点for child in soup.body.descendants: print(child) 遍历子孙节点 标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的迭代类型，用于循环遍历先辈节点 标签树的上行遍历 遍历所有先辈节点，包括soup本身，所以要区别判断 标签树的平行遍历 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 1234567标签树的平行遍历for sibling in soup.a.next_sibling:print(sibling)for sibling in soup.a.previous_sibling:print(sibling)遍历后续节点遍历前续节点 信息标记和提取方法信息标记标记后的信息可形成信息组织结构，增加了信息维度标记的结构与信息一样具有重要价值标记后的信息可用于通信、存储或展示标记后的信息更利于程序理解和运用 信息标记的三种信息xml，json，yaml html的信息标记HTML是WWW(World Wide Web)的信息组织方式 HTML通过预定义的&lt;&gt;…&lt;/&gt;标签形式组织不同类型的信息 xml eXtensible Markup Language 空元素的缩写形式 1&lt;img src=“china.jpg” size=“10” /&gt; 注释书写形式 1&lt;!‐‐ This is a comment, very useful ‐‐&gt; json JavsScript Object Notation有类型的键值对 key:value yaml YAML Ain’t Markup Language无类型键值对 key:value 1234缩进表达所属关系name : newName : 北京理工大学 oldName : 延安自然科学院 1234‐ 表达并列关系name :‐北京理工大学‐延安自然科学院 123456| 表达整块数据 # 表示注释text: | #学校介绍北京理工大学创立于1940年，前身是延安自然科学院， 是中国共产党创办的第一所理工科大学，毛泽东同志亲自题写校名，李富春、徐特立、李强等老一辈无产阶级革命家先后担任学校主要领导。学校是新中国成立以来国家历批次重点建设的高校，首批进入国家“211工程”和“985工程”建设行列；在全球具有广泛影响力的英国QS“世界大学500强”中，位列入选的中国大陆高校第15位。学校现隶属于工业和信息化部。 XMLJSONYAML最早的通用信息标记语言，可扩展性好，但繁琐信息有类型，适合程序处理(js)，较XML简洁信息无类型，文本信息比例最高，可读性好 XMLJSONYAMLInternet上的信息交互与传递移动应用云端和节点的信息通信，无注释各类系统的配置文件，有注释易读 信息提取融合方法：结合形式解析与搜索方法，提取关键信息XML JSON YAML 搜索需要标记解析器及文本查找函数 12345678from bs4 import BeautifulSoupimport requestsr =requests.get('http://python123.io/ws/demo.html')demo = r.textsoup = BeautifulSoup(demo, 'html.parser')for link in soup('a'): print(link) &lt;&gt;.find_all(name, attrs, recursive, string, **kwargs)∙ name : 对标签名称的检索字符串返回一个列表类型，存储查找的结果 attrs: 对标签属性值的检索字符串，可标注属性检索 recursive: 是否对子孙全部检索，默认True string: &lt;&gt;…&lt;/&gt;中字符串区域的检索字符串 &lt;tag&gt;(..) 等价于 &lt;tag&gt;.find_all(..)soup(..) 等价于 soup.find_all(..) 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，同.find()参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果，同.find()参数 &lt;&gt;.find_previous_siblings() 在前序平行节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_previous_sibling() 在前序平行节点中返回一个结果，同.find()参数 中国大学定向排名实例http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html 技术路线： requests‐bs4定向爬虫：仅对输入URL进行爬取，不扩展爬取 12345678910111213141516171819202122232425262728293031323334353637# CrawUnivRankingB.pyimport requestsfrom bs4 import BeautifulSoupimport bs4def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist, html): soup = BeautifulSoup(html, \"html.parser\") for tr in soup.find('tbody').children: if isinstance(tr, bs4.element.Tag): tds = tr('td') ulist.append([tds[0].string, tds[1].string, tds[3].string])def printUnivList(ulist, num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\" print(tplt.format(\"排名\", \"学校名称\", \"总分\", chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0], u[1], u[2], chr(12288)))def main(): uinfo = [] url = 'http://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html' html = getHTMLText(url) fillUnivList(uinfo, html) printUnivList(uinfo, 20) # 20 univsmain() 当中文字符宽度不够时，采用西文字符填充；中西文字符占用宽度不同采用中文字符的空格填充 chr(12288) 正则表达式regular expression, regex, RE 正则表达式是用来简洁表达一组字符串的表达式 正则表达式在文本处理中十分常用：表达文本类型的特征（病毒、入侵等）同时查找或替换一组字符串匹配字符串的全部或部分……最主要应用在字符串匹配中 正则表达式语法由字符和操作符构成 正则表达式常用操作符 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、 b、 c， [a‐z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示 ab、 abc、 abcc、 abccc等 + 前一个字符1次或无限次扩展 abc+ 表示 abc、 abcc、 abccc等 ? 前一个字符0次或1次扩展 abc? 表示 ab、 abc | 左右表达式任意一个 abc|def 表示 abc、 def {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、 abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 | 操作符 (abc)表示abc， (abc|def)表示abc、 def \\d 数字，等价于[0‐9] \\w 单词字符，等价于[A‐Za‐z0‐9_] 经典正则表达式1234567^[A‐Za‐z]+$ 由26个字母组成的字符串^[A‐Za‐z0‐9]+$ 由26个字母和数字组成的字符串^‐?\\d+$ 整数形式的字符串^[0‐9]*[1‐9][0‐9]*$ 正整数形式的字符串[1‐9]\\d&#123;5&#125; 中国境内邮政编码， 6位[\\u4e00‐\\u9fa5] 匹配中文字符\\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125; 国内电话号码， 010‐68913536 ip地址正则P地址字符串形式的正则表达式（ IP地址分4段，每段0‐255） 123456精确写法 0‐99： [1‐9]?\\d100‐199: 1\\d&#123;2&#125;200‐249: 2[0‐4]\\d250‐255: 25[0‐5](([1‐9]?\\d|1\\d&#123;2&#125;|2[0‐4]\\d|25[0‐5]).)&#123;3&#125;([1‐9]?\\d|1\\d&#123;2&#125;|2[0‐4]\\d|25[0‐5]) re库Re库是Python的标准库，主要用于字符串匹配 正则表达式的表示类型raw string类型（原生字符串类型）库采用类型表示正则表达式，表示为： 1例如： r'[1‐9]\\d&#123;5&#125;' r'\\d&#123;3&#125;‐\\d&#123;8&#125;|\\d&#123;4&#125;‐\\d&#123;7&#125;' raw string是不包含对转义符再次转义的字符串 re库也可以采用string类型表示正则表达式，但更繁琐例如：‘[1‐9]\\d{5}’‘\\d{3}‐\\d{8}|\\d{4}‐\\d{7}’建议：当正则表达式包含转义符时，使用raw string Re库的主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 re.search(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记在一个字符串中搜索匹配正则表达式的第一个位置返回match对象 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式的大小写， [A‐Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除换行外的所有字符 1234import rematch = re.search(r'[1-9]\\d&#123;5&#125;','bit 100001')if match: print(match.group(0)) re.match(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记从一个字符串的开始位置起匹配正则表达式返回match对象 re.findall(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记搜索字符串，以列表类型返回全部能匹配的子串 re.split(pattern, string, maxsplit=0, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ maxsplit: 最大分割数，剩余部分作为最后一个元素输出∙ flags : 正则表达式使用时的控制标记将一个字符串按照正则表达式匹配结果进行分割返回列表类型 re.finditer(pattern, string, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ string : 待匹配字符串∙ flags : 正则表达式使用时的控制标记搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 1import refor m in re.finditer(r'[1-9]\\d&#123;5&#125;','bit100001 lmz312552'): if m: print(m.group(0)) re.sub(pattern, repl, string, count=0, flags=0)在一个字符串中替换所有匹配正则表达式的子串返回替换后的字符串 ∙ pattern 正则表达式的字符串或原生字符串表示: ∙ repl : 替换匹配字符串的字符串∙ string : 待匹配字符串∙ count∙ flags : 匹配的最大替换次数正则表达式使用时的控制标记 1import resub = re.sub(r'[1-9]\\d&#123;5&#125;', 'bitzip', 'bit100001 lmz312552')print(sub) 正则表达式对象rst = re.search(r’[1‐9]\\d{5}’, ‘BIT 100081’)pat = re.compile(r’[1‐9]\\d{5}’)rst = pat.search(‘BIT 100081’)面向对象用法：编译后的多次操作函数式用法：一次性操作 regex = re.compile(pattern, flags=0)∙ pattern : 正则表达式的字符串或原生字符串表示∙ flags : 正则表达式使用时的控制标记 regex = re.compile(r’[1‐9]\\d{5}’)将正则表达式的字符串形式编译成正则表达式对象 re库的match对象Match对象是一次匹配的结果，包含匹配的很多信息 属性 说明 .string 待匹配的文本 .re 匹配时使用的patter对象（正则表达式） .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 re库的贪婪匹配和最小匹配123match = re.search(r'PY.*N', 'PYANBNCNDN')print(match.group(0))'PYANBNCNDN' Re库默认采用贪婪匹配，即输出匹配最长的子串 操作符 说明 *? 前一个字符0次或无限次扩展，最小匹配 +? 前一个字符1次或无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次（含n），最小匹配 *只要长度输出可能不同的，都可以通过在操作符后增加?变成最小匹配 * ScrapyScrapy是一个快速功能强大的网络爬虫框架 爬虫框架是实现爬虫功能的一个软件结构和功能组件集合。爬虫框架是一个半成品，能够帮助用户实现专业网络爬虫。 scrapy的安装 Win平台: “以管理员身份运行” cmd执行 1pip install scrapy 1conda install scrapy 安装后小测：执行 1scrapy Scrapy结构 Engine(1) 控制所有模块之间的数据流(2) 根据条件触发事件不需要用户修改 Downloader根据请求下载网页不需要用户修改 Scheduler对所有爬取请求进行调度管理不需要用户修改 Downloader Middleware目的：实施Engine、 Scheduler和Downloader之间进行用户可配置的控制功能：修改、丢弃、新增请求或响应用户可以编写配置代码 Spider(1) 解析Downloader返回的响应（ Response）(2) 产生爬取项（ scraped item）(3) 产生额外的爬取请求（ Request）需要用户编写配置代码 Item Pipelines(1) 以流水线方式处理Spider产生的爬取项(2) 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型(3) 可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据库需要用户编写配置代码 Spider Middleware目的：对请求和爬取项的再处理功能：修改、丢弃、新增请求或爬取项用户可以编写配置代码 requests和scrapy相同点：两者都可以进行页面请求和爬取， Python爬虫的两个重要技术路线两者可用性都好，文档丰富，入门简单两者都没有处理js、提交表单、应对验证码等功能（可扩展） requests scrapy 页面级爬虫 网站级爬虫 功能库 框架 并发性考虑不足，性能较差 并发性好，性能较高 重点在于页面下载 重点在于爬虫结构 定制灵活 一般定制灵活，深度定制困难 上手十分简单 入门稍难 scrapy常用命令Scrapy是为持续运行设计的专业爬虫框架，提供操作的Scrapy命令行Win下，启动cmd控制台 为什么Scrapy采用命令行创建和运行爬虫？命令行（不是图形界面）更容易自动化，适合脚本控制本质上， Scrapy是给程序员用的，功能（而不是界面）更重要 1scrapy &lt;command&gt; [options] [args] 命令 说明 格式 startproject 创建一个新工程 scrapy startproject [dir] genspider 创建一个爬虫 scrapy genspider [options] settings 获得爬虫配置信息 scrapy settings [options] crawl 运行一个爬虫 scrapy crawl list 列出工程中所有爬虫 scrapy list shell 启动URL调试命令行 scrapy shell [url] 产生的步骤应用Scrapy爬虫框架主要是编写配置型代码 步骤1：建立一个Scrapy爬虫工程选取一个目录（ D:\\pycodes\\），然后执行如下命令： 1scrapy startproject python123demo 生成的工程目录12345678910python123demo/ 外层目录 scrapy.cfg 部署Scrapy爬虫的配置文件 python123demo/ Scrapy框架的用户自定义Python代码 __init__.py 初始化脚本 items.py Items代码模板（继承类） middlewares.py Middlewares代码模板（继承类） pipelines.py Pipelines代码模板（继承类） settings.py Scrapy爬虫的配置文件 spiders/ Spiders代码模板目录（继承类）目录结构 __pycache__/ 缓存目录，无需修改 内层目录结构 用户自定义的spider代码增加在此处 123spiders/ Spiders代码模板目录（继承类） __init__.py 初始文件，无需修改 __pycache__/ 缓存目录，无需修改 步骤2：在工程中产生一个Scrapy爬虫进入工程目录（ D:\\pycodes\\python123demo），然后执行如下命令： 123You can start your first spider with: cd python123demo scrapy genspider example example.com 1E:\\Codes\\Python\\reptile\\python123demo&gt;scrapy genspider demo python123.io 该命令作用：(1) 生成一个名称为demo的spider(2) 在spiders目录下增加代码文件demo.py 该命令仅用于生成demo.py，该文件也可以手工生成 demo.py文件 12345678910# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' allowed_domains = ['python123.io'] start_urls = ['http://python123.io/']#parse()用于处理响应，解析内容形成字典，发现新的URL爬取请求 def parse(self, response): pass 步骤3：配置产生的spider爬虫配置：（ 1）初始URL地址 （ 2）获取页面后的解析方式 1234567891011121314# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' # allowed_domains = ['python123.io'] 可选 start_urls = ['http://python123.io/ws/demo.html'] def parse(self, response): fname = response.url.split('/')[-1] with open(fname,\"wb\") as f: f.write(response.body) self.log('Saved file %s.' % fname) 步骤4：运行爬虫，获取网页在命令行下，执行如下命令： 1scrapy crawl demo 完整版代码： 123456789101112131415161718# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' def start_requests(self): urls = [ 'http://python123.io/ws/demo.html' ] for url in urls: yield scrapy.Request(url=url,callback=self.parse) def parse(self, response): fname = response.url.split('/')[-1] with open(fname,\"wb\") as f: f.write(response.body) self.log('Saved file %s.' % fname) yield关键字yield 《=》生成器 包含yield语句的函数是一个生成器 生成器每次产生一个值（ yield语句），函数被冻结，被唤醒后再产生一个值生成器是一个不断产生值的函数 生成器相比一次列出所有内容的优势：1)更节省存储空间2)响应更迅速3)使用更灵活 实例： 123456def gen(n): for i in range(n): yield i ** 2for i in gen(5): print(i, \" \", end=\"\") 生成器每调用一次在yield位置产生一个值，直到函数执行结束 一次返回所有值 12345def square(n): return [i **2 for i in range(n)]for i in square(5): print(i, \" \", end=\"\") 数据类型Request类class scrapy.http.Request()Request对象表示一个HTTP请求由Spider生成，由Downloader执行 属性或方法 说明 .url Request对应的请求URL地址 .method 对应的请求方法， ‘GET’ ‘POST’等 .headers 字典类型风格的请求头 .body 请求内容主体，字符串类型 .meta 用户添加的扩展信息，在Scrapy内部模块间传递信息使用 .copy() 复制该请求 Response类class scrapy.http.Response()Response对象表示一个HTTP响应由Downloader生成，由Spider处理 属性或方法 说明 .url Response对应的URL地址 .status HTTP状态码，默认是200 .headers Response对应的头部信息 .body Response对应的内容信息，字符串类型 .flags 一组标记 .request 产生Response类型对应的Request对象 .copy() 复制该响应 Item类class scrapy.item.Item()Item对象表示一个从HTML页面中提取的信息内容由Spider生成，由Item Pipeline处理Item类似字典类型，可以按照字典类型操作 scrapy基本使用使用步骤步骤1：创建一个工程和Spider模板步骤2：编写Spider步骤3：编写Item Pipeline步骤4：优化配置策略 Scrapy爬虫支持多种HTML信息提取方法：• Beautiful Soup• lxml• re• XPath Selector• CSS Selector CSS Selector 1&lt;HTML&gt;.css('a::attr(href)').extract() CSS Selector由W3C组织维护并规范标签名称 标签属性 配置并发连接选项 settings.py文件 选项 说明 CONCURRENT_REQUESTS Downloader最大并发请求下载数量，默认32 CONCURRENT_ITEMS Item Pipeline最大并发ITEM处理数量，默认100 CONCURRENT_REQUESTS_PER_DOMAIN 每个目标域名最大的并发请求数量，默认8 CONCURRENT_REQUESTS_PER_IP 每个目标IP最大的并发请求数量，默认0，非0有效","categories":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"},{"name":"crawler","slug":"crawler","permalink":"https://codeofli.github.io/tags/crawler/"}]},{"title":"python","slug":"python/python/python","date":"2019-10-15T13:14:50.000Z","updated":"2019-11-13T12:20:25.650Z","comments":true,"path":"2019/10/python/python/python/","link":"","permalink":"https://codeofli.github.io/2019/10/python/python/python/","excerpt":"[TOC]python语法分支语法条件判断用于条件组合的三个保留字 操作符及使用 描述 x and y 两个条件x和y的逻辑与 x or y 两个条件x和y的逻辑或 not x 条件x的逻辑非 操作符 数学符号 描述 &lt; &lt; 小于 &lt;= ≤ 小于等于 &gt;= ≥ 大于等于 &gt; &gt; 大于 == = 等于 ！ = ≠ 不等于","text":"[TOC]python语法分支语法条件判断用于条件组合的三个保留字 操作符及使用 描述 x and y 两个条件x和y的逻辑与 x or y 两个条件x和y的逻辑或 not x 条件x的逻辑非 操作符 数学符号 描述 &lt; &lt; 小于 &lt;= ≤ 小于等于 &gt;= ≥ 大于等于 &gt; &gt; 大于 == = 等于 ！ = ≠ 不等于 1if &lt;condition&gt;: &lt;statement&gt; special： 1if not bool: statement 二分支紧凑形式 1&lt;statement&gt; if &lt;condition&gt; else &lt;statement&gt; 多分支 注意是elif，不是else if 1234567if &lt;条件1&gt; :&lt;语句块1&gt;elif &lt;条件2&gt; :&lt;语句块2&gt;……else :&lt;语句块N&gt; 循环结构遍历某个结构形成的循环运行方式 从遍历结构中逐一提取元素，放在循环变量中 12for &lt;循环变量&gt; in &lt;遍历结构&gt; :&lt;语句块&gt; 由保留字for和in组成，完整遍历所有元素后结束 每次循环，所获得元素放入循环变量，并执行一次语句块 计数循环(N次) 遍历由range()函数产生的数字序列，产生循环 12for i in range(N) :&lt;语句块&gt; 字符串遍历循环 s是字符串，遍历字符串每个字符，产生循环 12345for c in s :&lt;语句块&gt; &gt;&gt;&gt; for c in \"Python123\":print(c, end=\",\")P,y,t,h,o,n,1,2,3, ls是一个列表， 遍历其每个元素，产生循环 12345for item in ls :&lt;语句块&gt;&gt;&gt;&gt; for item in [123, \"PY\", 456] :print(item, end=\",\")123,PY,456, 文件遍历循环 fi是一个文件标识符，遍历其每行，产生循环 12for line in fi :&lt;语句块&gt; while由条件控制的循环运行方式 反复执行语句块，直到条件不满足时结束 12while &lt;条件&gt; :&lt;语句块&gt; 循环控制保留字break 和 continue break跳出并结束当前整个循环，执行循环后的语句 continue结束当次循环，继续执行后续次数循环 break和continue可以与for和while循环搭配使用 循环的扩展(else)循环与else 当循环没有被break语句退出时，执行else语句块 else语句块作为”正常”完成循环的奖励 这里else的用法与异常处理中else用法相似 123456789while &lt;条件&gt; :&lt;语句块1&gt;else :&lt;语句块2&gt;for &lt;变量&gt; in &lt;遍历结构&gt; :&lt;语句块1&gt;else :&lt;语句块2&gt; 123456789101112131415&gt;&gt;&gt; for c in \"PYTHON\" :if c == \"T\" :continueprint(c, end=\"\")else:print(\"正常退出\")PYHON正常退出&gt;&gt;&gt; for c in \"PYTHON\" :if c == \"T\" :breakprint(c, end=\"\")else:print(\"正常退出\")PY import库form:能直接调用函数当我们使用from * 的时候，会取得模块顶层左右赋值的变量名的拷贝。 123from 库 import 函数名from 库 import *&lt;functionName&gt;(argc) import:使用库名调用12import &lt;libaryName&gt;import &lt;libaryName&gt; as &lt;alias&gt; 输入输出print()以字符串形式向控制台输出的函数 1print(&#123;&#125;.format()) &#123;&#125;表示槽，后续format()填入 input()1input([prompt]) 在一行输入多个数字 1a, b, c, d = map(int, input().split()) python注释 基本数据类型及其操作数字类型整数类型与数学中整数的概念一致 可正可负，没有取值范围限制 pow(x,y)函数：计算 xy，想算多大算多大1234pow(2,100)1267650600228229401496703205376pow(2,pow(2,15))1415461031044954789001553…… 4种进制表示形式 十进制： 1010, 99, -217 二进制，以0b或0B开头： 0b010, -0B101 八进制，以0o或0O开头： 0o123, -0O456 十六进制，以0x或0X开头： 0x9a, -0X89 浮点数类型与数学中实数的概念一致 带有小数点及小数的数字 浮点数取值范围和小数精度都存在限制，但常规计算可忽略 取值范围数量级约-10307至10308，精度数量级10-16 浮点数间运算存在不确定尾数，不是bug 12340.1 + 0.30.40.1 + 0.20.30000000000000004 #不确定尾数 round(x, d)：对x四舍五入， d是小数截取位数 浮点数间运算与比较用round()函数辅助 不确定尾数一般发生在10-16左右， round()十分有效 浮点数可以采用科学计数法表示 使用字母e或E作为幂的符号，以10为基数，格式如下：e 表示 a*10b 例如： 4.3e-3 值为0.0043 9.6E5 值为960000.0 复数类型与数学中复数的概念一致如果x2 = -1，那么x的值是什么？ 定义 j = -𝟏𝟏 ，以此为基础，构建数学体系 a+bj 被称为复数，其中， a是实部， b是虚部 复数实例z = 1.23e-4+5.6e+89j 实部是什么？ z.real 获得实部 虚部是什么？ z.imag 获得虚部 数值运算操作符操作符是完成运算的一种符号体系 操作符及使用 描述 x + y 加， x与y之和 x – y 减， x与y之差 x * y 乘， x与y之积 x / y 除， x与y之商 10/3结果是3.3333333333333335 x // y 整数除， x与y之整数商 10//3结果是3 + x x本身 - y x的负值 x % y 余数，模运算 10%3结果是1 x ** y 幂运算， x的y次幂， x^y;当y是小数时，开方运算10**0.5结果是 增强操作符及使用 描述 x op= y 即 x = x op y，其中， op为二元操作符 x op= y x += y x -= y x = y x /= y x //= y x %= y x *= y x op= y &gt;&gt;&gt; x = 3.1415 &gt;&gt;&gt; x *= 3 与 x = x *3 等价 31.006276662836743 数字类型的关系类型间可进行混合运算，生成结果为”最宽”类型 三种类型存在一种逐渐”扩展”或”变宽”的关系： 整数 -&gt; 浮点数 -&gt; 复数 例如： 123 + 4.0 = 127.0 (整数+浮点数 = 浮点数) 数值运算函数一些以函数形式提供的数值运算功能 函数及使用 描述 abs(x) 绝对值， x的绝对值 abs(-10.01) 结果为 10.01 divmod(x,y) 商余， (x//y, x%y)，同时输出商和余数 divmod(10, 3) 结果为 (3, 1) pow(x, y[, z]) 幂余， (x**y)%z， [..]表示参数z可省略 pow(3, pow(3, 99), 10000) 结果为 4587 round(x[, d]) 四舍五入， d是保留小数位数，默认值为 round(-10.123, 2) 结果为 -10.12 max(x1,x2, … ,xn) 最大值，返回x1,x2, … ,xn中的最大值， n不限 max(1, 9, 5, 4, 3) 结果为 9 min(x1,x2, … ,xn) 最小值，返回x1,x2, … ,xn中的最小值， n不限 min(1, 9, 5, 4, 3) 结果为 1 int(x) 将x变成整数，舍弃小数部分 int(123.45) 结果为123； int(“123”) 结果为123 float(x) 将x变成浮点数，增加小数部分 float(12) 结果为12.0； float(“1.23”) 结果为1.23 complex(x) 将x变成复数，增加虚数部分 complex(4) 结果为 4 + 0j 集合类型集合是多个元素的无序组合 集合类型与数学中的集合概念一致 集合元素之间无序，每个元素唯一，不存在相同元素 集合元素不可更改，不能是可变数据类型 为什么？ 集合用大括号 {} 表示，元素间用逗号分隔 建立集合类型用 {} 或 set() 建立空集合类型，必须使用set() 123456&gt;&gt;&gt; A = &#123;\"python\", 123, (\"python\",123)&#125; #使用&#123;&#125;建立集合&#123;123, 'python', ('python', 123)&#125;&gt;&gt;&gt; B = set(\"pypy123\") #使用set()建立集合&#123;'1', 'p', '2', '3', 'y'&#125;&gt;&gt;&gt; C = &#123;\"python\", 123, \"python\",123&#125;&#123;'python', 123&#125; 集合操作符 操作符及应用 描述 S | T 并，返回一个新集合，包括在集合S和T中的所有元素 S - T 差，返回一个新集合，包括在集合S但不在T中的元素 S &amp; T 交，返回一个新集合，包括同时在集合S和T中的元素 S ^ T 补，返回一个新集合，包括集合S和T中的非相同元素 S &lt;= T 或 S &lt; T 返回True/False，判断S和T的子集关系 S &gt;= T 或 S &gt; T 返回True/False，判断S和T的包含关系 S |= T 并，更新集合S，包括在集合S和T中的所有元素 S -= T 差，更新集合S，包括在集合S但不在T中的元素 S &amp;= T 交，更新集合S，包括同时在集合S和T中的元素 S ^= T 补，更新集合S，包括集合S和T中的非相同元素 123456789101112&gt;&gt;&gt; A = &#123;\"p\", \"y\" , 123&#125;&gt;&gt;&gt; B = set(\"pypy123\")&gt;&gt;&gt; A-B&#123;123&#125;&gt;&gt;&gt; B-A&#123;'3', '1', '2'&#125;&gt;&gt;&gt; A&amp;B&#123;'p', 'y'&#125;&gt;&gt;&gt; A|B&#123;'1', 'p', '2', 'y', '3', 123&#125;&gt;&gt;&gt; A^B&#123;'2', 123, '3', '1'&#125; 集合处理方法 S.add(x) 如果x不在集合S中，将x增加到S S.discard(x) 移除S中元素x，如果x不在集合S中，不报错 S.remove(x) 移除S中元素x，如果x不在集合S中，产生KeyError异常 S.clear() 移除S中所有元素 S.pop() 随机返回S的一个元素，更新S，若S为空产生KeyError异常 S.copy() 返回集合S的一个副本 len(S) 返回集合S的元素个数 x in S 判断S中元素x， x在集合S中，返回True，否则返回False x not in S 判断S中元素x， x不在集合S中，返回True，否则返回False set(x) 将其他类型变量x转变为集合类型 1234567891011121314&gt;&gt;&gt; A = &#123;\"p\", \"y\" , 123&#125;&gt;&gt;&gt; for item in A:print(item, end=\"\")p123y&gt;&gt;&gt; A&#123;'p', 123, 'y'&#125;&gt;&gt;&gt; try:while True:print(A.pop(), end=\"\"))except:passp123y&gt;&gt;&gt; Aset() 集合类型应用场景包含关系比较 1234\"p\" in &#123;\"p\", \"y\" , 123&#125;True&#123;\"p\", \"y\"&#125; &gt;= &#123;\"p\", \"y\" , 123&#125;False 数据去重：集合类型所有元素无重复 12345&gt;&gt;&gt; ls = [\"p\", \"p\", \"y\", \"y\", 123]&gt;&gt;&gt; s = set(ls) # 利用了集合无重复元素的特点&#123;'p', 'y', 123&#125;&gt;&gt;&gt; lt = list(s) # 还可以将集合转换为列表['p', 'y', 123] 字典类型及操作字典类型定义字典类型是“映射”的体现 映射是一种键(索引)和值(数据)的对应 键值对：键是数据索引的扩展 字典是键值对的集合，键值对之间无序 采用大括号{}和dict()创建，键值对用冒号: 表示{&lt;键1&gt;:&lt;值1&gt;, &lt;键2&gt;:&lt;值2&gt;, … , &lt;键n&gt;:&lt;值n&gt;} 在字典变量中，通过键获得值&lt;字典变量&gt; = {&lt;键1&gt;:&lt;值1&gt;, … , &lt;键n&gt;:&lt;值n&gt;}&lt;值&gt; = &lt;字典变量&gt;[&lt;键&gt;][ ] 用来向字典变量中索引或增加元素&lt;字典变量&gt;[&lt;键&gt;] = &lt;值&gt; 123456789&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; d&#123;'中国': '北京', '美国': '华盛顿', '法国': '巴黎'&#125;&gt;&gt;&gt; d[\"中国\"]'北京'&gt;&gt;&gt; de = &#123;&#125; ; type(de)&lt;class 'dict'&gt;type(x)返回变量x的类型 字典类型操作函数和方法 函数或方法 描述 del d[k] 删除字典d中键k对应的数据值 k in d 判断键k是否在字典d中，如果在返回True，否则False d.keys() 返回字典d中所有的键信息 d.values() 返回字典d中所有的值信息 d.items() 返回字典d中所有的键值对信息 d.get(k, ) 键k存在，则返回相应值，不在则返回值 d.pop(k, ) 键k存在，则取出相应值，不在则返回值 d.popitem() 随机从字典d中取出一个键值对，以元组形式返回 d.clear() 删除所有的键值对 len(d) 返回字典d中元素的个数 123456789101112131415&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; \"中国\" in dTrue&gt;&gt;&gt; d.keys()dict_keys(['中国', '美国', '法国'])&gt;&gt;&gt; d.values()dict_values(['北京', '华盛顿', '巴黎'])&gt;&gt;&gt; d = &#123;\"中国\":\"北京\", \"美国\":\"华盛顿\", \"法国\":\"巴黎\"&#125;&gt;&gt;&gt; d.get(\"中国\",\"伊斯兰堡\")'北京'&gt;&gt;&gt; d.get(\"巴基斯坦\",\"伊斯兰堡\")'伊斯兰堡'&gt;&gt;&gt; d.popitem()('美国', '华盛顿') 元素遍历 12for k in d :&lt;语句块&gt; 文件处理文件的理解文件是数据的抽象和集合 文件是存储在辅助存储器上的数据序列 文件是数据存储的一种形式 文件展现形态：文本文件和二进制文件 文本文件 vs. 二进制文件 文件文件和二进制文件只是文件的展示方式 本质上，所有文件都是二进制形式存储 形式上， 所有文件采用两种方式展示 文本文件 由单一特定编码组成的文件，如UTF-8编码 由于存在编码，也被看成是存储着的长字符串 适用于例如： .txt文件、 .py文件等 二进制文件 直接由比特0和1组成， 没有统一字符编码 一般存在二进制0和1的组织结构，即文件格式 适用于例如： .png文件、 .avi文件等 文本文件vs二进制文件f.txt文件保存：“中国是一个伟大的国家！”； 文本形式打开文件12345678#tf = open(\"f.txt\", mode=\"rt\",encoding='UTF-8') 能指定编码tf = open(\"f.txt\", \"rt\",encoding='UTF-8')print(tf.readline())tf.close()============= RESTART: E:/Codes/Python/new/file.py ====================中国是一个伟大的国家！&gt;&gt;&gt; 二进制形式打开文件12345678tf = open(\"f.txt\", mode=\"rb\")#tf = open(\"f.txt\", \"rb\")print(tf.readline())tf.close()====== RESTART: E:/Codes/Python/new/file.py ====================b'\\xe4\\xb8\\xad\\xe5\\x9b\\xbd\\xe6\\x98\\xaf\\xe4\\xb8\\x80\\xe4\\xb8\\xaa\\xe4\\xbc\\x9f\\xe5\\xa4\\xa7\\xe7\\x9a\\x84\\xe5\\x9b\\xbd\\xe5\\xae\\xb6\\xef\\xbc\\x81'&gt;&gt;&gt; 文件的使用 文件的打开 1&lt;变量名(文件句柄)&gt; = open(&lt;文件名|文件路径和名称&gt;, &lt;打开模式 |文本 or 二进制|读 or 写 &gt;) 文件路径和名称源文件同目录可省路径 123\"D:/PYE/f.txt\"\"D:\\\\PYE\\\\f.txt\" \"f.txt\"\"./PYE/f.txt\" 打开模式文本形式、只读模式、默认值 文件的打开模式 描述 ‘r’ 只读模式，默认值，如果文件不存在，返回FileNotFoundError ‘w’ 覆盖写模式，文件不存在则创建，存在则完全覆盖 ‘x’ 创建写模式，文件不存在则创建，存在则返回FileExistsError ‘a’ 追加写模式，文件不存在则创建，存在则在文件最后追加内容 ‘b’ 二进制文件模式 ‘t’ 文本文件模式，默认值 ‘+’ 与r/w/x/a一同使用，在原功能基础上增加同时读写功能 1234567891011121314f = open(\"f.txt\")f = open(\"f.txt\", \"rt\")f = open(\"f.txt\", \"w\")f = open(\"f.txt\", \"a+\")f = open(\"f.txt\", \"x\")f = open(\"f.txt\", \"b\")f = open(\"f.txt\", \"wb\")- 文本形式、只读模式、默认值- 文本形式、只读模式、同默认值- 文本形式、覆盖写模式- 文本形式、追加写模式+ 读文件- 文本形式、创建写模式- 二进制形式、只读模式- 二进制形式、覆盖写模式 12345678#文本形式打开文件tf = open(\"f.txt\", \"rt\")print(tf.readline())tf.close()#二进制形式打开文件bf = open(\"f.txt\", \"rb\")print(bf.readline())bf.close() 文件内容的读取 操作方法 描述 .read(size=-1) 读入全部内容，如果给出参数，读入前size长度 &gt;&gt;&gt;s = f.read(2) 中国 .readline(size=-1) 读入一行内容，如果给出参数，读入该行前size长度 &gt;&gt;&gt;s = f.readline() 中国是一个伟大的国家！ .readlines(hint=-1) 读入文件所有行，以每行为元素形成列表 如果给出参数，读入前hint行 &gt;&gt;&gt;s = f.readlines() [‘中国是一个伟大的国家！ ‘] 文件的逐行操作 逐行遍历文件：方法一 一次读入，分行处理 12345fname = input(\"请输入要打开的文件名称:\")fo = open(fname,\"r\")for line in fo.readlines():print(line)fo.close() 逐行遍历文件：方法二 分行读入，逐行处理 12345fname = input(\"请输入要打开的文件名称:\")fo = open(fname,\"r\")for line in fo:print(line)fo.close() 数据的文件写入 操作方法 描述 .write(s) 向文件写入一个字符串或字节流 &gt;&gt;&gt;f.write(“中国是一个伟大的国家!”) .writelines(lines) 将一个元素全为字符串的列表写入文件 &gt;&gt;&gt;ls = [“中国”, “法国”, “美国”] &gt;&gt;&gt;f.writelines(ls) 中国法国美国 .seek(offset) 改变当前文件操作指针的位置， offset含义如下： 0 – 文件开头； 1 – 当前位置； 2 – 文件结尾 &gt;&gt;&gt;f.seek(0) #回到文件开头 数据的文件写入 写入一个字符串列表(没有任何输出) 123456fo = open(\"output.txt\",\"w+\")ls = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)for line in fo:print(line)fo.close() 写入一个字符串列表 中国法国美国 1234567fo = open(\"output.txt\",\"w+\")ls = [\"中国\", \"法国\", \"美国\"]fo.writelines(ls)fo.seek(0)for line in fo:print(line)fo.close() with open文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： 1f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open('/path/to/file', 'r') print(f.read())finally: if f: f.close() 但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法： 12with open('/path/to/file', 'r') as f: print(f.read()) 这和前面的try ... finally是一样的，但是代码更佳简洁，并且不必调用f.close()方法。 异常处理异常处理的基本使用 123456789try :&lt;语句块1&gt;except :&lt;语句块2&gt;try :&lt;语句块1&gt;except &lt;异常类型&gt; :&lt;语句块2&gt; 1234567891011121314try :num = eval(input(\"请输入一个整数: \"))print(num**2)except :print(\"输入不是整数\")try :num = eval(input(\"请输入一个整数: \"))print(num**2)except NameError:print(\"输入不是整数\")示例标注异常类型后，仅响应此类异常异常类型名字等同于变量名 异常处理的高级使用 finally对应语句块4一定执行 else对应语句块3在不发生异常时执行 12345678try :&lt;语句块1&gt;except :&lt;语句块2&gt;else :&lt;语句块3&gt;finally :&lt;语句块4&gt; 1234try: ...except xxx as xx: ... 12345try: response = urllib.request.urlopen('http://httpbin.org/get',timeout=1)except urllib.error.URLError as e: if isinstance(e.strerror,socket.timeout): print('TIME OUT') python第三方库Python社区 PyPI PyPI: Python Package Index PSF维护的展示全球Python计算生态的主站 学会检索并利用PyPI，找到合适的第三方库开发程序 实例：开发与区块链相关的程序 第1步：在pypi.org搜索 blockchain 第2步：挑选适合开发目标的第三方库作为基础 第3步：完成自己需要的功能 三种方法 方法1(主要方法): 使用pip命令 方法2: 集成安装方法 方法3: 文件安装方法 pip -h 1234567891011121314151617181920E:\\Users\\11623\\Anaconda3\\Lib\\site-packages&gt;pip -hUsage: pip &lt;command&gt; [options]Commands: install Install packages. download Download packages. uninstall Uninstall packages. freeze Output installed packages in requirements format. list List installed packages. show Show information about installed packages. check Verify installed packages have compatible dependencies. config Manage local and global configuration. search Search PyPI for packages. wheel Build wheels from your requirements. hash Compute hashes of package archives. completion A helper command used for command completion. debug Show information useful for debugging. help Show help for commands. pip常用指令安装指定的第三方库 1pip install &lt;第三方库名&gt; 使用-U标签更新已安装的指定第三方库 1pip install –U &lt;第三方库名&gt; 卸载指定的第三方库 D:&gt;pip uninstall &lt;第三方库名&gt; 下载但不安装指定的第三方库 D:&gt;pip download &lt;第三方库名&gt; 列出某个指定第三方库的详细信息 D:&gt;pip show &lt;第三方库名&gt; 根据关键词在名称和介绍中搜索第三方库 D:&gt;pip search &lt;关键词&gt; 1pip search blockchain D:&gt;pip list 列出当前系统已经安装的第三方库 第三方库的集成安装方法 Anaconda集成安装：结合特定Python开发工具的批量安装 https://www.continuum.io 支持近800个第三方库 包含多个主流工具 适合数据计算领域开发 Anaconda跟换国内镜像源https://blog.csdn.net/dream_allday/article/details/80344511 文件安装方法为什么有些第三方库用pip可以下载，但无法安装？ 某些第三方库pip下载后，需要编译再安装 如果操作系统没有编译环境，则能下载但不能安装 可以直接下载编译后的版本用于安装吗？ http://www.lfd.uci.edu/~gohlke/pythonlibs/ 实例：安装wordcloud库 步骤1：在UCI页面上搜索wordcloud 步骤2：下载对应版本的文件 步骤3：使用pip install &lt;文件名&gt;安装","categories":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://codeofli.github.io/tags/python/"}]},{"title":"html-css","slug":"front-end/html-css/html-css","date":"2019-10-14T14:19:09.000Z","updated":"2019-11-13T12:20:26.860Z","comments":true,"path":"2019/10/front-end/html-css/html-css/","link":"","permalink":"https://codeofli.github.io/2019/10/front-end/html-css/html-css/","excerpt":"[TOC]初步了解软件的架构C/S，客户端/服务器 1.一般我们使用的软件都是C/S架构 2.比如系统的中的软件QQ、360、office、XMind 3.C表示客户端，用户通过客户端来使用软件 4.S表示服务器，服务器负责处理软件的业务逻辑 特点 1.软件使用前必须得安装 2.软件更新时，服务器和客户端得同时更新 3.C/S架构的软件不能跨平台使用 4.C/S架构的软件客户端和服务器通信采用的是自有协议，相对来说比较安全B/S，浏览器/服务器 1.B/S本质上也是C/S，只不过B/S架构的软件，使用浏览器作为软件的客户端 2.B/S架构软件通过使用浏览器访问网页的形式，来使用软件 3.比如：京东 淘宝 12306 知乎 新浪微博 特点 1.软件不需要安装，直接使用浏览器访问指定的网址即可 2.软件更新时，客户端不需要更新 3.软件可以跨平台，只要系统中有浏览器，就可以使用 4.B/S架构的软件，客户端和服务器之间通信采用的是通用的HTTP协议，相对来说不安全","text":"[TOC]初步了解软件的架构C/S，客户端/服务器 1.一般我们使用的软件都是C/S架构 2.比如系统的中的软件QQ、360、office、XMind 3.C表示客户端，用户通过客户端来使用软件 4.S表示服务器，服务器负责处理软件的业务逻辑 特点 1.软件使用前必须得安装 2.软件更新时，服务器和客户端得同时更新 3.C/S架构的软件不能跨平台使用 4.C/S架构的软件客户端和服务器通信采用的是自有协议，相对来说比较安全B/S，浏览器/服务器 1.B/S本质上也是C/S，只不过B/S架构的软件，使用浏览器作为软件的客户端 2.B/S架构软件通过使用浏览器访问网页的形式，来使用软件 3.比如：京东 淘宝 12306 知乎 新浪微博 特点 1.软件不需要安装，直接使用浏览器访问指定的网址即可 2.软件更新时，客户端不需要更新 3.软件可以跨平台，只要系统中有浏览器，就可以使用 4.B/S架构的软件，客户端和服务器之间通信采用的是通用的HTTP协议，相对来说不安全 乱码的问题乱码出现的原因 计算机是一个非常笨的机器，它只认识两个东西 0 1 在计算机中保存的任何内容，最终都需要转换为0 1这种二进制编码来保存，包括网页中的内容 比如：中国，在计算机底层，可以能需要转换为 1010001001010101011010 在读取内容时，需要将二进制编码，在转换为正确的内容 编码 依据一定的规则，将字符转换为二进制编码的过程 解码 依据一定的规则，将二进制编码转换为字符的过程 字符集 编码和解码所采用的规则，我们称为字符集 常见的字符集 ASCII ISO-8859-1 GBK GB2312 中文系统的默认编码 UTF-8 万国码，支持地球上所有的文字 ANSI 自动以系统的默认编码来保存文件 产生乱码的根本原因是，编码和解码采用的字符集不同 在中文系统的浏览器中，默认都是使用GB2312进行解码的HTML网页的结构一个网页有三个部分组成 结构html结构是页面的整体结构，哪里是标题，哪里是段落，哪里是图片结构使用HTML来编写 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 表现css表现是页面的外在的样式，比如字体，字体大小，字体颜色，背景。。。使用CSS来设置页面中元素的样式 行为js页面和用户之间的交互行为使用JavaScript来设置页面的行为一个设计优良的网页要求结构、表现、行为三者分离在开发中总是要面临一个问题，就是程序之间的耦合，三者分离就是为了解耦合HTML，超文本标记语言负责页面中的结构，定义出页面中的各个组成部分HTML是采用纯文本的形式的编写，采用HTML标签来标识出页面中的不同部分 标签(元素)成对出现 &lt;标签名&gt;&lt;/标签名&gt;自结束标签 &lt;标签名 /&gt; 块元素和内联元素块元素**块元素会独占页面中的一行，无论他的内容的多少** 一般使用块元素对页面进行布局 常见的块元素 div p h1~h6内联元素 **内联元素只占用自身的大小，不会独占一行** 内联元素也叫行内元素（inline） 一般内联元素都是用来为文本来设置效果 常见的内联 span a img 包裹规则 **一般都是使用块元素去包裹内联元素，而不会使用内联去包裹块元素** **a元素可以包含任意元素，除了a本身** **p元素不能包含任何块元素**元素之间的关系父元素 **直接**包含子元素的的元素叫做父元素 子元素 **直接被**父元素包含的元素叫做子元素 祖先元素 **直接或间接**包含后代元素的元素叫做祖先元素，父元素也是祖先元素 后代元素 直接或间接被祖先元素包含的元素叫后代元素，子元素也是后代元素 兄弟元素 拥有**相同父元素**的元素叫做兄弟元素属性通过属性可以设置标签的效果属性需要定义在开始标签中或这自结束标签中属性实际上是一组一组名值对结构例子：&lt;标签名 属性名=”属性值” 属性名=”属性值”&gt;&lt;/标签名&gt;&lt;标签名 属性名=”属性值” 属性名=”属性值” /&gt; 常用标签HTML页面的基本结构文档声明&lt;!doctype html&gt;用来标识当前页面的html的版本该声明用来告诉浏览器，当前的页面是使用HTML5的标准编写的&lt;html&gt;网页的根标签一个页面中有且只有一个根标签网页中的所有内容都需要写在html标签的内部&lt;head&gt;网页的头部该标签中的内容不会在网页中直接显示该标签用于帮助浏览器解析页面子标签&lt;title&gt;用来设置网页的标题默认会在浏览器的标题栏中显示搜索引擎检索网页时，会主要检索title中的内容，它会影响到页面在搜索引擎中的排名&lt;meta&gt;用来设置网页的元数据，比如网页使用的字符集&lt;meta charset=&quot;utf-8&quot; /&gt;设置网页的关键字&lt;meta name=&quot;keywords&quot; content=&quot;关键字,关键字,关键字,关键字&quot;/&gt;设置网页的描述&lt;meta name=&quot;description&quot; content=&quot;网页的描述&quot;/&gt;请求的重定向&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=地址&quot; /&gt;&lt;body&gt;网页的主体网页中所有的可见部分都需要在body中编写&lt;h1&gt; ~ &lt;h6&gt;标题标签在html中一共有六级标题六级标题中，h1最重要，h6最不重要，一般页面中只会使用h1~h3h1的重要性仅次于title，浏览器也会主要检索h1中的内容，以判断页面的主要内容一般一个页面中只能写一个h1&lt;p&gt;段落标签&lt;br /&gt;换行标签&lt;hr /&gt;水平线标签内联框架可以向一个页面中引入其他的外部页面&lt;iframe&gt;``&lt;/iframe&gt;属性src外部页面的地址，可以使用相对路径width和height可以设置框架的宽度和高度name可以为内联框架指定一个名字可以将该属性值设置为超链接的target属性的值这样当点击超链接时，页面将会在相应的内联框架中打开内联框架中的内容不会被搜索引擎所检索，所以开发中尽量不要使用内联框架 &lt;a&gt;超链接 可以使当前页面跳转到其他的页面 &lt;a&gt;链接的文字&lt;/a&gt; 属性 href 指向链接跳转的目标地址，可以是一个相对路径 还可以是#id属性值，这样当点击超链接以后，将会跳转到当前页面的指定位置 可以使用mailto:来创建一个发送电子邮件的超链接 target 指定在哪个窗口中打开链接 可选值 _self 默认值，默认在当前窗口打开链接 _blank 在新窗口中打开链接 内联框架的name属性值 在指定的内联框架中打开链接 语法注释 &lt;!-- 注释内容 --&gt; 注释中的内容不会在页面中显示，但是会在源码中显示，我们可以通过注释来说明网页的代码 也可以通过注释隐藏一些页面中不想显示的内容实体在HTML页面中一些特殊符号是不能直接使用，需要使用实体来代替这些特殊符号 实体也可以称为转义字符实体的语法 &amp;实体名;常用的实体 空格&amp;nbsp; Non-Breaking Space” 的缩写， &lt;&amp;lt; 、&gt;&amp;gt;、版权符号&copy;&amp;copy; 图片标签 使用图片标签可以向页面中引入一个外部图片 属性 src 指向一个外部图片的路径，可以使用相对路径 alt 指定一个在图片无法加载时对图片的描述 搜索引擎主要通过该属性来识别图片的内容 如果不写该属性则搜索引擎会对图片进行收录 width 设置图片的宽度 height 设置图片的高度 图片的格式 JPEG 颜色丰富的图片，如，照片 GIF 颜色单一，简单透明的图片，动态图 PNG 颜色丰富，复杂透明的图片 图片选择的原则 效果一致，用小的 效果不一致，用效果好的相对路径 相对于当前资源所在的目录的路径 可以使用../返回一级目录，返回几级使用几个../xHtml语法规范 1.HTML中不区分大小写，但是尽量使用小写 2.HTML的注释不能嵌套 3.标签必须结构完整 要么成对出现 要么自结束标签 4.标签可以嵌套但是不能交叉嵌套 5.属性必须有值，且值必须加引号，单引号双引号都可以 文本标签 `&lt;em&gt;` 表示语气上的强调 `&lt;strong&gt;` 表示内容的重要性 `&lt;i&gt;` 表示单纯的斜体 `&lt;b&gt;` 表示单纯的加粗 `&lt;small&gt;` 表示细则一类的内容 `&lt;cite&gt;` 表示参考的内容，凡是加书名号的都可以使用cite `&lt;q&gt;` 短引用，行内引用&lt; blockquote&gt; 长引用，块级引用 &lt;sup&gt;上标&lt;sub&gt;下标&lt;del&gt;删除的内容&lt;ins&gt;插入的内容 &lt; pre&gt;预格式标签，可以保留代码中空格换行这些格式&lt; code&gt;表示程序代码 css基础Cascading（级联） Style Sheets(薄片，纸张，覆盖)，层叠样式表 css样式三种方式内联样式可以将css样式编写到元素的style属性中将样式直接编写在style属性中，这样的样式成为内联样式只对当前元素（标签）有效，不方便复用内联样式属于结构与表现耦合，不方便后期维护 12&lt;p style=\"color: red; font-size: 40px\"&gt;锄禾日当午，汗滴禾下土&lt;/p&gt;&lt;p&gt;谁知盘中餐，粒粒皆辛苦&lt;/p&gt; head编写style便签也可以将CSS样式编写到head中的style标签里将样式表编写的style标签中，然后通过CSS选择器选中指定元素然后可以同时为这些元素一起设置样式，这样可以使样式进一步的复用将样式表编写到style标签中，也可以使表现和结构进一步分离它也是我们推荐的使用方式 12345&lt;style type=\"text/css\"&gt; p&#123; color: red; font-size: 40px; &#125;&lt;/style&gt; 外部的CSS文件还可以将样式表编写到外部的CSS文件中,然后通过link标签来将外部的CSS文件引入到当前页面中，这样外部文件中的css样式表将会应用到当前页面中。 将CSS样式统一编写到外部的样式表中，完全使结构和表现分离，可以是样式表可以在不同的页面中使用，最大限度的使样式可以进行复用，将样式统一写在样式表中，然后通过link标签引入，可以利用浏览器的缓存加快用户访问的速度提高了用户体验，所以在开发中我们最推荐使用的方式就是外部的CSS文件 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" /&gt; css语法：选择器、声明块、注释 123456789101112131415161718192021222324&lt;style type=\"text/css\"&gt; /* CSS的注释，作用和HTML注释类似，只不过它必须编写在style标签中，或者是css文件中 CSS的语法： 选择器 声明块 选择器： - 通过选择器可以选中页面中指定的元素， 并且将声明块中的样式应用到选择器对应的元素上 声明块： - 声明块紧跟在选择器的后边，使用一对&#123;&#125;括起来， 声明块中实际上就是一组一组的名值对结构， 这一组一组的名值对我们称为声明， 在一个声明块中可以写多个声明，多个声明之间使用;隔开， 声明的样式名和样式值之间使用:来连接 */ p&#123; color:red; font-size:50px; &#125;&lt;/style&gt; 单位长度单位**px** 像素，像素就是构成一个图片的最小的单位，我们的屏幕就是由一个一个像素点构成 一个像素指的就是一个像素点 在不同的显示器中，一个像素的大小是不同的，越清晰的屏幕像素越小 % 可以将一个元素的样式值设置为一个百分比的值，这样浏览器将会根据父元素的值去计算出相应的值 当父元素的值改变时，子元素的值会按照一定比例一起改变，经常用于自适应的页面 em em会相对于当前元素的字体大小来计算 1em = 1font-size em经常用于设置文字相关的一些样式，因为当文字大小发生改变时，em会随之改变 rem…. 颜色单位颜色单词 直接使用英文单词来表示颜色 red green blue orangeRGB值 所谓RGB值就是通过红 绿 蓝三元色的不同组合来搭配出各种不同的颜色语法：rgb(红色,绿色,蓝色)这三个值需要一个0-255之间的值 0表示没有 255表示最大 rgb(50,200,30)也可以使用百分数来设置RGB值，需要0%-100%之间的值 百分数最终也是转换为0-255的 0%相当于0 100%相当于255 rgb(100%,0%,0%)十六进制RGB值也是一种RGB值的表示方式，不同的是它使用的是16进制数字来表示而不是语法： #红色绿色蓝色这里的颜色需要一个00-ff之间的值例子： #ff0000如果颜色的是两位两位重复的，可以进行简写 比如 #aabbcc 可以写成 #abc 比如 #bbffaa 可以写成 #bfa 文本样式字体color 字体的颜色font-size 字体的大小 浏览器中默认的字体大小一般都是16px，而我们开发时一般会统一为12pxfont-family 设置文字的字体font-style 设置斜体font-weight 设置文字的加粗font-variant 小型大写字母font文字的简写属性可以同时设置所有的字体相关的样式语法： font: [加粗 斜体 小大字母] 大小[/行高] 字体加粗，斜体，小大字母，顺序无所谓，写不写都行，如果不写在使用默认值文本大小，和字体必须写，且大小必须是倒数第二个，字体必须是最后一个大小后可以设置行高，可写可不写，如果不写则使用默认值 文本样式 line-height 行高** 文本默认都是在行高中垂直居中的 通过line-height可以修改行高 行间距 = 行高 - 字体大小** text-transform 设置文本的大小写可选值： none 默认值，该怎么显示就怎么显示，不做任何处理 capitalize 单词的首字母大写，通过空格来识别单词 uppercase 所有的字母都大写 lowercase 所有的字母都小写 text-decoration 设置文本修饰123456a &#123; /*超链接会默认添加下划线，也就是超链接的text-decoration的默认值是underline 如果需要去除超链接的下划线则需要将该样式设置为none * */ text-decoration: none;&#125; text-align 设置文本对齐 text-indent 设置首行缩进 它需要一个长度单位，如果是正值则首行向右移动，如果是负值则向左移动1234567/** text-indent用来设置首行缩进* 当给它指定一个正值时，会自动向右侧缩进指定的像素* 如果为它指定一个负值，则会向左移动指定的像素,* 通过这种方式可以将一些不想显示的文字隐藏起来* 这个值一般都会使用em作为单位*/ letter-spacing 字符间距word-spacing 单词间距 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 在CSS并没有为我们提供一个直接设置行间距的方式， * 我们只能通过设置行高来间接的设置行间距，行高越大行间距越大 * 使用line-height来设置行高 * 行高类似于我们上学单线本，单线本是一行一行，线与线之间的距离就是行高， * 网页中的文字实际上也是写在一个看不见的线中的，而文字会默认在行高中垂直居中显示 * * 行间距 = 行高 - 字体大小 */.p1&#123; font-size: 20px; /* * 通过设置line-height可以间接的设置行高， * 可以接收的值： * 1.直接就收一个大小 * 2.可以指定一个百分数，则会相对于字体去计算行高 * 3.可以直接传一个数值，则行高会设置字体大小相应的倍数 */ /*line-height: 200%;*/ line-height: 2;&#125;.box&#123; width: 200px; height: 200px; round-color: #bfa; /* * 对于单行文本来说，可以将行高设置为和父元素的高度一致， * 这样可以是单行文本在父元素中垂直居中 */ line-height: 200px;&#125;.p2&#123; /* * 在font中也可以指定行高 * 在字体大小后可以添加/行高，来指定行高，该值是可选的，如果不指定则会使用默认值 */ font: 30px \"微软雅黑\"; line-height: 50px;&#125; 选择器通过选择器可以选中页面中的一组元素，然后为其设置样式 基础选择器元素选择器根据标签名，选中页面中的指定元素语法：标签名{ }例子： 123div&#123;&#125;p&#123;&#125;h1&#123;&#125; id选择器根据元素的id属性值选中一个唯一的元素语法：#id {}例子： 12#box1&#123;&#125;#hello&#123;&#125; 类选择器我们可以为元素设置class属性， class属性和id属性类似，只不过class属性可以重复 拥有相同class属性值的元素，我们说他们是一组元素 可以同时为一个元素设置多个class属性值，多个值之间使用空格隔开 根据元素的class属性值，选中一组元素语法：.class{}例子： 12.hello&#123;&#125;.box&#123;&#125; 通配选择器选中页面中的所有元素语法：*{}通配选择器的性能比较差，尽量避免使用 并集选择器可以同时选中符合多个选择器的元素语法：选择器1,选择器2,选择器N{}例子： 1div,p,#box,.hello&#123;&#125; 交集选择器对于id选择器来说，不建议使用复合选择器,因为id已经能唯一标识 可以选中满足多个条件的元素 先元素再类 语法：选择器1选择器2选择器N{} 例子： 1p.hello&#123;&#125; 后代元素选择器选中指定元素的指定后代元素语法：祖先元素 （空格）后代元素{}例子： 12div span &#123;&#125;div p&#123;&#125; 子元素选择器选中指定元素的指定子元素语法：父元素 &gt; 子元素 {}例子： 12div &gt; span &#123;&#125;div &gt; p&#123;&#125; 声明块声明块中实际上就是一个一个CSS声明声明每一个CSS声明都是一个样式，实际上就是一个名值对的结构名和值之间使用:链接:左边是样式的名字:右边是样式的值每一个声明以;结尾例子 12color:red;font-size:20px; 伪类和伪元素伪类和伪元素用来表示元素所处的一个特殊的状态，或者是一个特殊的位置 伪类：:link 表示一个普通的链接（未访问过的链接）:visited 表示访问过的链接 浏览器是通过历史记录来判断一个链接是否访问过,由于涉及到用户的隐私问题，所以使用visited伪类只能设置字体的颜色 :hover（盘旋，徘徊） 鼠标移入的链接，也可以为其他元素设置hover :active 正在被点击的链接，也可以为其他元素设置active :focus 表示元素获取焦点的状态，一般用于文本框 ::selection（注意有两个冒号） 表示内容被选中的状态 在火狐中使用::-moz-selection来代替伪元素：:first-letter 表示第一个字符 :first-line 表示文字的第一行 :before 选中元素的最前边 一般该伪类都会结合content一起使用，通过content可以向指定位置添加内容 :after 选中元素的最后边 一般该伪类都会结合content一起使用，通过content可以向指定位置添加内容 属性选择器根据元素的属性选择指定元素 [属性名] 选取含有指定属性的元素 [属性名=&quot;属性值&quot;] 选取属性值等于指定值的元素 [属性名^=&quot;属性值&quot;] 选取属性值以指定内容**开头的元素** [属性名$=&quot;属性值&quot;] 选取属性值以指定内容结尾的元素 [属性名*=&quot;属性值&quot;] 选取属性值中**包含指定内容的元素**子元素的伪类:first-child 寻找父元素的第一个子元素，**在所有的子元素中排序**（前面不指定特定元素就表示全部元素,指定就是交集选择器） :last-child 寻找父元素的最后一个子元素，在所有的子元素中排序 :nth-child 寻找父元素中的指定位置子元素，在所有的子元素中排序 例子 p:nth-child(3) 可以使用even，来找到偶数的子元素 可以使用odd，来找到奇数的子元素 :first-of-type 寻找指定类型中的第一个子元素 :last-of-type 寻找指定类型中的最后一个子元素 :nth-of-type 寻找指定类型中的指定子元素:empty Selects elements that don’t have any other elements inside of them. div:empty selects all empty elements. :nth-of-type(A) Selects a specific element based on its type and order in another element - or even or odd instances of that element. div:nth-of-type(2) selects the second instance of a div. .example:nth-of-type(odd) selects all odd instances of a the example class. :only-child You can select any element that is the only element inside of another one. :nth-last-child(A) Selects the children from the bottom of the parent. This is like nth-child, but counting from the back! Nth-of-type Selector with Formula :nth-of-type(An+B) The nth-of-type formula selects every nth element, starting the count at a specific instance of that element. span:nth-of-type(6n+2) selects every 6th instance of a span, starting from (and including) the second instance. :only-of-type Selects the only element of its type within another element. p span:only-of-type selects a span within any p if it is the only span in there. 兄弟元素选择器**选取后一个兄弟元素** 前一个 + 后一个 选取后边所有的兄弟元素 前一个 ~ 后边所有否定伪类从一组元素中将符合要求的元素剔除出去 语法： :not(选择器) 例子： .abc:not(div)样式的继承为祖先元素设置样式，会同时应用到它的后代元素上，这一特性称为样式的继承。 通过样式的继承可以将一些样式统一设置个祖先元素，这样所有的后代都会应用到相同的样式。 但是并不是所有的样式都会继承，比如：背景相关的，边框相关的，定位相关的。具体参考文档选择器的优先级当使用选择器为元素设置样式时，如果样式发生了冲突，采用哪个样式由选择器的优先级（权重）来决定。 越精准，越优先 优先级 内联样式1000 id选择器100 类和伪类选择器10 元素选择器1 通配选择器0 继承的样式：没有优先级当样式发生冲突时，需要将相关的选择器优先级进行求和计算，优先级高的优先显示，如果优先级一样，则显示靠后的样式（覆盖） 优先级计算时，总大小不能超过他的最大的数量级 可以在样式后边添加一个!important，如果样式中添加了该内容，则该样式将会获取最大的优先级，将会优先于所有的样式显示，包括内联样式，但是这个属性要慎用。 盒子模型CSS 框模型Box Model CSS中将每一个元素都设置为了一个矩形的盒子将所有的元素都设置为盒子，是为了方便页面的布局当这些元素都是盒子以后，我们的布局就变成了在页面中摆放盒子 盒子模型构成每个盒子都由如下几部分构成 4 内容区： content内容区相当于盒子存放东西的空间 内容区在盒子的最里边 元素的所有的子元素都是放在父元素的内容区 内容区设置 width 内容区的宽度 height 内容区的高度边框 border边框盒子可见框最外侧，边框是盒子的边缘 设置边框 **设置边框需要同时设置三个样式，缺一不可** border-width 边框的宽度 可以同时指定四个边框的宽度，也可以分别指定 规则 四个值 border-width : 10px 20px 30px 40px; border-width : 上 右 下 左;(顺时针) 三个值 border-width : 10px 20px 30px; border-width : 上 左右 下 ; 两个值 border-width : 10px 20px; border-width : 上下 左右 ; 一个值 border-width : 10px; border-width : 上下左右 ; border-color 边框的颜色 border-style 边框的样式 除了这三个样式，CSS中还提供了 border-xxx-width border-xxx-color border-xxx-style xxx可以是 top right bottom left 通过这些样式可以单独指定四个边的颜色，宽度和样式 边框的简写属性 border border-left border-top border-right border-bottom12border: red solid 10px ;border-left: red solid 10px ; 这个几个属性可以同时设置边框相关的的样式 **border可以同时设置四个边的颜色，宽度，样式** **border-xxx可以单独设置某一个边** 规则 使用这些样式可以同时设置border-width border-style border-color，不同的属性使用空格隔开，并且**没有顺序要求**内边距： padding内边距指的是内容区和边框之间的距离，内边距会影响盒子的大小 盒子中一共有四个方向的内边距 padding-top padding-right padding-bottom padding-left padding 可以同时设置四个方向的内边距，规则和border-width一致 padding:上 右 下 左 padding:上 左右 下 padding:上下 左右 padding:上下左右 **盒子的可见框大小由内容区、内边距和边框共同决定**外边距 margin外边距盒子和其他盒子之间的距离，外边距不会影响可见框的大小，但是会影响盒子的位置 也是具有四个方向的外边距 margin-top margin-right margin-bottom margin-left 简写属性 margin 规则和padding一致 margin值 可以设置为auto **如果单独将左右外边距设置为auto**，则会将左或右外边距设置为最大值 如果同时将**左右外边距设置为auto，则会将左右外边距设置为一个相等的值**，通过这种方式使一个子元素在它的父元素中水平居中 **margin:0 auto** **可以设置为负值** 如果将margin设置为负值，则元素会向相反的方向移动外边距的重叠 相邻的垂直外边距会发生重叠现象 相邻元素的外边距会取最大值 子元素的外边距会传递给父元素 水平外边距不会重叠，而是取和 内联元素的盒子模型内联元素不能设置width和heightpadding 支持水平方向的padding 垂直方向的padding也支持，但是不会影响布局border 支持四个方向边框，但是垂直的边框不会影响布局margin 支持水平方向外边距，水平方向的相邻外边距不会重叠，而是求和 不支持垂直方向的盒模型相关的样式 CSS 定位属性（Positioning）display设置元素的显示类型可选值none 元素不会在页面中显示，并且不会占据页面的位置block 元素会作为块元素显示inline 元素会作为内联元素显示inline-block 元素会作为行内块元素显示 既具有内联元素的特点也具有块元素的特点 既不独占一行，又可以设置宽高 visibility设置元素是否在页面中显示可选值visible 默认值，元素在页面中正常显示hidden 元素不在页面中显示，但是依然在页面中占据位置 overflow设置元素如何处理溢出内容可选值visible 默认值，不会处理溢出的内容，在父元素以外的地方显示hidden 溢出的内容会被隐藏不会显示scroll 在父元素中同时添加水平和垂直方向的滚动条 不内容是否溢出都会添加滚动条auto 根据需要自动生成滚动条 布局文档流文档流指的是网页中的一个位置文档流是网页的基础，是网页的最底层，所有的元素默认都是在文档流中排列元素在文档流中默认自左向右，自上向下排列（和我们的书写习惯一致）块元素 1.块元素在文档流中自上向下排列 2.块元素在文档流中宽度默认是父元素的100%(auto) 3.块元素在文档流中高度默认被内容撑开内联元素 1.内联元素在文档流中自左向右排列，如果一行中不足以容下所有的内联元素，则换到下一行，继续自左至右排列 2.内联元素在文档流中宽度和高度默认都被内容撑开 浮动使用float来设置元素浮动可选值none 默认值，不浮动，元素在文档流中left 元素向左浮动right 元素向右浮动特点1.元素浮动以后会完全脱离文档流2.浮动以后元素会一直向父元素的最上方移动3.直到遇到父元素的边框或者其他的浮动元素，会停止移动4.如果浮动元素的上边是一个块元素，则浮动元素不会覆盖块元素5.浮动元素不会超过他上边的浮动的兄弟元素，最多一边齐6.浮动元素不会覆盖文字，文字会自动环绕在浮动元素的周围，可以通过浮动来实现文字环绕的效果浮动以后元素的特点元素浮动以后，会使其完全脱离文档流。块元素 块元素脱离文档流以后 1.不会独占一行 2.宽度和高度都被内容撑开内联元素 内联元素脱离文档流以后会变成块元素 高度塌陷父元素在文档流中高度默认是被子元素撑开的，当子元素脱离文档流以后，将无法撑起父元素的高度，也就会导致父元素的高度塌陷父元素的高度一旦塌陷所有元素的位置将会上移，导致整个页面的布局混乱 我们可以将父元素的高度写死，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。 方法一 开启父元素的BFC或hasLayoutBFC:Block Formatting Context,块级格式化环境 BFC是元素的隐含属性，默认是在关闭状态的可以通过一些特殊的样式，来开启BFC开启BFC以后元素将会具有如下特性1、父元素的垂直外边距不会与子元素重叠2、开启BFC的元素不会被浮动元素所覆盖3、开启BFC的元素可以包含浮动子元素 开启BFC的方式1.设置元素浮动 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失 且使用这种方式也会导致下边的元素上移，不能解决问题2.设置元素绝对定位3.设置元素为inline-block 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式4.将元素的overflow设置为一个非visible的值 推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。 一般都是使用overflow:hidden来开启BFChasLayout 在IE6中没有BFC，但是有一个和BFC类似的hasLayout 在IE6中可以通过开启hasLayout来解决高度塌陷的问题 副作用最小的开启方式 zoom:1 当为元素设置宽度非默认值时，会自动开启hasLayout 方法二：清除浮动clear可以用来清除其他浮动元素对当前元素的影响可选值：none，默认值，不清除浮动left，清除左侧浮动元素对当前元素的影响right，清除右侧浮动元素对当前元素的影响both，清除两侧浮动元素对当前元素的影响 清除对他影响最大的那个元素的浮动清除浮动以后，元素会回到其他元素浮动之前的位置 塌陷的父元素的最后添加一个空白的div，然后对该div进行**清除浮动** 然基本没有副作用，使用这种方式会在页面中添加多余的结构方法三用after伪类，向父元素后添加一个块元素，并对其清除浮动 种方式的原理和方法二原理一样，但是不用向页面中添加对于的结构,这是我们最推荐使用的方式，几乎没有副作用12345678.clearfix:after&#123; /*添加一个内容*/ content: \"\"; /*转换为一个块元素*/ display: block; /*清除两侧的浮动*/ clear: both;&#125; 定位通过定位可以将页面中的元素，摆放到页面的任意位置使用position来设置元素的定位 123456789可选值static 默认值，元素没有开启定位relative 开启元素的相对定位absolute 开启元素的绝对定位fixed 开启元素的固定定位 偏移量当元素开启了定位以后，可以通过偏移量来设置元素的位置。 靠近中心是正数，远离是负数。 12345678left 元素距离定位位置的左侧距离top 元素距离定位位置的上边距离right 元素距离定位位置的右侧距离bottom 元素距离定位位置的底部距离 一般情况下，只使用两个值即可定义一个元素的位置。 相对定位：ralative1.开启元素的相对定位后，如果不设置偏移量元素不会发生任何变化2.相对定位元素相对于其自身在文档流中的位置来定位3.相对定位的元素不会脱离文档流4.相对定位不会改变元素的性质，块元素还是块元素，内联元素还是内联元素5.相对定位的元素会提升一个层级，会覆盖其他元素 绝对定位： absolute1.元素设置绝对定位以后，如果不设置偏移量，元素的位置不会发生变化2.绝对定位的元素是相对于距离他最近的开启了定位的祖先元素进行定位（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位，子绝父相），如果所有的祖先元素都没开启定位，则相对于浏览器窗口进行定位。3.绝对定位的元素会完全脱离文档流4.绝对定位会改变元素的性质。内联变块，块的高度和宽度都被内容撑开，并且不独占一行5.绝对定位会使元素提升一个层级，会覆盖其他元素 固定定位:fixed固定定位是一种特殊的绝对定位，它的特点大部分都和绝对定位一样.不同的是，固定定位的元素永远都是相对于浏览器窗口进行定位的。并且他不会随滚动条滚动IE6不支持固定定位 层级定位元素 &gt; 浮动元素 &gt; 文档流中的元素 如果定位元素的层级是一样，则下边的元素会盖住上边的 当元素开启了定位以后，可以通过z-index来设置元素的层级1.z-index值越高元素越优先显示2.如果z-index值一样，或者都没有z-index则优先显示下边的元素3.父元素永远不会盖住子元素 其他 css属性设置元素的透明背景opacity可以用来设置元素背景的透明，它需要一个0-1之间的值 0 表示完全透明 1 表示完全不透明 0.5 表示半透明 opacity属性在IE8及以下的浏览器中不支持IE8及以下的浏览器需要使用如下属性代替alpha(opacity=透明度) filter: alpha(opacity=50);透明度，需要一个0-100之间的值 0 表示完全透明 100 表示完全不透明 50 半透明 background属性使用backgroundimage来设置背景图片 语法：backgroundimage:url(相对路径); 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素大小，则会默认将背景图片平铺以充满元素 可以同时为一个元素指定背景颜色和背景图片，这样背景颜色将会作为背景图片的底色一般情况下设置背景图片时都会同时指定一个背景颜色 1backgroundimage:url(img2.jpg); backgroundrepeat用于设置背景图片的重复方式可选值： repeat，默认值，背景图片会双方向重复（平铺） norepeat ，背景图片不会重复，有多大就显示多大 repeatx， 背景图片沿水平方向重复 repeaty，背景图片沿垂直方向重复 background-position背景图片默认是贴着元素的左上角显示通过background-position可以调整背景图片在元素中的位置可选值：该属性可以使用 top right left bottom center中的两个值 来指定一个背景图片的位置 top left 左上 bottom right 右下 如果只给出一个值，则第二个值默认是center 也可以直接指定两个偏移量， 第一个值是水平偏移量 如果指定的是一个正值，则图片会向右移动指定的像素 如果指定的是一个负值，则图片会向左移动指定的像素 第二个是垂直偏移量 如果指定的是一个正值，则图片会向下移动指定的像素 如果指定的是一个负值，则图片会向上移动指定的像素 background-attachment用来设置背景图片是否随页面一起滚动可选值： scroll，默认值，背景图片随着窗口滚动 fixed，背景图片会固定在某一位置，不随页面滚动 不随窗口滚动的图片，我们一般都是设置给body，而不设置给其他元素 当背景图片的backgroundattachment设置为fixed时，背景图片的定位永远相对于浏览器的窗口 backgroundattachment: fixed; 常用标签span没有任何的语义，span标签专门用来选中文字，然后为文字来设置样式 a元素可以包含任意元素，除了他本身 p元素不可以包含任何块元素 div这个标签没有任何语义，就是一个纯粹的块元素，并且不会为它里边的元素设置任何的默认样式， div元素主要用来对页面进行布局的 form表单表单的作用就是用来将用户信息提交给服务器的 比如：百度的搜索框 注册 登录这些操作都需要填写表单 使用form标签创建一个表单 action属性 *form标签中必须指定一个，该属性指向的是一个服务器的地址** 我们提交表单时将会提交到action属性对应的地址input框 使用input来创建一个文本框，它的type属性是text 如果希望表单项中的数据会提交到服务器中，还必须给表单项指定一个name属性 name表示提交内容的名字 用户填写的信息会附在url地址的后边以查询字符串的形式发送给服务器 url地址?查询字符串格式： 属性名=属性值&amp;属性名=属性值&amp;属性名=属性值&amp;属性名=属性值在文本框中也可以指定value属性值，该值将会作为文本框的默认值显示 单选按钮 使用input来创建一个单选按钮，它的type属性使用radio 单选按钮通过name属性进行分组，name属性相同是一组按钮 像这种需要用户选择但是不需要用户直接填写内容的表单项， 还必须指定一个value属性，这样被选中的表单项的value属性值将会最终提交给服务器 如果希望在单选按钮或者是多选框中指定默认选中的选项， 则可以在希望选中的项中添加checked=”checked”属性 多选框 使用input创建一个多选框，它的type属性使用checkbox 下拉列表 使用select来创建一个下拉列表下拉列表的name属性需要指定给select，而value属性需要指定给option可以通过在option中添加selected=”selected”来将选项设置为默认选中 当为select添加一个multiple=”multiple”，则下拉列表变为一个多选的下拉列表 12345678910111213141516171819202122你喜欢的明星 &lt;select name=\"star\"&gt;&lt;!-- 在select中可以使用optgroup对选项进行分组 同一个optgroup中的选项是一组 可以通过label属性来指定分组的名字 --&gt; &lt;optgroup label=\"女明星\"&gt; &lt;!-- 在下拉列表中使用option标签来创建一个一个列表项 --&gt; &lt;option value=\"fbb\"&gt;范冰冰&lt;/option&gt; &lt;option value=\"lxr\"&gt;林心如&lt;/option&gt; &lt;option value=\"zw\"&gt;赵薇&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=\"男明星\"&gt; &lt;option value=\"ldh\"&gt;刘德华&lt;/option&gt; &lt;option value=\"pcj\"&gt;潘长江&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;&lt;br /&gt;&lt;br /&gt; textarea使用textarea创建一个文本域按钮 提交按钮可以将表单中的信息提交给服务器使用input创建一个提交按钮,它的type属性值是submit在提交按钮中可以通过value属性来指定按钮上的文字 可以创建一个重置按钮， 点击重置按钮以后表单中内容将会恢复为默认值 使用input type=button可以用来创建一个单纯的按钮， 这个按钮没有任何功能，只能被点击 除了使用input，也可以使用button标签来创建按钮这种方式和使用input类似，只不过由于它是成对出现的标签 使用起来更加的灵活 123&lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;button type=\"reset\"&gt;重置&lt;/button&gt;&lt;button type=\"button\"&gt;按钮&lt;/button&gt; 标签label 在html中还为我们提供了一个标签，专门用来选中表单中的提示文字的label标签该标签可以指定一个for属性，该属性的值需要指定一个表单项的id值 在点击标签时，相当于对for的表单向选中 12&lt;label for=\"um\"&gt;用户名&lt;/label&gt;&lt;input id=\"um\" type=\"text\" name=\"username\" /&gt; &lt;br/&gt; fieldset 在表单中可以使用fieldset来为表单项进行分组，可以将表单项中的同一组放到一个fieldset中 12345678&lt;fieldset&gt; &lt;!-- 在fieldset可以使用legend子标签，来指定组名 --&gt; &lt;legend&gt;用户信息&lt;/legend&gt; &lt;label for=\"um\"&gt;用户名&lt;/label&gt; &lt;input id=\"um\" type=\"text\" name=\"username\" /&gt; &lt;br /&gt; &lt;label for=\"pwd\"&gt;密码 &lt;/label&gt; &lt;input id=\"pwd\" type=\"pwd\" name=\"password\"/&gt;&lt;br /&gt;&lt;/fieldset&gt; table表格CSS border-collapse 属性 123table&#123; border-collapse:collapse;&#125; separate 默认值。边框会被分开。不会忽略 border-spacing 和 empty-cells 属性。 collapse 如果可能，边框会合并为一个单一的边框。会忽略 border-spacing 和 empty-cells 属性。 inherit 规定应该从父元素继承 border-collapse 属性的值。 标签的 colspan. rowspan 属性 值 描述 number 设置单元格可横跨的列(行）数。 caption 元素定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 列表列表就相当于去超市购物时的那个购物清单， 在HTML也可以创建列表，在网页中一共有三种列表： 1.无序列表 2.有序列表 3.定义列表 序列表 使用ul(unordered list)来创建一个无序列表，在列表中使用li来表示一个列表项 无序列表使用符号作为项目符号 序列表 使用ol(ordered list)来创建一个无序列表，在列表中使用li来表示一个列表项 使用有序的序号作为项目符号 义列表 表相关的元素都是块元素，他们之间可以互相嵌套 除项目符号 list-style:noneframeset框架集框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面， 框架集可以同时引入多个页面，而内联框架只能引入一个， 在h5标准中，推荐使用框架集，而不使用内联框架 使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中 所以要使用框架集，页面中就不可以使用body标签 属性： rows，指定框架集中的所有的框架，一行一行的排列 cols， 指定框架集中的所有的页面，一列一列的排列 这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小 frameset中也可以再嵌套frameset frameset和iframe一样，它里边的内容都不会被搜索引擎所检索， 所以如果搜索引擎检索到的页面是一个框架页的话，它是不能去判断里边的内容的使用框架集则意味着页面中不能有自己的内容，只能引入其他的页面，而我们每单独加载一个页面 浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求，用户的体验比较差如果非得用建议使用frameset而不使用iframe 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;frameset cols=\"30% , * , 30%\"&gt; &lt;!-- 在frameset中使用frame子标签来指定要引入的页面 引入几个页面就写几个frame --&gt; &lt;frame src=\"table.html\" /&gt; &lt;frame src=\"form.html\" /&gt; &lt;!-- 嵌套一个frameset --&gt; &lt;frameset rows=\"30%,50%,*\"&gt; &lt;frame src=\"04.表格的布局.html\" /&gt; &lt;frame src=\"05.完善clearfix.html\" /&gt; &lt;frame src=\"06.表单.html\" /&gt; &lt;/frameset&gt; &lt;/frameset&gt;&lt;/html&gt; CSS3 @media 查询如果文档宽度小于 300 像素则修改背景颜色(background-color): 12345@media screen and (max-width: 300px) &#123; body &#123; background-color:lightblue; &#125;&#125; min-height 属性设置元素的最小高度。设置以后：不能修改为小于此高度的距离 css hack 能有效识别低版本ie，具体八度 clearfix 1234567891011121314151617解决父子元素的外边距重叠.box1:before&#123;content: \"\"; display:table可以将一个元素设置为表格显示 display: table;&#125;解决父元素高度塌陷.clearfix:after&#123;content: \"\";display: block;clear: both;&#125; 经过修改后的clearfix是一个多功能的既可以解决高度塌陷，又可以确保父元素和子元素的垂直外边距不会重叠 123456.clearfix:before,.clearfix:after&#123;content: \"\";display: table;clear: both;&#125; 长表格有一些情况下表格是非常的长的， 这时就需要将表格分为三个部分，表头，表格的主体，表格底部在HTML中为我们提供了三个标签： thead 表头 tbody 表格主体 tfoot 表格底部 这三个标签的作用，就来区分表格的不同的部分，他们都是table的子标签， 都需要直接写到table中，tr需要写在这些标签当中 thead中的内容，永远会显示在表格的头部tfoot中的内容，永远都会显示表格的底部tbody中的内容，永远都会显示表格的中间 如果表格中没有写tbody，浏览器会自动在表格中添加tbody并且将所有的tr都放到tbody中，所以注意tr并不是table的子元素，而是tbody的子元素通过table &gt; tr 无法选中行 需要通过tbody &gt; tr css精灵图CSS-Sprite 做完功能以后，发现在第一次切换图片时，会发现图片有一个非常快的闪烁，这个闪烁会造成一次不佳的用户体验。产生问题的原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发送一次请求，但是我们外部资源并不是同时加载，浏览器会在资源被使用才去加载资源我们这个练习，一上来浏览器只会加载link.png由于hover和active的状态没有马上触发， 所以hover.png和active.png并不是立即加载的当hover被触发时，浏览器才去加载hover.png当active被触发时，浏览器才去加载active.png由于加载图片需要一定的时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况 为了解决该问题，可以将三个图片整合为一张图片，这样可以同时将三张图片一起加载，就不会出现闪烁的问题了，然后在通过background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（CSS-Sprite,css精灵图）优点： 1 将多个图片整合为一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片， 提高访问效率，提高了用户体验。 2 将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验 title属性**，这个属性可以给任何标签指定当鼠标移入到元素上时，元素中的title属性的值将会作为提示文字显示 我是一个段落 **浏览器默认样式** 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多的元素都设置了一些默认的margin和padding，而它的这些默认样式，正常情况下我们是不需要使用的。所以我们往往在编写样式之前需要将浏览器中的默认的margin和padding统统的去掉清除浏览器的默认样式 1234*&#123;margin: 0;padding: 0;&#125; 这种方式支持IE6，但是这种效果在IE Tester中无法测试 字体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .p1&#123; /*设置字体颜色,使用color来设置文字的颜色*/ color: red; /* * 设置文字的大小,浏览器中一般默认的文字大小都是16px font-size设置的并不是文字本身的大小， 在页面中，每个文字都是处在一个看不见的框中的 我们设置的font-size实际上是设置格的高度，并不是字体的大小 一般情况下文字都要比这个格要小一些，也有时会比格大， 根据字体的不同，显示效果也不能 * */ font-size: 30px; /* * 通过font-family可以指定文字的字体 * 当采用某种字体时，如果浏览器支持则使用该字体， * 如果字体不支持，则使用默认字体 * 该样式可以同时指定多个字体，多个字体之间使用,分开 * 当采用多个字体时，浏览器会优先使用前边的字体， * 如果前边没有在尝试下一个 */ /*font-family: arial , 微软雅黑;*/ /* * 浏览器使用的字体默认就是计算机中的字体， * 如果计算机中有，则使用，如果没有就不用 * * 在开发中，如果字体太奇怪，用的太少了，尽量不要使用， * 有可能用户的电脑没有，就不能达到想要的效果。 */ /*font-family: 华文彩云 , arial , 微软雅黑;*/ font-family: \"curlz mt\"; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"p1\"&gt; 我是一个p标签，ABCDEFGabcdefg &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 字体分类： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; p&#123; font-family: arial , 微软雅黑 , 华文彩云 , serif; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 在网页中将字体分成5大类： serif（衬线字体） sans-serif（非衬线字体） monospace （等宽字体） cursive （草书字体） fantasy （虚幻字体） 可以将字体设置为这些大的分类,当设置为大的分类以后， 浏览器会自动选择指定的字体并应用样式 一般会将字体的大分类，指定为font-family中的最后一个字体 --&gt; &lt;p style=\"font-size: 50px; font-family: serif;\"&gt;衬线字体：我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;p style=\"font-size: 50px; font-family: sans-serif;\"&gt;非衬线字体：我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;p style=\"font-size: 50px; font-family: monospace;\"&gt;等宽字体：我是一段文字，IHABCDEFGabcdefg&lt;/p&gt; &lt;p style=\"font-size: 50px; font-family: cursive;\"&gt;草书字体：我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;p style=\"font-size: 50px; font-family: fantasy;\"&gt;虚幻字体：我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 字体其他样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .p1&#123; color: red; font-size: 30px; font-family: \"微软雅黑\"; /* * font-style可以用来设置文字的斜体 * - 可选值： * normal，默认值，文字正常显示 * italic 文字会以斜体显示 * oblique 文字会以倾斜的效果显示 * - 大部分浏览器都不会对倾斜和斜体做区分， * 也就是说我们设置italic和oblique它们的效果往往是一样的 * - 一般我们只会使用italic */ font-style: italic; /* * font-weight可以用来设置文本的加粗效果： * 可选值： * normal，默认值，文字正常显示 * bold，文字加粗显示 * * 该样式也可以指定100-900之间的9个值， * 但是由于用户的计算机往往没有这么多级别的字体，所以达到我们想要的效果 * 也就是200有可能比100粗，300有可能比200粗，但是也可能是一样的 */ font-weight: bold; /* * font-variant可以用来设置小型大写字母 * 可选值： * normal，默认值，文字正常显示 * small-caps 文本以小型大写字母显示 * * 小型大写字母： * 将所有的字母都以大写形式显示，但是小写字母的大写， * 要比大写字母的大小小一些。 */ font-variant: small-caps ; &#125; .p2&#123; /*设置一个文字大小*/ font-size: 50px; /*设置一个字体*/ font-family: 华文彩云; /*设置文字斜体*/ font-style: italic; /*设置文字的加粗*/ font-weight: bold; /*设置一个小型大写字母*/ font-variant: small-caps; &#125; .p3&#123; /* * 在CSS中还为我们提供了一个样式叫font， * 使用该样式可以同时设置字体相关的所有样式, * 可以将字体的样式的值，统一写在font样式中，不同的值之间使用空格隔开 * * 使用font设置字体样式时，斜体 加粗 小大字母，没有顺序要求，甚至可写可不写， * 如果不写则使用默认值，但是要求文字的大小和字体必须写，而且字体必须是最后一个样式 * 大小必须是倒数第二个样式 * * 实际上使用简写属性也会有一个比较好的性能 */ font: small-caps bold italic 60px \"微软雅黑\"; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"p3\"&gt;我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;p class=\"p1\"&gt;我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;p class=\"p2\"&gt;我是一段文字，ABCDEFGabcdefg&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"学习笔记-前端","slug":"学习笔记-前端","permalink":"https://codeofli.github.io/categories/学习笔记-前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://codeofli.github.io/tags/前端/"},{"name":"html","slug":"html","permalink":"https://codeofli.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://codeofli.github.io/tags/css/"}]},{"title":"git","slug":"git/git","date":"2019-10-13T14:19:09.000Z","updated":"2019-11-13T12:18:59.502Z","comments":true,"path":"2019/10/git/git/","link":"","permalink":"https://codeofli.github.io/2019/10/git/git/","excerpt":"[TOC]特点：分布式版本控制系统优势： SVN在开发过程中必须保证需要与SVN服务器连接才能使用，需要联网基础操作1、设置全局信息1234567设置开发者的用户名 git config --global user.name nicolas设置开发者邮箱 git config --global user.email 1162314270@qq.com取得全部的全局信息 git config --list git config -l","text":"[TOC]特点：分布式版本控制系统优势： SVN在开发过程中必须保证需要与SVN服务器连接才能使用，需要联网基础操作1、设置全局信息1234567设置开发者的用户名 git config --global user.name nicolas设置开发者邮箱 git config --global user.email 1162314270@qq.com取得全部的全局信息 git config --list git config -l 2、创建仓库1、创建目录当做仓库目录2、进入目录中配置将目录变为仓库目录，需要进入目录中配置3、初始化仓库方法一：创建一个包含有配置信息目录的仓库文件夹 12git initInitialized empty Git repository in E:/gitpro/.git/ 文件区域 工作区用户编写代码的文件夹所有的文件操作以工作区为主GIT仓库 暂存库只是将工作中的未保存文件保存到暂存区中，有GIT维护；保存的内容是暂时需要的 版本库Master 真正发布的代码 3、仓库基本操作1、观察仓库的状态 1git status 2、将文件添加到git暂存区 1git add 文件名称 4、批量添加新文件到暂存区 1git add . 添加所有在仓库目录中创建的新文件到暂存区3、将文件提交到版本库中 1git commit -m \"注释信息Comment\" 现在才表示将新的文件提交到了GIT之中进行管理（这个代码才能被项目使用）自动增加并提交修改到版本库中 1git commit -a -m \"注释Comment\" 4、修改仓库文件 比较同一文件 git diff git diff 文件名 查看修改历史 12git log 文件名git log ​ 每次提交时都会自动生成一个Commit ID（在日后版本恢复中使用） 版本穿越​ 查看日志信息 12git loggit log --pretty=oneline 简化查看可以按q结束查看整个日志记录是用栈来记录的master库存在head指针回退到上一个版本 1git reset --hard head~1 查看所有删除的日志 1git reflog ​ 到指定版本 1git reset --hard 1fc9d3f（Commit id） 撤销修改撤销工作区修改显示那些文件发生了改变 1git checkout 恢复单个文件 1git checkout 文件名 恢复多个文件 1git checkout . 修改已在暂存区将暂存区的文件撤回到工作区 1git reset HEAD &lt;file&gt;... 文件删除 1del 文件名 删除工作区中的文件恢复 1git checkout -- 文件名 ​ 因为版本库中任存在，可以直接删除​ git commit -a -m “Commet”​ 提交之后，库中相应的文件也没有了​ 只能通过版本穿越恢复 GITHUB配置远程仓库ssh通信模式1.启动git bash 在此之中可以使用linux命令2、生成ssh key密钥 1ssh-keygen -t rsa -C &quot;1162314270@qq.com&quot; 1234命令输入后，首先询问用户密钥的保存位置 /c/Users/11623/.ssh/id_rsa 默认为公钥和私钥保存在：用户/.ssh/id_rsa瑞后询问是否设置保护密码 3、将公钥内容保存到GITHUB 公钥文件，保存在外部使用==(保存到github的ssh密匙中)== id_rsa.pub 私钥文件，做本机标识 id_rsa 打卡github的setting页面添加ssh key 将公钥内容复制到key内容中 1234567891011121314151617181920212223C:\\Users\\11623&gt;ssh-keygen -t rsa -C \"lmz\"Generating public/private rsa key pair.Enter file in which to save the key (C:\\Users\\11623/.ssh/id_rsa):C:\\Users\\11623/.ssh/id_rsa already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in C:\\Users\\11623/.ssh/id_rsa.Your public key has been saved in C:\\Users\\11623/.ssh/id_rsa.pub.The key fingerprint is:SHA256:722mRw92N2R2fb71Yr3tBEgSQORYxzzzF6n4xRkh7Mk lmzThe key's randomart image is:+---[RSA 2048]----+| o=+o.. .o || + .=...+ || . . .B.+ +.|| .oE.=++|| S ..o=.o|| . = .o+|| .o + o*|| . .+ +o+|| o=.. ++|+----[SHA256]-----+ 4、在github上建立远程仓库信息 不选择：Initialize this repository with a README 创建仓库后界面上就给出了仓库的访问地址 SSH，有了SSH key直接连接 https://github.com/NicolasCoder/rep.git HRRPS,所有人都可以连接 https://github.com/NicolasCoder/rep.git删除github仓库 仓库的setting 客服端访问本地代码同步到远程仓库中 12345Either specify the URL from the command-line or configure a remote repository using git remote add &lt;name&gt; &lt;url&gt;and then push using the remote name git push &lt;name&gt; 1、建立客服端与服务端的连接地址信息 1git remote add origin （SSH链接）https://github.com/NicolasCoder/rep.git 2、连接成功后将本地仓库全部代码推送到服务器端 1git push -u origin master 强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容 12git push -fgit push -u origin master -f ：使用这个强制的方法 1git pull origin master --allow-unrelated-histories 后面加上 --allow-unrelated-histories ， 把两段不相干的 分支进行强行合并 提高本地修改 首先将修改提高到master分支上，然后推送代码到服务器 3、git pull的作用是从一个仓库或者本地的分支拉取并且整合代码。 1git pull [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]] 实例：默认使用方式 1git pull 按照git branch 设置的默认跟踪的服务器和分支来拉取。 实例： 拉取远程服务器origin的master分支 1git pull origin master 删除远程分支 1git remote rm origin 克隆远程仓库已经初始化完成的仓库 已执行 Initialize this repository with a README克隆远程仓库：（直接在当前目录新建远程仓库的项目文件） git clone （HTTPS）https://github.com/NicolasCoder/crm.git GIT的分支管理策略1).基础操作1、查看当前仓库中可用的分支 1git branch 2、创建新的分支 1git branch 分支名 3、切换分支 1git checkout 分支名 要想进行开发，一定不能再master中开发，必须在子分支开发回到master进行合并分支 1git merge dev ​ 合并后提示Fast-forward​ 快速合并方式一般开发分支和master分支都在服务器上 1git push -u origin 分支名 删除分支 1git branch -d 分支名 删除远程分支 1git push origin --delete 分支名 推送空的分支 1git push origin:dev 2）合并操作冲突解决 创建并切换到dev分支 1git checkout -b dev 两个分支修改了同一文件 提交到master后会提示conflict和文件名 打开文件会发现相应的冲突都写在了里面 修改后再次提交即可分支合并模式 通过图形化的方式查看所有分支合并记录 1git log --graph --pretty=oneline 1Fast forwaed(默认)合并 ​ 不会产生新的提交点添加参数 -no-ff(Not Fast Forward)​ 1git merge --no-ff -m \"use no-ff merge\" dev –no-ff的作用： git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。 git merge 则不会显示 feature，只保留单条分支记录。 ​ master不予许修改，dev分支如果有多人共享，需要在创建自己的分支在进行开发，合并时使用no-ff方式bug分支,暂挂工作区​ 有错误的代码不能保存在暂存区​ 保存当前工作区的状态​ git stash​ 查看所有暂时挂起的工作区​ git stash list​ 两步​ 恢复挂起的工作区​ git stash apply​ 清除保存的工作区​ git stash drop​ 一步​ 恢复并清除保存区​ git stash popfeature,扩展分支​ 已经开发，但不准备使用的功能等​ 强制删除有不同修改的分支​ git branch -D feature补丁​ 比较分支区别​ git diff master &gt; patch​ 通过命令行的管道流，将diff保存再来patch文件里​ 通过补丁合并分支​ git apply patch​ 当项目很大的时候，效率更高​ 不便于开发者沟通​ git format-patch -M master​ 通知master​ 应用分支补丁​ git am （补丁路劲）”E:\\gitpro\\0001-git-apply-patch.patch” .gitignore的操作目的是忽略指定类型的文件或者某个文件夹 a、新建.gitignore文件： b、输入要忽略的文件（可用通配符） 利用git status 查看，可以看出排除了写入的文件，避免了其提交 123456789101112131415161718192021222324HELP.mdtarget/!.mvn/wrapper/maven-wrapper.jar!**/src/main/**!**/src/test/**###忽略配置文件###judge.properties### IntelliJ IDEA ###.idea*.iws*.iml*.ipr### NetBeans ###/nbproject/private//nbbuild//dist//nbdist//.nb-gradle/build/### VS Code ###.vscode/","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/tags/学习笔记/"}]},{"title":"linux","slug":"linux/linux","date":"2019-10-12T06:20:26.000Z","updated":"2019-11-13T12:19:13.699Z","comments":true,"path":"2019/10/linux/linux/","link":"","permalink":"https://codeofli.github.io/2019/10/linux/linux/","excerpt":"[TOC]3.VM和Linux系统(CentOS)安装3.1安装vm和Centos学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。1)先安装virtualmachine,vm122)再安装Linux(CentOS6.8)3)原理示意图，这里我们画图说明一下VM和CentOS的关系。","text":"[TOC]3.VM和Linux系统(CentOS)安装3.1安装vm和Centos学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习。1)先安装virtualmachine,vm122)再安装Linux(CentOS6.8)3)原理示意图，这里我们画图说明一下VM和CentOS的关系。 3.3VM安装的步骤 1)去BIOS里修改设置开启虚拟化设备支持（f2,f10） 2)安装虚拟机软件（vm12）看老师的具体演示：因为老师的电脑上已经安装了VM12，因此我先卸载然后再安装。 3.4CentOS安装的步骤 1)创建虚拟机(空间)这里在配置网络连接时，有三种形式，需要大家伙注意： 3.5CentOS的终端使用和联网1)终端的使用，点击鼠标右键，即可选择打开终端 2)配置网络，可以上网。点击上面右侧的；两个计算机图片，选择启用eth0,即可成功连接到网络，就可以上网。 3.7vmtools的安装和使用3.7.1安装vmtools的步骤说明 1.进入centos 2.点击vm菜单的-&gt;installvmwaretools 3.centos会出现一个vm的安装包 4.点击右键解压,得到一个安装文件 5.进入该vm解压的目录，该文件在/root/桌面/vmware-tools-distrib/下 6.安装./vmware-install.pl 7.全部使用默认设置即可8.需要reboot重新启动即可生效 3.7.2使用vmtools来设置windows和linux的共享文件夹 1)菜单-&gt;vm-&gt;setting,如图设置即可注意:设置选项为alwaysenable,这样可以读写了 2)windows和centos可共享d:/share目录可以读写文件了 3)在centos的/mnt/hgfs/下 4.Linux的目录结构4.1基本介绍 linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。深刻理解linux树状文件目录是非常重要的，这里我给大家说明一下。 记住一句经典的话：==在Linux世界里，一切皆文件。== 具体的目录结构: /bin [重点] (/usr/bin、/usr/local/bin) •是Binary的缩写, 这个目录存放着最经常使用的命令 /home [重点] •存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /root [重点] •该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin(/usr/sbin、/usr/local/sbin) •s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /lib •系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found •这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc [重点](etcetera,等等) •所有的系统管理所需要的配置文件和子目录my.conf /usr [重点] •这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。 /boot [重点] •存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /srv •service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys •这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs /tmp •这个目录是用来存放一些临时文件的。 /dev •类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media [重点] •linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 /mnt [重点] •系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。d:/myshare /var [重点] •这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 /opt •这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 /usr/local [重点] •这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 /selinux [security-enhanced linux] 360 •SELinux是一种安全子系统,它能控制程序只能访问特定文件。 4.3Linux目录总结1)linux的目录中有且只要一个根目录/2)linux的各个目录存放的内容是规划好，不用乱放文件。3)linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。 4)linux的各个文件目录下存放什么内容，大家必须有一个认识。5)学习后，你脑海中应该有一颗linux目录树 5、远程登录Linux系统5.1为什么需要远程登录Linux 5.1.1示意图 为什么需要远程登录Linux说明: 公司开发时候，具体的情况是这样的 1) linux服务器是开发小组共享的.2) 正式上线的项目是运行在公网的.3) 因此程序员需要远程登录到centos进行项目管理或者开发.4) 画出简单的网络拓扑示意图(帮助理解)5) 远程登录客户端有Xshell5，Xftp5 , 我们学习使用Xshell5 和Xftp , 其它的远程工具大同小异. 远程登录Linux-Xshell5介绍: 说明:Xshell 是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。Xshell[1]是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 特别说明：如果希望安装好XShell5就可以远程访问Linux系统的话，需要有一个前提，就是Linux启用了SSHD服务，该服务会监听22号端口。 ==终端setup指令查看系统服务中ssh是否开启== 如果都有，还是不行，就重新建立连接 5.3安装XShell5并使用5.3.2XShell5的关键配置 5.3.3XShel5远程登录到Linux后，就可以使用指令来操作Linux系统 5.4远程上传下载文件Xftp55.4.1XFtp5软件介绍 是一个基于windows平台的功能强大的SFTP、FTP文件传输软件。使用了Xftp以后，windows用户能安全地在UNIX/Linux和WindowsPC之间传输文件。 5.4.2XFtp5软件的安装这个看老师的演示即可.5.4.3Xftp5的配置和使用 6.vi和vim编辑器6.1vi和vim的基本介绍所有的Linux系统都会内建vi文本编辑器。Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 6.2vi和vim的三种常见模式6.2.1正常模式 在正常模式下，我们可以使用快捷键。以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、贴上』来处理你的文件数据。6.2.2插入模式/编辑模式 在模式下，程序员可以输入内容。按下i,I,o,O,a,A,r,R等任何一个字母之后才会进入编辑模式,一般来说按i即可 6.2.3命令行模式 在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的！ 6.4vi和vim三种模式的相互转化图 快捷键使用练习: 1) 拷贝当前行yy , 拷贝当前行向下的5行5yy，并粘贴。 2) 删除当前行dd , 删除当前行向下的5行 5+dd 3) 在文件中查找某个单词[命令行下/关键字，回车查找, 输入n 就是查找下一个] 4) 设置文件的行号，取消文件的行号. [命令行下: set nu 和:set nonu] 5) 编辑/etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg] 6) 在一个文件中输入”hello” ,然后又撤销这个动作u7) 编辑/etc/profile 文件，并将光标移动到20行shift+g8) 更多的看整理的文档 7)编辑/etc/profile文件，并将光标移动到第20行shift+g 第一步：显示行号:setnu 第二步：输入20这个数 第三步:输入（G）shift+g， ：20在按gg uu回退 6.6vim和vi的快捷键键盘一览图 7、实操篇开机、重启和用户登录注销7.1关机&amp;重启命令 7.1.1基本介绍 shutdown shutdown-hnow:表示立即关机 shutdown-h1:表示1分钟后关机 shutdown-rnow:立即重启 halt 就是直接使用，效果等价于关机 reboot就是重启系统。 sync：把内存的数据同步到磁盘 7.1.2注意细节 当我们关机或者重启时，都应该先执行以下sync指令，把内存的数据写入磁盘，防止数据丢失。 7.2用户登录和注销 7.2.1基本介绍 1)登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用”su-用户名’命令来切换成系统管理员身份. 2)在提示符下输入logout即可注销用户 7.2.2使用细节 1)logout注销指令在图形运行级别无效，在运行级别3下有效. 2)运行级别这个概念，后面给大家介绍 8.实操篇用户管理8.1基本介绍 给大家画一个示意图，帮助大家理解用户管理的规则。 说明 1)Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 2)Linux的用户需要至少要属于一个组。 查看所有用户名1234567891011121314151617181920212223242526272829303132333435[root@hapdoop1 ~]# more /etc/passwd[root@hapdoop1 ~]# more /etc/passwd | cut -f 1 -d :rootbindaemonadmlpsyncshutdownhaltmailuucpoperatorgamesgopherftpnobodydbususbmuxdrtkitavahi-autoipdvcsaabrthaldaemonntpapachesaslauthpostfixgdmpulsesshdtcpdumpxmfoxtom 8.2添加用户 8.2.1基本语法 useradd [选项] 用户名 8.2.2实际案例 特别说明：==cd表示changedirectory==,切换目录. 8.2.3细节说明 1)当创建用户成功后，(加上-m参数)会自动的创建和用户同名的家目录 ==没有-m参数不会有缺省目录== 1root@iZuf6i77uwsb2oiszspgvkZ:~# useradd -m nicolas 2)也可以通过useradd-d指定目录新的用户名，给新创建的用户指定家目录 1[root@hapdoop1 home]# useradd -d /home/dog xh 指定/修改密码基本语法 passwd 用户名 删除用户基本语法userdel 用户名 应用案例1)删除用户xiaoming，但是要保留家目录 1[root@hapdoop1 ~]# userdel xm 2)删除用户以及用户主目录 1[root@hapdoop1 home]# userdel -r xh 8.4.3思考题在删除用户时，我们一般不会将家目录删除。 8.5查询用户信息 8.5.1基本语法 id 用户名 应用实例案例1：请查询root信息8.5.3 ![1565783310913](linux/id username.png) 细节说明 1)当用户不存在时，返回”无此用户” 8.6切换用户8.6.1介绍(substitute user) 在操作Linux中，如果当前用户的权限不够，可以通过su-指令，切换到高权限用户，比如root 8.6.2基本语法(run a shell with substitute user and group IDs) su– 切换用户名 8.6.3应用实例 1)创建一个用户zf,，指定密码，然后切换到zf. 细节说明 1)从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。 2)当需要返回到原来用户时，使用exit指令 12[root@hapdoop1 ~]# whoamiroot 8.7用户组 8.7.1介绍类似于角色，系统可以对有共性的多个用户进行统一的管理。 8.7.2增加组 groupadd 组名 案例演示 1[root@hapdoop1 ~]# groupadd wudang 8.7.4删除组指令 (基本语法)groupdel 组名 8.7.5案例演示 1[root@hapdoop1 ~]# groupdel wudang 8.8增加用户时直接加上组8.8.1指令(基本语法) useradd -g 用户组 用户名 8.8.2案例演示 增加一个用户zwj,直接将他指定到wudang步骤看演示： ![1565786129905](linux/useradd -g) 8.9修改用户的组 8.9.1指令(基本语法) usermod -g 用户组 用户名 8.9.2案例演示创建一个shaolin组，让将zwj用户修改到shaolin ![1565786180228](linux/usermod -g.png) 8.10/etc/passwd文件 用户（user）的配置文件，记录用户的各种信息 每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 8.11/etc/shadow文件 口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 8.12/etc/group文件 组(group)的配置文件，记录Linux包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表 9、实操篇实用指令9.1指定运行级别运行级别说明： 0：关机 1：单用户【找回丢失密码】 2：多用户状态没有网络服务 3：多用户状态有网络服务4：系统未使用保留给用户 5：图形界面 6：系统重启 常用运行级别是3和5，要修改默认的运行级别可改文件/etc/inittab的id:5:initdefault:这一行中的数字运行级别的示意图： 9.2切换到指定运行级别的指令 9.2.1基本语法 init[012356] 9.2.2应用实例案例 1：通过init来切换不同的运行级别，比如动5-&gt;3，然后关机 12345init3init5init0 9.2.3面试题 如何找回root密码，如果我们不小心，忘记root密码，怎么找回。 思路：进入到单用户模式，然后修改root密码。 因为进入单用户模式，root不需要密码就可以登录。演示一把（注意观察）： 总结:开机-&gt;在引导时输入回车键-&gt;看到一个界面输入e-&gt;看到一个新的界面，选中第二行（编辑内核）在输入e-&gt;在这行最后输入1,再输入回车键-&gt;再次输入b,这时就会进入到单用户模式。这时，我们就进入到单用户模式，使用passwd指令来修改root密码。 2)请设置我们的运行级别，linux运行后，直接进入到命令行界面，即进入到3 运行级别vim/etc/inittab将id:5:initdefault:这一行中的数字,5这个数字改成对应的运行级别即可。 9.3帮助指令9.3.1介绍 当我们对某个指令不熟悉时，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法。 9.3.2man(manual) 获得帮助信息 基本语法 man [命令或配置文件]（功能描述：获得帮助信息） 应用实例案例：查看ls命令的帮助信息 1[root@hapdoop1 ~]# man ls 9.3.3help指令 基本语法 help命令（功能描述：获得shell内置命令的帮助信息） 应用实例案例：查看cd命令的帮助信息 1[root@hapdoop1 ~]# help cd 9.4文件目录类9.4.1pwd 指令(print name of current/working directory) •基本语法 pwd (功能描述：显示当前工作目录的绝对路径) •应用实例案例：显示当前工作目录的绝对路径 12[root@hapdoop1 ~]# pwd/root 9.4.2ls指令 (list directory contents) •基本语法 ls [选项] [目录或是文件] •常用选项 -a：显示当前目录所有的文件和目录，包括隐藏的。 -l：以列表的方式显示信息 •应用实例案例:查看当前目录的所有内容信息 9.4.3cd指令•基本语法 cd [参数] (功能描述：切换到指定目录) •常用参数 绝对路径和相对路径 如何理解绝对路径和相对路径： cd~ 或者 cd：回到自己的家目录 cd.. : 回到当前目录的上一级目录 •应用实例 案例1：使用绝对路径切换到root目录 cd/root 案例2: 使用相对路径到/root目录 这里我们需要知道该用户目录在哪个目录下，才能写出这个指令，假设在/usr/lib 1cd../../root 案例3：表示回到当前目录的上一级目录cd..案例4：回到家目录 cd cd~ 9.4.4 mkdir指令mkdir指令用于创建目录(makedirectory) 基本语法 mkdir [选项] 要创建的目录 •常用选项 -p(–parents)：创建多级目录 •应用实例案例1:创建一个目录/home/dog 案例2:创建多级目录/home/animal/tiger 9.4.5rmdir指令介绍 rmdir指令删除空目录 基本语法 rmdir [选项] 要删除的空目录 应用实例案例1:删除一个目录/home/dog 使用细节 rmdir删除的是空目录，如果目录下有内容时无法删除的。 提示：如果需要删除非空目录，需要使用rm-rf要删除的目录 9.4.6touch指令touch指令 创建空文件 •基本语法 touch 文件名称 •应用实例案例 1:创建一个空文件hello.txt 123[root@hapdoop1 home]# touch ok1.txt ok2.txt[root@hapdoop1 home]# lsok1.txt ok2.txt xm 9.4.7cp指令[重要]cp指令 拷贝文件到指定目录 •基本语法 1cp [选项] source dest •常用选项-r：递归复制整个文件夹 •应用实例案例 1:将/home/aaa.txt拷贝到/home/bbb目录下[拷贝单个文件 案例2:递归复制整个文件夹，举例将/home/test整个目录拷贝到/home/zwj目录 •使用细节 强制覆盖不提示的方法：\\cp 9.4.8rm指令 rm 指令移除 【删除】文件或目录 •基本语法rm[选项]要删除的文件或目录 •常用选项 -r：递归删除整个文件夹 -f：强制删除不提示 •应用实例案例1:将/home/aaa.txt删除 案例2:递归删除整个文件夹/bb 12[root@hapdoop1 /]# rm -r bb/rm：是否删除目录 \"bb\"？y 使用细节 强制删除不提示的方法：带上-f参数即可 9.4.9mv指令 mv 移动文件与目录或重命名 •基本语法 mv oldNameFile newNameFile (功能描述：重命名) mv /temp/movefile /targetFolder(功能描述：移动文件) •应用实例 案例1:将/home/aaa.txt文件重新命名为pig.txt 123[root@hapdoop1 home]# mv aaa.txt pig.txt[root@hapdoop1 home]# lsok1.txt ok2.txt pig.txt xm 案例2:将/home/pig.txt文件移动到/root目录下 123456[root@hapdoop1 home]# mv pig.txt /root[root@hapdoop1 home]# cd ~[root@hapdoop1 ~]# lsanaconda-ks.cfg install.log.syslog 公共的 视频 下载hello.java ok.txt 红1.jpg 图片 音乐install.log pig.txt 模板 文档 桌面 9.4.10 cat指令(concatenate) cat查看文件内容，是以只读的方式打开。 •基本语法 cat [选项] 要查看的文件 •常用选项-n：显示行号 •应用实例 案例1:/etc/profile文件内容，并显示行号 1[root@hapdoop1 ~]# cat -n /etc/profile | more •使用细节 cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令|more cat文件名|more[分页浏览] 9.4.11more指令 more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。 more指令中内置了若干快捷键，详见操作说明 •基本语法 more 要查看的文件 •操作说明 •应用实例案例: 采用more查看文件/etc/profile 1[root@hapdoop1 ~]# more /etc/profile 9.4.12less指令 less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。 •基本语法 less 要查看的文件 •操作说明 •应用实例 案例:采用less查看一个大文件文件/opt/金庸-射雕英雄传txt精校版.txt 1[root@hapdoop1 opt]# less 金庸-射雕英雄传txt精校版.txt 9.4.13&gt;指令和&gt;&gt;指令介绍 指令和&gt;&gt;指令 &gt; 输出重定向:会将原来的文件的内容覆盖 &gt;&gt;追加：不会覆盖原来文件的内容，而是追加到文件的尾部。• 基本语法 1)ls-l&gt;文件（功能描述：列表的内容写入文件a.txt中（覆盖写）） 1[root@hapdoop1 home]# ls -l &gt; a.txt 说明：ls-l&gt;a.txt,将ls-l的显示的内容覆盖写入到a.txt文件，如果该文件不存在，就创建该文件。 2)ls-al&gt;&gt;文件（功能描述：列表的内容追加到文件aa.txt的末尾） 1[root@hapdoop1 home]# ls -al &gt;&gt; a.txt 3)cat文件1&gt;文件2（功能描述：将文件1的内容覆盖到文件2）相当于复制文件 1[root@hapdoop1 home]# cat /etc/profile &gt; c.txt 9.4.14echo指令 echo输出内容到控制台。 •基本语法echo[选项] [输出内容] •应用实例 案例:使用echo指令输出环境变量,输出当前的环境路径。 123[root@hapdoop1 ~]# echo $PATH[root@hapdoop1 ~]# echo \"hello\" 9.4.15head指令 head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容 •基本语法 head 文件(功能描述：查看文件头10行内容) head -n 5 文件 (功能描述：查看文件头5行内容，5可以是任意行数) •应用实例 案例:查看/etc/profile的前面5行代码 1[root@hapdoop1 ~]# head -n 5 /etc/profile 9.4.16tail指令 tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容。 •基本语法 1)tail 文件（功能描述：查看文件后10行内容） 2)tail -n 5 文件（功能描述：查看文件后5行内容，5可以是任意行数）3)tail -f 文件（功能描述：实时追踪该文档的所有更新，工作经常使用） •应用实例 案例1:查看/etc/profile最后5行的代码 1[root@hapdoop1 ~]# tail -n 5 /etc/profile 案例2:实时监控mydate.txt,看看到文件有变化时，是否看到，实时的追加日期 1[root@hapdoop1 home]# tail -f mydate.txt 9.4.17ln指令 软链接也叫符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径 •基本语法 ln -s [原文件或目录] [软链接名]（功能描述：给原文件创建一个软链接） •应用实例 案例1:在/home目录下创建一个软连接linkToRoot，连接到/root目录 1[root@hapdoop1 home]# ln -s /root linkToRoot 案例2:删除软连接linkToRoot 1[root@hapdoop1 home]# rm linkToRoot •细节说明 当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录。 1234567[root@hapdoop1 home]# cd linkToRoot/[root@hapdoop1 linkToRoot]# pwd/home/linkToRoot[root@hapdoop1 linkToRoot]# lsanaconda-ks.cfg install.log.syslog 公共的 视频 下载hello.java ok.txt 红1.jpg 图片 音乐install.log pig.txt 模板 文档 9.4.18history指令查看已经执行过历史命令,也可以执行历史指令 •基本语法history（功能描述：查看已经执行过历史命令） •应用实例案例1:显示所有的历史命令 1[root@hapdoop1 home]# history 案例2:显示最近使用过的10个指令。 1[root@hapdoop1 home]# history 10 案例3：执行历史编号为5的指令 1[root@hapdoop1 home]# !111 9.5时间日期类9.5.1date指令 -显示当前日期 •基本语法 1)date（功能描述：显示当前时间） 2)date+%Y（功能描述：显示当前年份） 3)date+%m（功能描述：显示当前月份） 4)date+%d（功能描述：显示当前是哪一天） 5)date”+%Y-%m-%d%H:%M:%S”（功能描述：显示年月日时分秒） •应用实例案例1:显示当前时间信息 12[root@hapdoop1 home]# date2019年 08月 15日 星期四 17:57:34 CST 案例2:显示当前时间年月日 12[root@hapdoop1 home]# date \"+%Y %m %d\"2019 08 15 案例3:显示当前时间年月日时分秒 12[root@hapdoop1 home]# date \"+%Y %m %d %H:%M:%S\"2019 08 15 18:04:05 9.5.2date指令 -设置日期 •基本语法 date -s 字符串时间 •应用实例 案例1:设置系统当前时间，比如设置成2018-10-1011:22:22 12[root@hapdoop1 home]# date -s \"2019-9-9 11:11:11\"2019年 09月 09日 星期一 11:11:11 CST 9.5.3cal指令(calendar) 查看日历指令 •基本语法cal[选项]（功能描述：不加选项，显示本月日历） •应用实例案例1:显示当前日历 1[root@hapdoop1 home]# cal 案例2:显示2020年日历 1[root@hapdoop1 ~]# cal 2020 9.6搜索查找类9.6.1find指令 find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。 •基本语法 find [搜索范围] [选项] •选项说明 •应用实例 案例1:按文件名：根据名称查找/home目录下的hello.txt文件 1[root@hapdoop1 ~]# find /home -name hello.txt 案例2：按拥有者：查找/opt目录下，用户名称为root的文件 1[root@hapdoop1 ~]# find /opt -user root 案例3：查找整个linux系统下大于20m的文件（+n大于-n小于n等于） 1[root@hapdoop1 ~]# find /opt -size +20M 查询/目录下，所有.txt的文件 1[root@hapdoop1 ~]# find / -name \\*.txt 9.6.2locate指令 locaate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。 •基本语法 locate 搜索文件 •特别说明由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库。 •应用实例 案例1:请使用locate指令快速定位hello.txt文件所在目录 9.6.3grep指令和管道符号|grep过滤查找，管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 •基本语法 grep [选项] 查找内容源文件 •常用选项 •应用实例 案例1:请在hello.txt文件中，查找”yes”所在行，并且显示行号 123[root@hapdoop1 home]# cat hello.txt | grep -n yes#不区分大小写[root@hapdoop1 home]# cat hello.txt | grep -ni yes 9.7压缩和解压类9.7.1gzip/gunzip指令 gzip用于压缩文件，gunzip用于解压的 •基本语法 gzip 文件（功能描述：压缩文件，只能将文件压缩为*.gz文件） gunzip 文件.gz（功能描述：解压缩文件命令） •应用实例 案例1:gzip压缩，将/home下的hello.txt文件进行压缩 1[root@hapdoop1 home]# gzip hello.txt 案例2:gunzip压缩，将/home下的hello.txt.gz文件进行解压缩 1[root@hapdoop1 home]# gunzip hello.txt.gz 细节说明 当我们使用gzip对文件进行压缩后，不会保留原来的文件。 9.7.2 zip/unzip指令 zip用于压缩文件，unzip用于解压的，这个在项目打包发布中很有用的 •基本语法 zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录的命令）unzip [选项] XXX.zip（功能描述：解压缩文件） •zip常用选项 -r：递归压缩，即压缩目录 unzip的常用选项 -d &lt;目录&gt;：指定解压后文件的存放目录 •应用实例 案例1:将/home下的所有文件进行压缩成mypackage.zip 1[root@hapdoop1 home]# zip -r mypackge.zip /home/ 案例2:将mypackge.zip解压到/opt/tmp目录下 1[root@hapdoop1 home]# unzip -d /opt/tmp/ mypackge.zip 9.7.3tar指令tar指令是打包指令，最后打包后的文件是.tar.gz的文件。 •基本语法 tar [选项] XXX.tar.gz 打包的内容(功能描述：打包目录，压缩后的文件格式.tar.gz) •选项说明 v(verbose) z(gzip) f(file) c(file) x(extract) •应用实例 案例1:压缩多个文件，将/home/a1.txt和/home/a2.txt压缩成a.tar.gz 1[root@hapdoop1 home]# tar -zcvf a.tar.gz ok1.txt ok2.txt 案例3:将a.tar.gz解压到当前目录 1[root@hapdoop1 home]# tar -zxvf a.tar.gz 案例4:将myhome.tar.gz解压到/opt/目录下 1[root@hapdoop1 home]# tar -zxvf a.tar.gz -C /opt 10.组管理和权限管理10.1Linux组 基本介绍 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 1)所有者 2)所在组 3)其它组 4)改变用户所在的组 10.2文件/目录所有者 一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。10.2.1查看文件的所有者 1)指令：ls -ahl 2)应用实例：创建一个组police,再创建一个用户tom,将tom放在police组,然后使用tom来创建一个文件ok.txt，看看情况如何 10.3组的创建10.3.1基本指令 groupadd 组名 10.3.2应用实例: 创建一个组,monster 创建一个用户fox，并放入到monster组中 12[root@hapdoop1 ~]# groupadd monster[root@hapdoop1 ~]# useradd -g monster fox 10.4文件/目录所在组当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。### 10.4.1查看文件/目录所在组 •基本指令 ls –ahl 10.4.2修改文件所在的组•基本指令 chgrp 组名 文件名 •应用实例 使用root用户创建文件orange.txt,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到police组。 123[root@hapdoop1 ~]# chgrp police orange.txt [root@hapdoop1 ~]# ls -ahl-rw-r--r--. 1 root police 12 9月 16 02:17 orange.txt 10.5其它组 除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组. 10.6改变用户所在组 在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。 10.6.1改变用户所在组 1)usermod –g 组名 用户名 2)usermod –d 目录名 用户名 改变该用户登陆的初始目录。 1[root@hapdoop1 ~]# usermod -g bandit fox 10.7权限的基本介绍ls -l中显示的内容如下： -rwxrw-r–1rootroot1213Feb209:39abc 0-9位说明 1)第0位确定文件类型(d,-,l,c,b) 2)第1-3位确定所有者（该文件的所有者）拥有该文件的权限。—User 3)第4-6位确定所属组（同用户组的）拥有该文件的权限，—Group 4)第7-9位确定其他用户拥有该文件的权限—Other 10.8rwx权限详解10.8.1rwx作用到文件 1)[r]代表可读(read):可以读取,查看 ： 数字4 2)[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件. ：数字2 3)[x]代表可执行(execute):可以被执行 ：数字1 10.8.2rwx作用到目录 1)[r]代表可读(read):可以读取，ls查看目录内容 2)[w]代表可写(write):可以修改,目录内创建+删除+重命名目录 3)[x]代表可执行(execute):可以进入该目录10.9文件及目录权限实际案例ls-l中显示的内容如下：(记住)-rwxrw-r–1rootroot1213Feb209:39abc 10个字符确定不同用户能对文件干什么 第一个字符代表文件类型：文件(-),目录(d),链接(l) 其余字符每3个一组(rwx)读(r)写(w)执行(x) 第一组rwx:文件拥有者的权限是读、写和执行 第二组rw-:与文件拥有者同一组的用户的权限是读、写但不能执行 第三组r–:不与文件拥有者同组的其他用户的权限是读不能写和执行 可用数字表示为:r=4,w=2,x=1因此rwx=4+2+1=7 1 文件：硬连接数或目录：子目录数 root 用户root组 1213 文件大小(字节)，如果是文件夹，显示4096字节 Feb209:39 最后修改日期 abc 文件名 10.9文件及目录权限ls-l中显示的内容如下：(记住) -rwxrw-r–1rootroot1213Feb209:39abc 10.10修改权限-chmod10.10.1基本说明： 通过chmod指令，可以修改文件或者目录的权限 10.10.2第一种方式：+、-、=变更权限 u:所有者g:所有组o:其他人a:所有人(u、g、o的总和) 1)chmod u=rwx,g=rx,o=x文件目录名 2)chmod o+w 文件目录名 3)chmod a-x 文件目录名 •案例演示 1)给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限 1234[root@hapdoop1 ~]# chmod u=rwx,g=x,o=rx abc[root@hapdoop1 ~]# ls -l总用量 136drwx--xr-x. 2 root root 4096 9月 16 02:34 abc 2)给abc文件的所有用户添加读的权限 1[root@hapdoop1 ~]# chmod a+r abc 10.10.3第二种方式：通过数字变更权限 规则：r=4 w=2 x=1 ,rwx=4+2+1=7 chmod u=rwx, g=rx, o=x文件目录名 相当于 chmod 751 文件目录名 •案例演示 要求：将/home/abc.txt文件的权限修改成rwxr-xr-x,使用给数字的方式实现：rwx=4+2+1=7 r-x=4+1=5 r-x=4+1=5 指令：chmod755/home/abc.txt 10.11修改文件所有者-chown(chmod - change file mode bits) 10.11.1基本介绍 1chown newowner file 改变文件的所有者 1chown [-R] newowner:newgroupfile 改变用户的所有者和所有组 [-R] 如果是目录则使其下所有子文件或目录递归生效 10.11.2案例演示： 1)请将/home/abc.txt文件的所有者修改成tom 1[root@hapdoop1 ~]# chown fox abc.txt 2)请将/home/kkk目录下所有的文件和目录的所有者都修改成tom 1[root@hapdoop1 ~]# chown -R tom kkk/ 10.13最佳实践-警察和土匪游戏police，bandit jack,jerry:警察 xh,xq:土匪 (1)创建组 12[root@hapdoop1 ~]# groupadd police[root@hapdoop1 ~]# groupadd bandit (2)创建用户 11.crond任务调度11.1原理示意图 crontab进行定时任务的设置。 1.2概述 任务调度：是指系统在某个时间执行的特定的命令或程序。 任务调度分类： 1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 2.个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。 11.3基本语法 crontab [选项] 11.3.1常用选项 11.4快速入门 11.4.1任务的要求 设置任务调度文件：/etc/crontab 设置个人任务调度。执行crontab–e命令。 接着输入任务到调度文件如：/1ls–l/etc/&gt;/tmp/to.txt意思说每小时的每分钟执行ls–l/etc/&gt;/tmp/to.txt命令 11.4.2步骤如下 1) 1[root@hapdoop1 ~]# crontab -e 2) */1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt 3)当保存退出后就程序。 4)在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tmp/to.txt 11.4.3参数细节说明 11.5.1 案例1：每隔1分钟，就将当前的日期信息，追加到/tmp/mydate文件中 1)先编写一个文件/home/mytask1.sh 1date &gt;&gt; /tmp/mydate 2)给mytask1.sh一个可以执行权限 1[root@hapdoop1 home]# chmod 774 mytask1.sh 3)crontab-e 4) 1*/1 * * * * /home/mytask1.sh 11.5.2 案例2：每隔1分钟，将当前日期和日历都追加到/home/mycal文件中 1)先编写一个文件/home/mytask2.sh 12date &gt;&gt; /tmp/mycalcal &gt;&gt; /tmp/mycal 2)给mytask2.sh一个可以执行权限 1[root@hapdoop1 home]# chmod 774 mytask2.sh 3)crontab -e 4) 1*/1 * * * * /home/mytask2.sh 11.5.3 案例3:每天凌晨2:00将mysql数据库testdb，备份到文件中mydb.bak。 1)先编写一个文件/home/mytask2.sh 1/usr/local/mysql/bin/mysqldump -u root-proot testdb&gt;/tmp/mydb.bak 2)给mytask3.sh一个可以执行权限 1[root@hapdoop1 home]# chmod 774 mytask2.sh 3)crontab -e 4) 10 2 * * */home/mytask3.sh 11.6crond相关指令: 1)conrtab–r：终止任务调度。 2)crontab–l：列出当前有那些任务调度 3)service crond restart [重启任务调度] 12.Linux磁盘分区、挂载12.1分区基础知识12.1.1分区的方式： 1)mbr分区: 1.最多支持四个主分区 2.系统只能安装在主分区 3.扩展分区要占一个主分区4.MBR最大只支持2TB，但拥有最好的兼容性 2)gpt分区: 1.支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区） 2.最大支持18EB的大容量（1EB=1024PB，1PB=1024TB）3.windows764位以后支持gpt 12.1.2windows下的磁盘分区 12.2Linux分区12.2.1原理介绍 1)Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构,Linux中每个分区都是用来组成整个文件系统的一部分。 2)Linux采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 3)示意图 12.2.2硬盘说明 1)Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘 2)对于IDE硬盘，驱动器标识符为“hdx”,其中“hd”表明分区所在设备的类型，这里是指IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）,“”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。 3)对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样 12.2.3使用lsblk指令查看当前系统的分区情况 12.5磁盘情况查询12.5.1查询系统整体磁盘使用情况 基本语法 df -h 应用实例 查询系统整体磁盘使用情况 123456[root@hapdoop1 ~]# df -lhFilesystem Size Used Avail Use% Mounted on/dev/sda3 18G 4.2G 13G 26% /tmpfs 1003M 80K 1003M 1% /dev/shm/dev/sda1 190M 39M 142M 22% /boot/dev/sr0 3.7G 3.7G 0 100% /media/CentOS_6.8_Final 12.5.2查询指定目录的磁盘占用情况 •基本语法 du -h/目录查询指定目录的磁盘占用情况，默认为当前目录 -s指定目录占用大小汇总 -h带计量单位 -a含文件 –max-depth=1子目录深度 -c列出明细的同时，增加汇总值 •应用实例查询/opt目录的磁盘占用情况，深度为1 123456789101112131415161718[root@hapdoop1 ~]# du -ach --max-depth=1 /opt4.0K /opt/Hello.java64K /opt/tmp147M /opt/jdk-7u79-linux-x64.gz35M /opt/mysql-5.6.14.tar.gz8.6M /opt/apache-tomcat-7.0.70.tar.gz298M /opt/jdk1.7.0_794.0K /opt/rh4.0K /opt/Hello.class0 /opt/ok2.txt28M /opt/金庸-射雕英雄传txt精校版.txt69M /opt/VMwareTools-10.0.5-3228253.tar.gz15M /opt/apache-tomcat-7.0.70214M /opt/vmware-tools-distrib0 /opt/ok1.txt274M /opt/eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz1.1G /opt1.1G 总用量 12.6磁盘情况-工作实用指令1)统计/home文件夹下文件的个数 12[root@hapdoop1 home]# ll /home | grep \"^-\" | wc -l11 2)统计/home文件夹下目录的个数 12[root@hapdoop1 home]# ll /home | grep \"^d\" | wc -l3 3)统计/home文件夹下文件的个数，包括子文件夹里的 12[root@hapdoop1 home]# ls -lR /home | grep \"^-\" | wc -l11 4)统计文件夹下目录的个数，包括子文件夹里的 12[root@hapdoop1 home]# ls -lR /home | grep \"^d\" | wc -l3 5)以树状显示目录结构 1234567891011121314151617[root@hapdoop1 home]# yum install tree[root@hapdoop1 home]# tree.├── a.tar.gz├── a.txt├── c.txt├── fox├── hello.txt├── mydate.txt├── mydate.txt~├── mypackge.zip├── mytask1.sh├── mytask2.sh├── ok1.txt├── ok2.txt├── tom└── xm 13、实操篇网络配置13.1Linux网络配置 原理图(含虚拟机) 目前我们的网络配置采用的是NAT。 13.2查看网络IP和网关 13.2.1查看虚拟网络编辑器 13.2.2修改ip地址(修改虚拟网络的ip) 3.2.3查看网关 13.2.4查看windows环境的中VMnet8网络配置(ipconfig指令) 1)使用ipconfig查看 2)界面查看 13.3ping测试主机之间网络连通 13.3.1基本语法ping目的主机（功能描述：测试当前服务器是否可以连接目的主机） 13.3.2应用实例测试当前服务器是否可以连接百度 [root@hadoop100桌面]#pingwww.baidu.com 1[root@hapdoop1 home]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 13.4linux网络环境配置 13.4.1第一种方法(自动获取) 缺点:linux启动后会自动获取IP,缺点是每次自动获取的ip地址可能不一样。这个不适用于做服务器，因为我们的服务器的ip需要时固定的。 13.4.2第二种方法(指定固定的ip) 说明直接修改配置文件来指定IP,并可以连接到外网(程序员推荐)，编辑vi/etc/sysconfig/network-scripts/ifcfg-eth0 要求：将ip地址配置的静态的，ip地址为192.168.184.130 修改后，一定要重启服务 1)service network restart 2)reboot重启系统 不推荐 14、实操篇进程管理14.1进程的基本介绍1)在LINUX中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个ID号。 2)每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如www服务器。 3)每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。 4)一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。 14.2显示系统执行的进程ps14.2.1说明： 查看进行使用的指令是ps,一般来说使用的参数是ps-aux 14.2.2ps指令详解 1)指令：ps –aux| grep xxx，比如我看看有没有sshd服务 2)指令说明 •SystemV展示风格•USER：用户名称 •PID：进程号•%CPU：进程占用CPU的百分比 •%MEM：进程占用物理内存的百分比 •VSZ：进程占用的虚拟内存大小（单位：KB） •RSS：进程占用的物理内存大小（单位：KB） •TT：终端名称,缩写 .•STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 •STARTED：进程的启动时间 •TIME：CPU时间，即进程使用CPU的总时间•COMMAND：启动进程所用的命令和参数，如果过长会被截断显示 14.2.3应用实例 要求：以全格式显示当前所有的进程，查看进程的父进程。 •ps -ef是以全格式显示当前所有的进程 -e显示所有进程(every)。 -f全格式(Do full-format listing)。 •ps -ef|grep xxx •是BSD风格 •UID：用户ID •PID：进程ID •PPID：父进程ID •C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高•STIME：进程启动的时间 •TTY：完整的终端名称 •TIME：CPU时间 •CMD：启动进程所用的命令和参数 思考题，如果我们希望查看sshd进程的父进程号是多少，应该怎样查询？ 1234[root@hapdoop1 ~]# ps -ef | grep sshdroot 14263 1 0 (ppid) 05:34 ? 00:00:00 /usr/sbin/sshdroot 16269 14263 0 06:07 ? 00:00:00 sshd: root@pts/1 root 16321 16273 0 06:19 pts/1 00:00:00 grep sshd 14.3终止进程kill和killall14.3.1介绍: 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。 14.3.2基本语法： kill [选项] 进程号（功能描述：通过进程号杀死进程） killall进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用） 14.3.3常用选项： -9:表示强迫进程立即停止 14.3.4最佳实践： 案例1：踢掉某个非法登录用户 12345678[root@hapdoop1 ~]# ps -aux | grep sshdWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 14263 0.0 0.0 66236 1200 ? Ss 05:34 0:00 /usr/sbin/sshdroot 16269 0.0 0.2 102084 4156 ? Ss 06:07 0:00 sshd: root@pts/1 root 16357 0.4 0.1 102084 4040 ? Ss 06:28 0:00 sshd: fox [priv] fox 16361 0.1 0.0 102084 1904 ? S 06:28 0:00 sshd: fox@pts/2 root 16387 0.0 0.0 103332 860 pts/1 S+ 06:29 0:00 grep sshd[root@hapdoop1 ~]# kill 16361 案例2:终止远程登录服务sshd,在适当时候再次重启sshd服 12345678[root@hapdoop1 ~]# ps -aux | grep sshdWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 14263 0.0 0.0 66236 1200 ? Ss 05:34 0:00 /usr/sbin/sshdroot 16269 0.0 0.2 102084 4156 ? Ss 06:07 0:00 sshd: root@pts/1 root 16357 0.4 0.1 102084 4040 ? Ss 06:28 0:00 sshd: fox [priv] fox 16361 0.1 0.0 102084 1904 ? S 06:28 0:00 sshd: fox@pts/2 root 16387 0.0 0.0 103332 860 pts/1 S+ 06:29 0:00 grep sshd[root@hapdoop1 ~]# kill 14263 案例3:终止多个gedit编辑器【killall,通过进程名称来终止进程】 1[root@hapdoop1 桌面]# killall gedit 案例4：强制杀掉一个终端 12345678[root@hapdoop1 桌面]# ps -aux |grep bashWarning: bad syntax, perhaps a bogus '-'? See /usr/share/doc/procps-3.2.8/FAQroot 15158 0.0 0.0 108348 1840 pts/0 Ss 05:37 0:00 /bin/bashroot 16273 0.0 0.0 108348 1820 pts/1 Ss+ 06:07 0:00 -bashroot 16398 0.0 0.0 108428 1828 pts/2 Ss+ 06:33 0:00 /bin/bashroot 16411 0.0 0.0 108348 1788 pts/3 Ss 06:33 0:00 /bin/bashroot 16438 0.0 0.0 103328 856 pts/3 S+ 06:37 0:00 grep bash[root@hapdoop1 桌面]# kill -9 16398 14.4查看进程树pstree14.4.1基本语法： pstree [选项] ,可以更加直观的来看进程信息 14.4.2常用选项： -p:显示进程的PID -u:显示进程的所属用户 14.4.3应用实例： 案例1：请你树状的形式显示进程的pid 123456789[root@hapdoop1 ~]# pstree -pinit(1)─┬─ManagementAgent(13688)─┬─&#123;ManagementAgen&#125;(13706) │ └─&#123;ManagementAgen&#125;(13707) ├─NetworkManager(14070)─┬─dhclient(16203) │ └─&#123;NetworkManager&#125;(14099) ├─VGAuthService(13576) ├─abrtd(14468) ├─acpid(14133) ├─atd(14495) 14.5服务(Service)管理4.5.1介绍: 服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd防火墙等)，因此我们又称为守护进程，是Linux中非常重要的知识点。 【原理图】 14.5.2service管理指令： 1service 服务名 [start|stop|restart|reload|status] 在CentOS7.0后不再使用service,而是systemctl 14.5.3使用案例： 1)查看当前防火墙的状况，关闭防火墙和重启防火墙。 1234567891011121314151617[root@hapdoop1 ~]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 1234567891011[root@hapdoop1 ~]# service iptables stopiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定][root@hapdoop1 ~]# service iptables statusiptables：未运行防火墙。[root@hapdoop1 ~]# service iptables startiptables：应用防火墙规则： [确定][root@hapdoop1 ~]# service iptables status表格：filterChain INPUT (policy ACCEPT) 14.5.4细节讨论： 1)关闭或者启用防火墙后，立即生效。[telnet测试某个端口即可]windows 1C:\\Users\\11623&gt;Telnet 192.168.163.129 22 2)这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置。如果希望设置某个服务自启动或关闭永久生效，要使用chkconfig指令，马上讲 14.5.5查看服务名: 方式1：使用setup-&gt;系统服务就可以看到。 方式2:/etc/init.d/服务名称 123456root@hapdoop1 ~]# ll /etc/init.d/总用量 376-rwxr-xr-x. 1 root root 1288 5月 12 2016 abrt-ccpp-rwxr-xr-x. 1 root root 1628 5月 12 2016 abrtd-rwxr-xr-x. 1 root root 1642 5月 12 2016 abrt-oops-rwxr-xr-x. 1 root root 1818 2月 17 2016 acpid 14.5.6服务的运行级别(runlevel): 查看或者修改默认级别：vi/etc/inittab Linux系统有7种运行级别(runlevel)：常用的是级别3和5 •运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 •运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 •运行级别2：多用户状态(没有NFS)，不支持网络 •运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 •运行级别4：系统未使用，保留 •运行级别5：X11控制台，登陆后进入图形GUI模式 •运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 14.5.7开机的流程说明 14.5.8chkconfig指令 介绍 通过chkconfig命令可以给每个服务的各个运行级别设置自启动/关闭 基本语法 1)查看服务chkconfig –list| grep xxx 1234567[root@hapdoop1 ~]# chkconfig --list NetworkManager 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭abrt-ccpp 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭abrtd 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭....[root@hapdoop1 ~]# chkconfig --list | grep sshsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 2)chkconfig 服务名 –list 12[root@hapdoop1 ~]# chkconfig iptables --listiptables 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 3)chkconfig –level 5 服务名 on/off 12345[root@hapdoop1 ~]# chkconfig --list | grep sshsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭[root@hapdoop1 ~]# chkconfig --level 5 sshd off[root@hapdoop1 ~]# chkconfig sshd --listsshd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:关闭 6:关闭 14.5.9应用实例： 1)案例1：请显示当前系统所有服务的各个运行级别的运行状态bash&gt;chkconfig–list 2)案例2：请查看sshd服务的运行状态bash&gt;servicesshdstatus 3)案例3：将sshd服务在运行级别5下设置为不自动启动，看看有什么效果？bash&gt;chkconfig–level5sshdoff 4)案例4：当运行级别为5时，关闭防火墙。bash&gt;chkconfig–level5iptablesoff 5)案例5：在所有运行级别下，关闭防火墙bash&gt;chkconfigiptablesoff 6)案例6：在所有运行级别下，开启防火墙bash&gt;chkconfigiptableson 14.5.10•使用细节 1)chkconfig重新设置服务后自启动或关闭，需要重启机器reboot才能生效. 14.6动态监控进程14.6.1介绍： top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。 14.6.2基本语法： top [选项] 14.6.3 选项说明： 14.6.4应用实例： 案例1.监视特定用户top：输入此命令，按回车键，查看执行的进程。 u：然后输入“u”回车，再输入用户名，即可 案例2：终止指定的进程。 top：输入此命令，按回车键，查看执行的进程。 k：然后输入“k”回车，再输入要结束的进程ID号 案例3:指定系统状态更新的时间(每隔10秒自动更新，默认是3秒)： bash&gt;top -d 10 14.6.5查看系统网络情况netstat(重要) •基本语法 netstat[选项] 1netstat -anp •选项说明 -an按一定顺序排列输出 -p显示哪个进程在调用 •应用案例 查看系统所有的网络服务 12345[root@hapdoop1 ~]# netstat -anp | moreActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 14263/sshd 请查看服务名为sshd的服务的信息。 1234567[root@hapdoop1 ~]# netstat -anp |grep sshd tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 14263/sshd tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 16552/sshd tcp 0 0 192.168.163.129:22 192.168.163.1:61806 ESTABLISHED 16552/sshd tcp 0 0 :::22 :::* LISTEN 14263/sshd tcp 0 0 ::1:6010 :::* LISTEN 16552/sshd unix 2 [ ] DGRAM 48552 16552/sshd 16.JavaEE篇搭建JavaEE环境 16.1概述16.1.1示意图： 16.2安装JDK16.2.1看老师演示，一会整理笔记： 16.2.2安装步骤 0)先将软件通过xftp5上传到/opt下 1)解压缩到/opt 1nicolas@ubuntu:~$ sudo tar -zxvf jdk-8u221-linux-x64.tar.gz -C /opt/jvm 2)配置环境变量的配置文件vim/etc/profile 123456unset iunset -f pathmungeJAVA_HOME=/opt/jdk1.7.0_79PATH=/opt/jdk1.7.0_79/bin:$PATHexport JAVA_HOME PATH 3)需要注销用户，环境变量才能生效。如果是在3运行级别，logout如果是在5运行级别， 4)在任何目录下就可以使用java和javac 16.2.3测试是否安装成功 编写一个简单的Hello.java输出”hello,world!” 12345public class Hello&#123; public static void main(String[] args)&#123; System.out.println(\"hello\"); &#125;&#125; 1234[root@hapdoop1 opt]# vim Hello.java[root@hapdoop1 opt]# javac Hello.java [root@hapdoop1 opt]# java Hellohello 16.3安装tomcat16.3.1步骤: 1)解压缩到/opt 1[root@hapdoop1 bin]# tar -zxvf apache-tomcat-7.0.70.tar.gz 2)启动tomcat./startup.sh 先进入到tomcat的bin目录 12[root@hapdoop1 bin]# cd apache-tomcat-7.0.70/bin/[root@hapdoop1 bin]# ./startup.sh 使用Linux本地的浏览是可以访问到tomcat 3)开放端口8080,这样外网才能访问到tomcat vim /etc/sysconfig/iptables 12-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启防火墙 12345678910111213141516171819202122[root@hapdoop1 bin]# service iptables restartiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定]iptables：应用防火墙规则： [确定][root@hapdoop1 bin]# service iptables status表格：filterChain INPUT (policy ACCEPT)num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080 6 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT)num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT)num target prot opt source destination 16.4Eclipse的安装16.4.1步骤: 1)解压缩到/opt 1nicolas@ubuntu:~$ sudo tar -zxvf eclipse-java-2019-06-R-linux-gtk-x86_64.tar.gz -C /opt 2)启动eclipse，配置jre和server 12nicolas@ubuntu:/opt/sts-4.3.2.RELEASE$ sudo mkdir /opt/sts-4.3.2.RELEASE/jrenicolas@ubuntu:/opt/sts-4.3.2.RELEASE$ sudo ln -s /opt/jvm/jdk1.8.0_221/bin/ /opt/sts-4.3.2.RELEASE/jre/ 启动方法1:创建一个快捷方式 启动方式2:进入到eclipse解压后的文件夹，然后执行./eclipse即可 3)编写jsp页面,并测试成功! 18. Python篇开发平台Ubuntu18.1Ubuntu的介绍Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu是基于GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（CanonicalLtd）打造的。 专业的Python开发者一般会选择Ubuntu这款Linux系统作为生产平台. 温馨提示：Ubuntu和Centos都是基于GNU/Linux内核的，因此基本使用和Centos是几乎一样的，它们的各种指令可以通用，同学们在学习和使用Ubuntu的过程中，会发现各种操作指令在前面学习CentOS都使用过。只是界面和预安装的软件有所差别。 Ubuntu下载地址：http://cn.ubuntu.com/download/ ubuntu的root密码：abc123 18.2Ubuntu的安装18.2.1安装的步骤 18.2.2设置Ubuntu支持中文 默认安装的ubuntu中只有英文语言，因此是不能显示汉字的。要正确显示汉字，需要安装中文语言包。安装中文支持步骤 1.单击左侧图标栏打开SystemSettings（系统设置）菜单，点击打开LanguageSupport（语言支持）选项卡。 2.点击Install/RemoveLanguages，在弹出的选项卡中下拉找到Chinese(Simplified)，即中文简体，在后面的选项框中打勾。然后点击ApplyChanges提交，系统会自动联网下载中文语言包。（保证ubuntu是联网的）。 3.这时“汉语（中国）”在最后一位因为当前第一位是”English”，所以默认显示都是英文。我们如果希望默认显示用中文，则应该将“汉语（中国）”设置为第一位。设置方法是拖动，鼠标单击“汉语（中国）”，当底色变化（表示选中了）后，按住鼠标左键不松手，向上拖动放置到第一位。 4.设置后不会即刻生效，需要下一次登录时才会生效。 ==如果中文包下载时间过长，可以给ubuntu换源（阿里源）；== 18.3Ubuntu的roo用户18.3.1介绍 安装ubuntu成功后，都是普通用户权限，并没有最高root权限，如果需要使用root权限的时候，通常都会在命令前面加上sudo。 有的时候感觉很麻烦。我们一般使用su命令来直接切换到root用户的，但是如果没有给root设置初始密码，就会抛出su:Authentication failure这样的问题。所以，我们只要给root用户设置一个初始密码就好了。 18.3.2 给root用户设置密码并使用 1)输入sudo passwd命令，输入一般用户密码并设定root用户密码。 2)设定root密码成功后，输入su命令，并输入刚才设定的root密码，就可以切换成root了。提示符$代表一般用户，提示符#代表root用户。3)输入exit命令，退出root并返回一般用户4)以后就可以使用root用户了 123456789nicolas@ubuntu:~$ sudo passwd[sudo] nicolas 的密码： 对不起，请重试。[sudo] nicolas 的密码： 对不起，请重试。[sudo] nicolas 的密码： 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 18.4Ubuntu下开发Python 18.4.1说明安装好Ubuntu后，默认就已经安装好Python的开发环境[Python2.7和Python3.5] 123456789nicolas@ubuntu:~$ pythonPython 2.7.12 (default, Nov 19 2016, 06:48:10) [GCC 5.4.0 20160609] on linux2Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; nicolas@ubuntu:~$ python3Python 3.5.2 (default, Nov 17 2016, 17:05:23) [GCC 5.4.0 20160609] on linuxType \"help\", \"copyright\", \"credits\" or \"license\" for more information. 18.4.2在Ubuntu下开发一个Python程序 1)vim hello.py[编写hello.py] 提示：如果Ubuntu没有vim我们可以根据提示信息安装一个vim 1sudo apt install vim 19.Python篇apt软件管理和远程登录19.1apt介绍apt是Advanced Packaging Tool的简称，是一款安装包管理工具。在Ubuntu下，我们可以使用apt命令可用于软件包的安装、删除、清理等，类似于Windows中的软件管理工具。 unbuntu软件管理的原理示意图： 19.2Ubuntu软件操作的相关命令 sudo apt-get update更新源 sudo apt-get install package安装包 sudo apt-get remove package删除包 sudo apt-cache search package搜索软件包 sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package–reinstall重新安装包 sudoapt-get-finstall修复安装 sudoapt-getremovepackage–purge删除包，包括配置文件等 sudoapt-getbuild-deppackage安装相关的编译环境 sudoapt-getupgrade更新已安装的包 sudoapt-getdist-upgrade升级系统 sudoapt-cachedependspackage了解使用该包依赖那些包 sudoapt-cacherdependspackage查看该包被哪些包依赖 sudoapt-getsourcepackage下载该包的源代码 19.3更新Ubuntu软件下载地址19.3.1原理示意图 19.3.2寻找国内镜像源 https://mirrors.tuna.tsinghua.edu.cn/ 所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore 19.3.3 备份Ubuntu默认的源地址 123456nicolas@ubuntu:/etc/apt$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup #拷贝root@ubuntu:/etc/apt# echo '' &gt; sources.list #清空root@ubuntu:/etc/apt# vim sources.list #拷贝清华镜像root@ubuntu:/etc/apt# exitexitnicolas@ubuntu:~$ sudo apt-get update #更新ubuntu软件列表 19.5使用ssh远程登录Ubuntu19.5.1ssh介绍 SSH为SecureShell的缩写，由IETF的网络工作小组（NetworkWorkingGroup）所制定；SSH为建立在应用层和传输层基础上的安全协议。 SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录，以及用户之间进行资料拷贝。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。 使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。和CentOS不一样，Ubuntu默认没有安装SSHD服务，因此，我们不能进行远程登录。 19.6使用ssh远程登录Ubuntu19.6.1安装SSH和启用 1nicolas@ubuntu:~$ sudo apt-get install openssh-server 执行上面指令后，在当前这台Linux上就安装了SSH服务端和客户端。 1nicolas@ubuntu:~$ service sshd restart 执行上面的指令，就启动了sshd服务。会监听端口22 1234567891011121314151617181920212223242526nicolas@ubuntu:~$ netstat -anp | more（并非所有进程都能被检测到，所有非本用户的进程信息将不会显示，如果想看到所有信息，则必须切换到 root 用户）激活Internet连接 (服务器和已建立连接的)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program nametcp 0 0 127.0.1.1:53 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 0.0.0.0:631 0.0.0.0:* - udp 0 0 0.0.0.0:36829 0.0.0.0:* - udp 0 0 127.0.1.1:53 0.0.0.0:* - udp 0 0 0.0.0.0:68 0.0.0.0:* - udp 0 0 0.0.0.0:5353 0.0.0.0:* - udp6 0 0 :::50035 :::* - udp6 0 0 :::5353 :::* - --更多-- 19.6.2在Windows使用XShell5/XFTP5登录Ubuntu 前面我们已经安装了XShell5，直接使用即可。 注意：使用atguigu用户登录，需要的时候再su-切换成root用户 19.6.3从linux系统客户机远程登陆linux 系统服务机首先，我们需要在linux的系统客户机也要安装openssh-server •基本语法：ssh 用户名@IP 例如：sshatguigu@192.168.188.131使用ssh访问，如访问出现错误。可查看是否有该文件～/.ssh/known_ssh尝试删除该文件解决。 •登出登出命令：exit或者logout nohupnohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 nohup 是 no hang up 的缩写，就是不挂断的意思。 nohup命令： 如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。 案例 nohup command &gt; myout.file 2&gt;&amp;1 &amp; 在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ； 2&gt;&amp;1是将标准错误（2）重定向到标准输出（&amp;1），标准输出（&amp;1）再被重定向输入到myout.file文件中。 \\2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py &gt; /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2&gt;&amp;1 这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中 常见问题每次进入命令都要重新source /etc/profile 才能生效如java命令 1、也可以放在/.bashrc里面。或者在/.bashrc里面加一句source /etc/profile2、你可以把这几条命令写在 /etc/bash里面 就会自动执行了","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://codeofli.github.io/categories/学习笔记/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://codeofli.github.io/tags/linux/"}]},{"title":"springBoot高级","slug":"java-note/springBoot-high","date":"2019-10-09T07:43:44.000Z","updated":"2019-11-12T02:56:58.306Z","comments":true,"path":"2019/10/java-note/springBoot-high/","link":"","permalink":"https://codeofli.github.io/2019/10/java-note/springBoot-high/","excerpt":"spring boot高级[TOC]一.Spring Boot与缓存1、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。•CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。","text":"spring boot高级[TOC]一.Spring Boot与缓存1、JSR107Java Caching定义了5个核心接口，分别是CachingProvider, CacheManager, Cache, Entry 和 Expiry。•CachingProvider定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期访问多个CachingProvider。 •CacheManager定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。 •Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。 •Entry是一个存储在Cache中的key-value对。 •Expiry 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（**Cache**）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @**CacheEvict** 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 一、搭建基本环境 1、导入数据库文件 创建出department和employee表 2、创建javaBean封装数据 3、整合MyBatis操作数据库 1.配置数据源信息 2.使用注解版的MyBatis； 1）、@MapperScan指定需要扫描的mapper接口所在的包 2、快速体验缓存==注意：cache注解（CachePut、Cacheable、@CachePut）的key保持一致，这样才能在cachemap中拿到同一个数据== @CacheConfig注解抽取缓存的公共配置 123@CacheConfig(cacheNames=\"emp\",cacheManager = \"employeeCacheManager\") //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; 步骤： ==1、开启基于注解的缓存 @EnableCaching== 123456789@EnableCaching@MapperScan(value = \"com.yoj.web.dao\")@SpringBootApplicationpublic class YojApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(YojApplication.class, args); &#125;&#125; 2、标注缓存注解即可 @Cacheable @CacheEvict @CachePut 123456/* * 默认使用的是ConcurrentMapCacheManager==ConcurrentMapCache；将数据保存在 ConcurrentMap&lt;Object, Object&gt;中 * 开发中使用缓存中间件；redis、memcached、ehcache； * * */ service层使用cache注解 缓存中能使用的spel表达式 Cache* SpEL available metadata 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false） #result @Cacheable注解原理： 1、自动配置类；CacheAutoConfiguration 2、缓存的配置类(11) 1234567891011org.springframework.boot.autoconfigure.cache.GenericCacheConfigurationorg.springframework.boot.autoconfigure.cache.JCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.EhCacheCacheConfigurationorg.springframework.boot.autoconfigure.cache.HazelcastCacheConfigurationorg.springframework.boot.autoconfigure.cache.InfinispanCacheConfigurationorg.springframework.boot.autoconfigure.cache.CouchbaseCacheConfigurationorg.springframework.boot.autoconfigure.cache.RedisCacheConfigurationorg.springframework.boot.autoconfigure.cache.CaffeineCacheConfigurationorg.springframework.boot.autoconfigure.cache.GuavaCacheConfigurationorg.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration 3、哪个配置类默认生效：SimpleCacheConfiguration； 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； 运行流程：(ConcurrentMapCacheManager.class) @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 123456789101112131415@Override@Nullablepublic Cache getCache(String name) &#123; Cache cache = this.cacheMap.get(name); if (cache == null &amp;&amp; this.dynamic) &#123; synchronized (this.cacheMap) &#123; cache = this.cacheMap.get(name); if (cache == null) &#123; cache = createConcurrentMapCache(name); this.cacheMap.put(name, cache); &#125; &#125; &#125; return cache;&#125; 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； 123protected Object lookup(Object key) &#123; return this.store.get(key);&#125; key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； 12345678public abstract class CacheAspectSupport extends AbstractCacheInvokerprotected Object generateKey(@Nullable Object result) &#123; if (StringUtils.hasText(this.metadata.operation.getKey())) &#123; EvaluationContext evaluationContext = createEvaluationContext(result); return evaluator.key(this.metadata.operation.getKey(), this.metadata.methodKey, evaluationContext); &#125; return this.metadata.keyGenerator.generate(this.target, this.metadata.method, this.args);&#125; SimpleKeyGenerator生成key的默认策略； 如果没有参数；key=new SimpleKey()； 如果有一个参数：key=参数的值 如果有多个参数：key=new SimpleKey(params)； 12345678910111213141516public class SimpleKeyGenerator implements KeyGenerator &#123; /*** Generate a key based on the specified parameters.*/public static Object generateKey(Object... params) &#123; if (params.length == 0) &#123; return SimpleKey.EMPTY; &#125; if (params.length == 1) &#123; Object param = params[0]; if (param != null &amp;&amp; !param.getClass().isArray()) &#123; return param; &#125; &#125; return new SimpleKey(params);&#125; 3、没有查到缓存就调用目标方法； 4、将目标方法返回的结果，放进缓存中 123public void put(Object key, @Nullable Object value) &#123; this.store.put(key, toStoreValue(value));&#125; @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； ==核心：== 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator 几个属性： cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] getEmp[2] ： **key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;**1@Cacheable(cacheNames = &#123;\"emp\"&#125;,key = \"#root.methodName+'['+#id+']'\") keyGenerator：key的生成器；可以自己指定key的生成器的组件id key/keyGenerator：二选一使用;123456789101112131415@Configurationpublic class MyCacheConfig &#123; @Bean(\"myKeyGenerator\") public KeyGenerator keyGenerator()&#123; return new KeyGenerator()&#123; @Override public Object generate(Object target, Method method, Object... params) &#123; return method.getName()+\"[\"+ Arrays.asList(params).toString()+\"]\"; &#125; &#125;; &#125;&#125;//调用 @Cacheable(cacheNames = &#123;\"emp\"&#125;,keyGenerator = \"myKeyGenerator\") cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 condition：指定符合条件的情况下才缓存； ,condition = &quot;#id&gt;0&quot; condition = &quot;#a0&gt;1&quot;：第一个参数的值 &gt;1的时候才进行缓存 unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 unless = &quot;#result == null&quot; unless = &quot;#a0==2&quot;:如果第一个参数的值是2，结果不缓存； sync：是否使用异步模式,启用sync就不能使用unless属性了 1234567891011121314151617181920212223242526272829303132333435363738@CacheConfig(cacheNames=\"emp\"/*,cacheManager = \"employeeCacheManager\"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * * @param id * @return * */ @Cacheable(value = &#123;\"emp\"&#125;/*,keyGenerator = \"myKeyGenerator\",condition = \"#a0&gt;1\",unless = \"#a0==2\"*/) public Employee getEmp(Integer id)&#123; System.out.println(\"查询\"+id+\"号员工\"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; @CachePut注解@CachePut：既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； 运行时机：1、先调用目标方法2、将目标方法的结果缓存起来 12345678910111213141516171819202122/** * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = \"#employee.id\":使用传入的参数的员工id； * key = \"#result.id\"：使用返回后的id * @Cacheable的key是不能用#result * 为什么是没更新前的？【1号员工没有在缓存中更新】 * */@CachePut(/*value = \"emp\",*/key = \"#result.id\")public Employee updateEmp(Employee employee)&#123; System.out.println(\"updateEmp:\"+employee); employeeMapper.updateEmp(employee); return employee;&#125; @CacheEvict注解evict：驱逐，逐出 @CacheEvict：缓存清除 key：指定要清除的数据 -allEntries = true：指定清除这个缓存中所有的数据 beforeInvocation = false：缓存的清除是否在方法之前执行默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 beforeInvocation = true：代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 123456@CacheEvict(value=\"emp\",beforeInvocation = true/*key = \"#id\",*/)public void deleteEmp(Integer id)&#123; System.out.println(\"deleteEmp:\"+id); //employeeMapper.deleteEmpById(id); int i = 10/0;&#125; @Caching注解定义复杂的缓存规则 12345678910111213// @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName)&#123; return employeeMapper.getEmpByLastName(lastName); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package com.atguigu.springboot01cache.service;import com.atguigu.springboot01cache.bean.Employee;import com.atguigu.springboot01cache.mapper.EmployeeMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;@CacheConfig(cacheNames = \"emp\"/*,cacheManager = \"employeeCacheManager\"*/) //抽取缓存的公共配置@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中获取，不用调用方法； * CacheManager管理多个Cache组件的，对缓存的真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字； * &lt;p&gt; * &lt;p&gt; * &lt;p&gt; * 原理： * 1、自动配置类；CacheAutoConfiguration * 2、缓存的配置类 * org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration * org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration * org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration * org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration * org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration * org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration * org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration * org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration * org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 * org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration * 3、哪个配置类默认生效：SimpleCacheConfiguration； * &lt;p&gt; * 4、给容器中注册了一个CacheManager：ConcurrentMapCacheManager * 5、可以获取和创建ConcurrentMapCache类型的缓存组件；他的作用将数据保存在ConcurrentMap中； * &lt;p&gt; * 运行流程： * * @param id * @return * @Cacheable： 1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取； * （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。 * 2、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数； * key是按照某种策略生成的；默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key； * SimpleKeyGenerator生成key的默认策略； * 如果没有参数；key=new SimpleKey()； * 如果有一个参数：key=参数的值 * 如果有多个参数：key=new SimpleKey(params)； * 3、没有查到缓存就调用目标方法； * 4、将目标方法返回的结果，放进缓存中 * @Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存， 如果没有就运行方法并将结果放入缓存；以后再来调用就可以直接使用缓存中的数据； * &lt;p&gt; * 核心： * 1）、使用CacheManager【ConcurrentMapCacheManager】按照名字得到Cache【ConcurrentMapCache】组件 * 2）、key使用keyGenerator生成的，默认是SimpleKeyGenerator * &lt;p&gt; * &lt;p&gt; * 几个属性： * cacheNames/value：指定缓存组件的名字;将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存； * &lt;p&gt; * key：缓存数据使用的key；可以用它来指定。默认是使用方法参数的值 1-方法的返回值 * 编写SpEL； #i d;参数id的值 #a0 #p0 #root.args[0] * getEmp[2] * &lt;p&gt; * keyGenerator：key的生成器；可以自己指定key的生成器的组件id * key/keyGenerator：二选一使用; * &lt;p&gt; * &lt;p&gt; * cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器 * &lt;p&gt; * condition：指定符合条件的情况下才缓存； * ,condition = \"#id&gt;0\" * condition = \"#a0&gt;1\"：第一个参数的值》1的时候才进行缓存 * &lt;p&gt; * unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断 * unless = \"#result == null\" * unless = \"#a0==2\":如果第一个参数的值是2，结果不缓存； * sync：是否使用异步模式 */ @Cacheable(value = &#123;\"emp\"&#125;/*,keyGenerator = \"myKeyGenerator\",condition = \"#a0&gt;1\",unless = \"#a0==2\"*/) public Employee getEmp(Integer id) &#123; System.out.println(\"查询\" + id + \"号员工\"); Employee emp = employeeMapper.getEmpById(id); return emp; &#125; /** * @CachePut：既调用方法，又更新缓存数据；同步更新缓存 修改了数据库的某个数据，同时更新缓存； * 运行时机： * 1、先调用目标方法 * 2、将目标方法的结果缓存起来 * &lt;p&gt; * 测试步骤： * 1、查询1号员工；查到的结果会放在缓存中； * key：1 value：lastName：张三 * 2、以后查询还是之前的结果 * 3、更新1号员工；【lastName:zhangsan；gender:0】 * 将方法的返回值也放进缓存了； * key：传入的employee对象 值：返回的employee对象； * 4、查询1号员工？ * 应该是更新后的员工； * key = \"#employee.id\":使用传入的参数的员工id； * key = \"#result.id\"：使用返回后的id * @Cacheable的key是不能用#result 为什么是没更新前的？【1号员工没有在缓存中更新】 */ @CachePut(value = \"emp\", key = \"#result.id\") public Employee updateEmp(Employee employee) &#123; System.out.println(\"updateEmp:\" + employee); employeeMapper.updateEmp(employee); return employee; &#125; /** * @CacheEvict：缓存清除 key：指定要清除的数据 * allEntries = true：指定清除这个缓存中所有的数据 * beforeInvocation = false：缓存的清除是否在方法之前执行 * 默认代表缓存清除操作是在方法执行之后执行;如果出现异常缓存就不会清除 * &lt;p&gt; * beforeInvocation = true： * 代表清除缓存操作是在方法运行之前执行，无论方法是否出现异常，缓存都清除 */ @CacheEvict(value = \"emp\", beforeInvocation = true/*key = \"#id\",*/) public void deleteEmp(Integer id) &#123; System.out.println(\"deleteEmp:\" + id); //employeeMapper.deleteEmpById(id); int i = 10 / 0; &#125; // @Caching 定义复杂的缓存规则 @Caching( cacheable = &#123; @Cacheable(/*value=\"emp\",*/key = \"#lastName\") &#125;, put = &#123; @CachePut(/*value=\"emp\",*/key = \"#result.id\"), @CachePut(/*value=\"emp\",*/key = \"#result.email\") &#125; ) public Employee getEmpByLastName(String lastName) &#123; return employeeMapper.getEmpByLastName(lastName); &#125;&#125; 3.整合redis作为缓存 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 原理：CacheManager===Cache 缓存组件来实际给缓存中存取数据 1）、引入redis的starter，容器中保存的是 RedisCacheManager； 2）、RedisCacheManager 帮我们创建 RedisCache 来作为缓存组件；RedisCache通过操作redis缓存数据的 3）、默认保存数据 kv 都是Object；利用序列化保存；如何保存为json 1、引入了redis的starter，cacheManager变为 RedisCacheManager； 2、默认创建的 RedisCacheManager 操作redis的时候使用的是 RedisTemplate&lt;Object, Object&gt; 3、RedisTemplate&lt;Object, Object&gt; 是 默认使用jdk的序列化机制 4）、自定义CacheManager； 1、安装redis：使用docker；启动redis，默认端口6379 123456[root@MiWiFi-R3A-srv ~]# docker run -d -p 6379:6379 --name myredis redisba86c7f5d285b74828df3ec4f0179cfcd3682dc58f2cfabe354a63336d94919e#开启持久化docker run -d -p 6379:6379 --name persistent-redis redis --appendonly yesdocker run --name=\"redis-2\" -d -p 6378:6379 -v /home/fr/redis:/opt royfans/redis:v1 /usr/local/redis/bin/redis-server /usr/local/redis/redis.conf --appendonly yes ==注意==：如果不开启持久化，会导致一段时间不用缓存之后，连接不上redis start with persistent storage 123docker run -v /myredis/conf/redis.conf:/home/ubuntu/redis/redis.conf -d -p 6379:6379 --name config-redis redis --appendonly yes$ docker run --name some-redis -d redis redis-server --appendonly yes 1$ docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf Where /myredis/conf/ is a local directory containing your redis.conf file. Using this method means that there is no need for you to have a Dockerfile for your redis container. 123456这个问题我们在项目中遇到同样的问题，目前已经解决了。最终得到的答案是： 服务器不稳定造成的。您可以尝试这样解决：1.推荐使用生产环境的服务器，并且将redis 绑定生产环境的ip;因为云服务器的ip 地址是很稳定的，而本地服务的ip地址经常是变动的；经 过测试，这种每过10分就会重新请求连接，还会发生重试失败的情况，就是因为服务器不稳定造成的；2.如果你在生产环境中，使用docker 部署，建议 不要在docker容器中 安装redis; 因为docker 容器 默认分配的ip 地址，也可能是变化的； 您可以直接将redis 安装在 服务器目录下，即可； redis desktop manager连接 ![1565350310934](redis desktop manager连接.png) 2、引入redis的starter1.引入spring-boot-starter-data-redis 12345&lt;!--引入redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 3、配置redis12#指定主机端口号spring.redis.host=192.168.31.39 4、测试缓存3.使用RestTemplate操作redis 1.redisTemplate.opsForValue();//操作字符串 2.redisTemplate.opsForHash();//操作hash 3.redisTemplate.opsForList();//操作list 4.redisTemplate.opsForSet();//操作set 5.redisTemplate.opsForZSet();//操作有序set 4.配置缓存、CacheManagerCustomizers 5.测试使用缓存、切换缓存、 CompositeCacheManager ==stringRedisTemplate== //操作k-v都是字符串的 1234567891011121314151617181920212223@AutowiredStringRedisTemplate stringRedisTemplate; //操作k-v都是字符串的/** * Redis常见的五大数据类型 * String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合） * stringRedisTemplate.opsForValue()[String（字符串）] * stringRedisTemplate.opsForList()[List（列表）] * stringRedisTemplate.opsForSet()[Set（集合）] * stringRedisTemplate.opsForHash()[Hash（散列）] * stringRedisTemplate.opsForZSet()[ZSet（有序集合）] */@Testpublic void test01()&#123; //给redis中保存数据 //stringRedisTemplate.opsForValue().append(\"msg\",\"hello\"); //获取数据 // String msg = stringRedisTemplate.opsForValue().get(\"msg\"); // System.out.println(msg); //保存list集合数据 stringRedisTemplate.opsForList().leftPush(\"mylist\",\"1\"); stringRedisTemplate.opsForList().leftPush(\"mylist\",\"2\");&#125; ==redisTemplate== k-v都是对象 12345678910111213141516 @Autowired RedisTemplate redisTemplate; //k-v都是对象的 @Autowired RedisTemplate&lt;Object,Object&gt; empRedisTemplate; //自定义缓存规则配置的redisTemplate//测试保存对象 @Test public void test02()&#123; Employee empById = employeeMapper.getEmpById(1); //默认如果保存对象，使用jdk序列化机制，序列化后的数据保存到redis中 //redisTemplate.opsForValue().set(\"emp-01\",empById); //1、将数据以json的方式保存 //(1)自己将对象转为json //(2)redisTemplate默认的序列化规则；改变默认的序列化规则； empRedisTemplate.opsForValue().set(\"emp-01\",empById); &#125; 5.使用Json格式序列化对象1.使用setKey和value的Serializer方法 123redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class)); redisTemplate.setKeySerializer(new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class)); redisTemplate.opsForValue().set(\"emp-02\",empById); 123456789101112@Configurationpublic class MyRedisConfig &#123; @Bean public RedisTemplate&lt;Object, Object&gt; empRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(serializer); return template; &#125; 2.0配置redis的CacheManager1234spring: cache: redis: timeToLive: 1000000 #毫秒 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.atguigu.springboot01cache.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.time.Duration;@Configurationpublic class MyRedisConfig &#123;// @Bean// public RedisTemplate&lt;Object, Object&gt; empRedisTemplate(RedisConnectionFactory redisConnectionFactory)// throws UnknownHostException &#123;// RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();// template.setConnectionFactory(redisConnectionFactory);// Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class);// template.setDefaultSerializer(serializer);// return template;// &#125; private Duration timeToLive = Duration.ZERO; public void setTimeToLive(Duration timeToLive) &#123; this.timeToLive = timeToLive; &#125; @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题） RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(timeToLive) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; 4.注意1.@CachePut 获取就是返回的值所有想要存入缓存的都是返回的值 my_redis设置缓存时间1stringRedisTemplate.opsForValue().set(email, checkCode,60*10,TimeUnit.SECONDS);//向redis里存入数据和设置缓存时间 删除缓存byKey1stringRedisTemplate.delete(user.getEmail()); 检查时间1stringRedisTemplate.hasKey(\"546545\");//检查key是否存在，返回boolean值 问题redis一段时间之后不连接就连不上==内存原因，设置maxmemory和替换算法== 在Linux上，如果开了redis的守护进程，kill -9和redis-cli shutdown 命令是无法杀掉 redis 进程的 ，杀掉就会重新启动一个新的进程 最后在网上找到这个命令： 1/etc/init.d/redis-server stop 二.Spring Boot与消息JMS、AMQP、RabbitMQ 一、概述1.大多应用中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力 2.消息服务中两个重要概念： ​ 消息代理（message broker）和目的地（destination） 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。 3.消息队列主要有两种形式的目的地 1.队列（queue）：点对点消息通信（point-to-point） 2.主题（topic）：发布（publish）/订阅（subscribe）消息通信 4.点对点式： –消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 –消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 5.发布订阅式： –发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 6.JMS（Java Message Service）JAVA消息服务： –基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现 7.AMQP（Advanced Message Queuing Protocol） –高级消息队列协议，也是一个消息代理的规范，兼容JMS –RabbitMQ是AMQP的实现 JMS AMQP 定义 Java api 网络线级协议 跨语言 否 是 跨平台 否 是 Model 提供两种消息模型： （1）、Peer-2-Peer （2）、Pub/sub 提供了五种消息模型： （1）、direct exchange （2）、fanout exchange （3）、topic change （4）、headers exchange （5）、system exchange 本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分； 支持消息类型 多种消息类型： TextMessage MapMessage BytesMessage StreamMessage ObjectMessage Message （只有消息头和属性） byte[] 当实际应用时，有复杂的消息，可以将消息序列化后发送。 综合评价 JMS 定义了JAVA API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差； AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。 8.Spring支持 –spring-jms提供了对JMS的支持 –spring-rabbit提供了对AMQP的支持 –需要ConnectionFactory的实现来连接消息代理 –提供JmsTemplate、RabbitTemplate来发送消息 –@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息 –@EnableJms、@EnableRabbit开启支持 9.Spring Boot自动配置 –JmsAutoConfiguration –RabbitAutoConfiguration 二、RabbitMQ简介RabbitMQ简介： RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。 核心概念 Message 消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher 消息的生产者，也是一个向交换器发布消息的客户端应用程序。 Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。 Exchange有4种类型：direct(默认)，fanout, topic, 和headers，不同类型的Exchange转发消息的策略有所区别 三、Spring Boot与检索 四.Spring Boot与任务异步任务、定时任务、邮件任务一、异步任务在Java应用中，绝大多数情况下都是通过同步的方式来实现交互处理的；但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务，其实，在Spring 3.x之后，就已经内置了@Async来完美解决这个问题。 两个注解： @EnableAysnc、@Aysnc springbootApplication添加@EnableAysnc注解 12345678@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 编写异步方法，同时执行，并不会等3s才有success 1234567891011121314@Servicepublic class AsyncService &#123; //告诉Spring这是一个异步方法 @Async public void hello()&#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"处理数据中...\"); &#125;&#125; 二、定时任务@EnableScheduling //开启基于注解的定时任务 123456789@EnableScheduling //开启基于注解的定时任务@SpringBootApplicationpublic class Springboot04TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot04TaskApplication.class, args); &#125;&#125; 编写定时方法 1234567891011121314151617181920@Servicepublic class ScheduledService &#123; /** * second(秒), minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 0 * * * * MON-FRI * 【0 0/5 14,18 * * ?】 每天14点整，和18点整，每隔5分钟执行一次 * 【0 15 10 ? * 1-6】 每个月的周一至周六10:15分执行一次 * 【0 0 2 ? * 6L】每个月的最后一个周六凌晨2点执行一次 * 【0 0 2 LW * ?】每个月的最后一个工作日凌晨2点执行一次 * 【0 0 2-4 ? * 1#1】每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */// @Scheduled(cron = \"0 * * * * MON-SAT\")// @Scheduled(cron = \"0,1,2,3,4 * * * * MON-SAT\") // @Scheduled(cron = \"0-4 * * * * MON-SAT\") @Scheduled(cron = \"0/4 * * * * MON-SAT\") //每4秒执行一次 public void hello()&#123; System.out.println(\"hello ... \"); &#125;&#125; 两个注解：@EnableScheduling、@Scheduled cron表达式： 字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 , - * / 星期 0-7或SUN-SAT 0,7是SUN , - * ? / L C # 特殊字符 代表含义 , 枚举 - 区间 * 任意 / 步长 ? 日/星期冲突匹配 L 最后 W 工作日 C 和calendar联系后计算过的值 # 星期，4#2，第2个星期四 三、邮件任务•邮件发送需要引入spring-boot-starter-mail •Spring Boot 自动配置MailSenderAutoConfiguration •定义MailProperties内容，配置在application.yml中 •自动装配JavaMailSender •测试邮件发送 1.导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 2.配置信息 1)首先在qq邮箱开通相关的服务 拿到的授权码即为password 12345678spring.mail.username=1162314270@qq.comspring.mail.password=kykperaulxvigjbhspring.mail.host=smtp.qq.com#503错误，我的没有这个错#spring.mail.properties.mail.smtp.ssl.enable=true#ggjhtotqoeahihgb#cnfyhrjcbacvgjaf#kykperaulxvigjbh 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringRunner.class)@SpringBootTestpublic class Springboot04TaskApplicationTests &#123; @Autowired JavaMailSenderImpl mailSender; @Test public void contextLoads() &#123; SimpleMailMessage message = new SimpleMailMessage(); //邮件设置 message.setSubject(\"通知-今晚开会\"); message.setText(\"今晚7:30开会\"); message.setTo(\"407820388@qq.com\"); message.setFrom(\"1162314270@qq.com\"); mailSender.send(message); &#125; @Test public void test02() throws Exception&#123; //1、创建一个复杂的消息邮件 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); //邮件设置 helper.setSubject(\"通知-今晚开会\"); helper.setText(\"&lt;b style='color:red'&gt;今天 7:30 开会&lt;/b&gt;\",true); helper.setTo(\"407820388@qq.com\"); helper.setFrom(\"1162314270@qq.com\"); //上传文件 helper.addAttachment(\"1.jpg\",new File(\"E:\\\\pictures\\\\desktop view.png\")); helper.addAttachment(\"2.jpg\",new File(\"E:\\\\pictures\\\\e.png\")); mailSender.send(mimeMessage); &#125;&#125; 五.Spring Boot与安全一、安全Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型。他可以实现强大的web安全控制。对于安全控制，我们仅需引入spring-boot-starter-security模块，进行少量的配置，即可实现强大的安全管理。 几个类： WebSecurityConfigurerAdapter：自定义Security策略 AuthenticationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 “认证”和“授权”•应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是Spring Security 的两个目标。 •“认证”（Authentication），是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统）。 •“授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程。为了抵达需要授权的店，主体的身份已经有认证过程建立。 •这个概念是通用的而不只在Spring Security中。 二、Web&amp;安全1.登陆/注销 –HttpSecurity配置登陆、注销功能 2.Thymeleaf提供的SpringSecurity标签支持 –需要引入thymeleaf-extras-springsecurity5（版本要一致） –sec:authentication=“name”获得当前用户的用户名 –sec:authorize=“hasRole(‘ADMIN’)”当前用户必须拥有ADMIN权限时才会显示标签内容 3.remember me –表单添加remember-me的checkbox –配置启用remember-me功能 4.CSRF（Cross-site request forgery）跨站请求伪造 HttpSecurity启用功能，会为表单添加csrfCSRF 使用SpringSecurity官方文档 1、引入SpringSecurity；1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 2、编写SpringSecurity的配置类；使用之间需要PasswordEncoder的bean存在 使用springboot，权限管理使用spring security，使用内存用户验证，但无响应报错：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”解决方法：这是因为Spring boot 2.0.3引用的security 依赖是 spring security 5.X版本，此版本需要提供一个PasswordEncorder的实例，否则后台汇报错误：java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”并且页面毫无响应。因此，需要创建PasswordEncorder的实现类。 1234567891011121314151617package springboot05security.nicolas.config;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;@Componentpublic class MyPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; return s.equals(charSequence.toString()); &#125;&#125; 自定义securityConfig需要继承WebSecurityConfigurerAdapter 3、控制请求的访问权限：configure(HttpSecurity http) {http.authorizeRequests().antMatchers(“/“).permitAll().antMatchers(“/level1/**”).hasRole(“VIP1”)} 4、定义认证规则：configure(AuthenticationManagerBuilder auth){auth.inMemoryAuthentication().withUser(“zhangsan”).password(“123456”).roles(“VIP1”,”VIP2”)} 123456789101112131415161718192021//定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\", \"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\", \"VIP3\"); /**有以下几种形式，使用第3种*/ //inMemoryAuthentication 从内存中获取 //auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(\"user1\").password(new BCryptPasswordEncoder().encode(\"123123\")).roles(\"USER\"); //jdbcAuthentication从数据库中获取，但是默认是以security提供的表结构 //usersByUsernameQuery 指定查询用户SQL //authoritiesByUsernameQuery 指定查询权限SQL //auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(query).authoritiesByUsernameQuery(query); //注入userDetailsService，需要实现userDetailsService接口 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); ==使用注入userDetailsService，需要实现userDetailsService接口== 1234567891011121314151617@Servicepublic class UserService implements UserDetailsService &#123; @Autowired UserMapper userMapper; @Autowired PrivilegeService privilegeService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; User user = userMapper.getUserByName(username); if(user == null)&#123; throw new UsernameNotFoundException(\"没有该用户\"); &#125; return new UserDetailsImpl(user, privilegeService.queryByUserId(user.getUserId())); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@ToStringpublic class UserDetailsImpl implements UserDetails&#123; private User user; private String username; private String password; //包含着用户对应的所有Privilege，在使用时调用者给对象注入Privileges private List&lt;Privilege&gt; privilege; @Autowired private com.yoj.web.service.PrivilegeService PrivilegeService; public void setPrivilege(List&lt;Privilege&gt; privilege) &#123; this.privilege = privilege; &#125; //无参构造 public UserDetailsImpl() &#123; &#125; //用User构造 public UserDetailsImpl(User user) &#123; this.username = user.getUserName(); this.password = user.getPassword(); this.user = user; &#125; //用User和List&lt;Privilege&gt;构造 public UserDetailsImpl(User user,List&lt;Privilege&gt; Privileges) &#123; this.user = user; this.username = user.getUserName(); this.password = user.getPassword(); this.privilege = Privileges; &#125; public List&lt;Privilege&gt; getPrivilege() &#123; return privilege; &#125; @Override //返回用户所有角色的封装，一个Privilege对应一个GrantedAuthority public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); for(Privilege Privilege : privilege) &#123; authorities.add(new SimpleGrantedAuthority(Privilege.getRight())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; @Override //判断账号是否已经过期，默认没有过期 public boolean isAccountNonExpired() &#123; return true; &#125; @Override //判断账号是否被锁定，默认没有锁定 public boolean isAccountNonLocked() &#123; return true; &#125; @Override //判断信用凭证是否过期，默认没有过期 public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override //判断账号是否可用，默认可用 public boolean isEnabled() &#123; return true; &#125;&#125; 5、开启自动配置的登陆功能：1、/login来到登陆页2、重定向到/login?error表示登陆失败3、更多详细规定4、默认post形式的 /login代表处理登陆5、一但定制loginPage；那么 loginPage的post请求就是登陆 123456@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); configure(HttpSecurity http){http.formLogin();} 6、注销：http.logout();注意logout时需要表单中的按钮 1、访问 /logout 表示用户注销，清空session2、注销成功会返回 /login?logout 页面； 1http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 123&lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt;&lt;/form&gt; 7、记住我：Remeberme() 123456&lt;form th:action=\"@&#123;/userlogin&#125;\" method=\"post\"&gt; 用户名:&lt;input name=\"user\"/&gt;&lt;br&gt; 密码:&lt;input name=\"pwd\"&gt;&lt;br/&gt; &lt;input type=\"checkbox\" name=\"remember\"&gt; 记住我&lt;br/&gt; &lt;input type=\"submit\" value=\"登陆\"&gt;&lt;/form&gt; 8获取UserDetails 12UserDetailsImpl userDetails = (UserDetailsImpl) SecurityContextHolder.getContext().getAuthentication().getPrincipal(); System.out.println(userDetails); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //super.configure(http); //定制请求的授权规则 http.authorizeRequests().antMatchers(\"/\").permitAll() .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); //开启自动配置的登陆功能，效果，如果没有登陆，没有权限就会来到登陆页面 //http.formLogin(); //1、/login来到登陆页 //2、重定向到/login?error表示登陆失败 //3、更多详细规定 //4、默认post形式的 /login代表处理登陆 //5、一但定制loginPage；那么 loginPage的post请求就是登陆 http.formLogin().usernameParameter(\"user\").passwordParameter(\"pwd\") .loginPage(\"/userlogin\"); //开启自动配置的注销功能。// http.logout(); //1、访问 /logout 表示用户注销，清空session //2、注销成功会返回 /login?logout 页面； http.logout().logoutSuccessUrl(\"/\");//注销成功以后来到首页 //开启记住我功能// http.rememberMe(); //登陆成功以后，将cookie发给浏览器保存，以后访问页面带上这个cookie，只要通过检查就可以免登录 //点击注销会删除cookie http.rememberMe().rememberMeParameter(\"remember\"); &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; //super.configure(auth); auth.inMemoryAuthentication() .withUser(\"zhangsan\").password(\"123456\").roles(\"VIP1\", \"VIP2\") .and() .withUser(\"lisi\").password(\"123456\").roles(\"VIP2\", \"VIP3\") .and() .withUser(\"wangwu\").password(\"123456\").roles(\"VIP1\", \"VIP3\"); /**有以下几种形式，使用第3种*/ //inMemoryAuthentication 从内存中获取 //auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(\"user1\").password(new BCryptPasswordEncoder().encode(\"123123\")).roles(\"USER\"); //jdbcAuthentication从数据库中获取，但是默认是以security提供的表结构 //usersByUsernameQuery 指定查询用户SQL //authoritiesByUsernameQuery 指定查询权限SQL //auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(query).authoritiesByUsernameQuery(query); //注入userDetailsService，需要实现userDetailsService接口 auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125;&#125; 定义认证用户信息获取来源，密码校验规则等 Thymeleaf Extras Springsecurity注意：thymeleaf和springsecurity版本一致，Thymeleaf Extras Springsecurity5 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819div sec:authorize=\"!isAuthenticated()\"&gt; &lt;h2 align=\"center\"&gt;游客您好，如果想查看武林秘籍 &lt;a th:href=\"@&#123;/userlogin&#125;\"&gt;请登录&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt;&lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;h2&gt;&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;，您好,您的角色有： &lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt;&lt;/h2&gt; &lt;form th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"注销\"/&gt; &lt;/form&gt;&lt;/div&gt;&lt;hr&gt;&lt;div sec:authorize=\"hasRole('VIP1')\"&gt; &lt;h3&gt;普通武功秘籍&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/1&#125;\"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/2&#125;\"&gt;武当长拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/level1/3&#125;\"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在Spring Security中使用AJAX向后台传送数据本文链接：https://blog.csdn.net/bnrmaster/article/details/52939212 环境：spring 4.2.3 spring security 4.1.3 表现： 2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.csrf.CsrfFilter - Invalid CSRF token found for XXX2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.header.writers.HstsHeaderWriter - Not injecting HSTS header since it did not match the requestMatcher org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@c3339ef2016-10-26 22:44:02 [http-apr-9080-exec-10] DEBUG org.springframework.security.web.context.SecurityContextPersistenceFilter - SecurityContextHolder now cleared, as request processing completed 前台使用AJAX向后台传输数据时候控制台报出上述错误，再未集成Spring Security时不会出现此现象 解决方法： 如果前端使用的JSP 可以在前端页面的标签中增加两个标签 如下 1234567&lt;html&gt;&lt;head&gt; &lt;meta name=\"_csrf\" content=\"$&#123;_csrf.token&#125;\"/&gt; &lt;!-- default header name is X-CSRF-TOKEN --&gt; &lt;meta name=\"_csrf_header\" content=\"$&#123;_csrf.headerName&#125;\"/&gt; &lt;!-- ... --&gt;&lt;/head&gt; 如果前端使用的是Thymeleaf分两种情况 1.前端无form表单,也要再头部增加两个meta标签，形式为 1234567&lt;html&gt;&lt;head&gt; &lt;meta name=\"_csrf\" th:content=\"$&#123;_csrf.token&#125;\" content=\"\"/&gt; &lt;!-- default header name is X-CSRF-TOKEN --&gt; &lt;meta name=\"_csrf_header\" th:content=\"$&#123;_csrf.headerName&#125;\" content=\"\"/&gt; &lt;!-- ... --&gt;&lt;/head&gt; 2.前端有form表单 Spring Security为Thymeleaf中的表单中自动添加一个 (xxxx为crrf.token) 添加完meta之后不妨运行下，在页面代码中搜索_csrf，可以看看附近代码的样子，应该就会明白了 这样在使用AJAX时，需要增加一个头部 12345678910111213141516var token = $(\"meta[name='_csrf']\").attr(\"content\");var header = $(\"meta[name='_csrf_header']\").attr(\"content\"); $.ajax(&#123; type: \"POST\", url: \"myposturl\", data: entID, contentType:\"application/json; charset=utf-8\", headers : &#123;header:token&#125;, async:false, success:function(data)&#123; //do something &#125;, error: function () &#123; //deal width error &#125; &#125;); 实际上，这里的header使用为值”X-CSRF-TOKEN” 这样就可以成功向后台请求了 spring security reference 123456789101112131415161718var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\");var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\");var headers = &#123;&#125;;headers[csrfHeader] = csrfToken;console.log(problem);$.ajax(&#123; url: \"/p/add\", type: \"POST\", headers : headers, data: problem, success(res)&#123; // $(\"id\").add(res); console.log(res); &#125;, error(res)&#123; console.log(res); &#125;&#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt; &lt;meta name=\"description\" content=\"This is the description for this page\" /&gt; &lt;sec:csrfMetaTags /&gt; &lt;script type=\"text/javascript\" language=\"javascript\"&gt; var csrfParameter = $(\"meta[name='_csrf_parameter']\").attr(\"content\"); var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\"); var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\"); // using XMLHttpRequest directly to send an x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(\"POST\", \"https://www.example.org/do/something\", true); ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded data\"); ajax.send(csrfParameter + \"=\" + csrfToken + \"&amp;name=John&amp;...\"); // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request var ajax = new XMLHttpRequest(); ajax.open(\"POST\", \"https://www.example.org/do/something\", true); ajax.setRequestHeader(csrfHeader, csrfToken); ajax.send(\"...\"); // using JQuery to send an x-www-form-urlencoded request var data = &#123;&#125;; data[csrfParameter] = csrfToken; data[\"name\"] = \"John\"; ... $.ajax(&#123; url: \"https://www.example.org/do/something\", type: \"POST\", data: data, ... &#125;); // using JQuery to send a non-x-www-form-urlencoded request var headers = &#123;&#125;; headers[csrfHeader] = csrfToken; $.ajax(&#123; url: \"https://www.example.org/do/something\", type: \"POST\", headers: headers, ... &#125;); &lt;script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 六、Spring Boot与分布式 七、Spring Boot与监控管理 八、Spring Boot与部署 七.开发热部署一、热部署在开发中我们修改一个Java文件后想看到效果不得不重启应用，这导致大量时间花费，我们希望不重启应用的情况下，程序可以自动部署（热部署）。有以下四种情况，如何能实现热部署。 •1、模板引擎 –在Spring Boot中开发情况下禁用模板引擎的cache –页面模板改变ctrl+F9可以重新编译当前页面并生效 2、Spring Loaded Spring官方提供的热部署程序，实现修改类文件的热部署 –下载Spring Loaded（项目地址https://github.com/spring-projects/spring-loaded） –添加运行时参数； -javaagent:C:/springloaded-1.2.5.RELEASE.jar –noverify 3、JRebel –收费的一个热部署软件 –安装插件使用即可 4、Spring Boot Devtools（推荐）–引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; –IDEA使用ctrl+F9 –或做一些小调整 Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。 •设置自动编译（settings-compiler-make project automatically） •ctrl+shift+alt+/（maintenance） •勾选compiler.automake.allow.when.app.running","categories":[{"name":"学习笔记-java","slug":"学习笔记-java","permalink":"https://codeofli.github.io/categories/学习笔记-java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://codeofli.github.io/tags/java/"},{"name":"springBoot","slug":"springBoot","permalink":"https://codeofli.github.io/tags/springBoot/"}]}]}